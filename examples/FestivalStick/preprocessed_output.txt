# 0 "FestivalStick.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "FestivalStick.cpp"
# 1 "../../src/FastLED.h" 1
       



# 1 "../../src/fl/stdint.h" 1
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 145 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 3 4

# 145 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 214 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 425 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 436 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 4 "../../src/fl/stdint.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 415 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 416 "/usr/include/features.h" 2 3 4
# 523 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 730 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 731 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 732 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 524 "/usr/include/features.h" 2 3 4
# 547 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 548 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/stdint-least.h" 3 4
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
# 42 "/usr/include/stdint.h" 2 3 4





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 60 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 76 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 90 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stdint.h" 2 3 4
# 5 "../../src/fl/stdint.h" 2
# 6 "../../src/FastLED.h" 2
# 70 "../../src/FastLED.h"
# 1 "../../src/fl/force_inline.h" 1
       
# 71 "../../src/FastLED.h" 2
# 1 "../../src/cpp_compat.h" 1
       
# 26 "../../src/cpp_compat.h"
# 1 "../../src/fl/register.h" 1
       
# 27 "../../src/cpp_compat.h" 2
# 72 "../../src/FastLED.h" 2

# 1 "../../src/fastled_config.h" 1
       
# 74 "../../src/FastLED.h" 2
# 1 "../../src/led_sysdefs.h" 1
       
# 67 "../../src/led_sysdefs.h"
# 1 "../../src/platforms/stub/led_sysdefs_stub.h" 1
       




# 1 "../../src/platforms/stub/led_sysdefs_stub_generic.h" 1
# 32 "../../src/platforms/stub/led_sysdefs_stub_generic.h"

# 32 "../../src/platforms/stub/led_sysdefs_stub_generic.h"
typedef volatile uint32_t RoReg;
typedef volatile uint32_t RwReg;

extern "C" {
    void pinMode(uint8_t pin, uint8_t mode);

    uint32_t millis(void);
    uint32_t micros(void);

    void delay(int ms);
    void yield(void);
}
# 7 "../../src/platforms/stub/led_sysdefs_stub.h" 2
# 68 "../../src/led_sysdefs.h" 2
# 83 "../../src/led_sysdefs.h"
# 1 "../../src/fl/namespace.h" 1



       
# 84 "../../src/led_sysdefs.h" 2
# 75 "../../src/FastLED.h" 2


# 1 "../../src/fastled_delay.h" 1
       





# 1 "../../src/fl/types.h" 1
       




namespace fl {




typedef int64_t cycle_t;


}
# 8 "../../src/fastled_delay.h" 2












template<int WAIT> class CMinWait {

 uint16_t mLastMicros;

public:

 CMinWait() { mLastMicros = 0; }


 void wait() {
  uint16_t diff;
  do {
   diff = (micros() & 0xFFFF) - mLastMicros;
  } while(diff < WAIT);
 }


 void mark() { mLastMicros = micros() & 0xFFFF; }
};
# 83 "../../src/fastled_delay.h"
template<fl::cycle_t CYCLES> inline void delaycycles();



template<fl::cycle_t CYCLES> inline void delaycycles_min1() {
 delaycycles<1>();
 delaycycles<CYCLES-1>();
}
# 136 "../../src/fastled_delay.h"
template<fl::cycle_t CYCLES> __attribute__((always_inline)) inline void delaycycles() {

 __asm__ __volatile__ ("nop\n");; delaycycles<CYCLES-1>();
}
# 151 "../../src/fastled_delay.h"
template<> __attribute__((always_inline)) inline void delaycycles<-10>() {}
template<> __attribute__((always_inline)) inline void delaycycles<-9>() {}
template<> __attribute__((always_inline)) inline void delaycycles<-8>() {}
template<> __attribute__((always_inline)) inline void delaycycles<-7>() {}
template<> __attribute__((always_inline)) inline void delaycycles<-6>() {}
template<> __attribute__((always_inline)) inline void delaycycles<-5>() {}
template<> __attribute__((always_inline)) inline void delaycycles<-4>() {}
template<> __attribute__((always_inline)) inline void delaycycles<-3>() {}
template<> __attribute__((always_inline)) inline void delaycycles<-2>() {}
template<> __attribute__((always_inline)) inline void delaycycles<-1>() {}
template<> __attribute__((always_inline)) inline void delaycycles<0>() {}
template<> __attribute__((always_inline)) inline void delaycycles<1>() {__asm__ __volatile__ ("nop\n");;}
template<> __attribute__((always_inline)) inline void delaycycles<2>() {__asm__ __volatile__ ("nop\n\t nop\n");;}
template<> __attribute__((always_inline)) inline void delaycycles<3>() {__asm__ __volatile__ ("nop\n");;__asm__ __volatile__ ("nop\n\t nop\n");;}
template<> __attribute__((always_inline)) inline void delaycycles<4>() {__asm__ __volatile__ ("nop\n\t nop\n");;__asm__ __volatile__ ("nop\n\t nop\n");;}
template<> __attribute__((always_inline)) inline void delaycycles<5>() {__asm__ __volatile__ ("nop\n\t nop\n");;__asm__ __volatile__ ("nop\n\t nop\n");;__asm__ __volatile__ ("nop\n");;}
# 218 "../../src/fastled_delay.h"

# 78 "../../src/FastLED.h" 2
# 1 "../../src/bitswap.h" 1
       
# 12 "../../src/bitswap.h"

# 293 "../../src/bitswap.h"

# 79 "../../src/FastLED.h" 2

# 1 "../../src/controller.h" 1
       







# 1 "../../src/cpixel_ledcontroller.h" 1
       




# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 7 "../../src/cpixel_ledcontroller.h" 2



# 1 "../../src/pixeltypes.h" 1
       





# 1 "../../src/lib8tion.h" 1
       





# 1 "../../src/lib8tion/types.h" 1



       





# 36 "../../src/lib8tion/types.h"
typedef uint8_t fract8;




typedef int8_t sfract7;




typedef uint16_t fract16;

typedef int32_t sfract31;

typedef uint32_t fract32;




typedef int16_t sfract15;


typedef uint16_t accum88;
typedef int16_t saccum78;
typedef uint32_t accum1616;
typedef int32_t saccum1516;
typedef uint16_t accum124;
typedef int32_t saccum114;




typedef union {
    uint32_t i;
    float f;
    struct {
        uint32_t mantissa: 23;
        uint32_t exponent: 8;
        uint32_t signbit: 1;
    };
    struct {
        uint32_t mant7 : 7;
        uint32_t mant16: 16;
        uint32_t exp_ : 8;
        uint32_t sb_ : 1;
    };
    struct {
        uint32_t mant_lo8 : 8;
        uint32_t mant_hi16_exp_lo1 : 16;
        uint32_t sb_exphi7 : 8;
    };
} IEEE754binary32_t;





# 8 "../../src/lib8tion.h" 2
# 1 "../../src/fl/deprecated.h" 1
       
# 9 "../../src/lib8tion.h" 2
# 19 "../../src/lib8tion.h"
# 1 "../../src/lib8tion/lib8static.h" 1



       
# 20 "../../src/lib8tion.h" 2
# 1 "../../src/lib8tion/qfx.h" 1
       





# 16 "../../src/lib8tion/qfx.h"
template<class T, int F, int I> class qfx {
    T i:I;
    T f:F;
public:

    qfx(float fx) { i = fx; f = (fx-i) * (1<<F); }

    qfx(uint8_t _i, uint8_t _f) {i=_i; f=_f; }


    uint32_t operator*(uint32_t v) { return (v*i) + ((v*f)>>F); }

    uint16_t operator*(uint16_t v) { return (v*i) + ((v*f)>>F); }

    int32_t operator*(int32_t v) { return (v*i) + ((v*f)>>F); }

    int16_t operator*(int16_t v) { return (v*i) + ((v*f)>>F); }




};

template<class T, int F, int I> static uint32_t operator*(uint32_t v, qfx<T,F,I> & q) { return q * v; }
template<class T, int F, int I> static uint16_t operator*(uint16_t v, qfx<T,F,I> & q) { return q * v; }
template<class T, int F, int I> static int32_t operator*(int32_t v, qfx<T,F,I> & q) { return q * v; }
template<class T, int F, int I> static int16_t operator*(int16_t v, qfx<T,F,I> & q) { return q * v; }





typedef qfx<uint8_t, 4,4> q44;

typedef qfx<uint8_t, 6,2> q62;

typedef qfx<uint16_t, 8,8> q88;

typedef qfx<uint16_t, 12,4> q124;




# 21 "../../src/lib8tion.h" 2
# 1 "../../src/lib8tion/memmove.h" 1
       
# 22 "../../src/lib8tion.h" 2
# 1 "../../src/lib8tion/config.h" 1
       
# 23 "../../src/lib8tion.h" 2
# 1 "../../src/fl/ease.h" 1
       
# 13 "../../src/fl/ease.h"
namespace fl {

enum EaseType {
    EASE_NONE,
    EASE_IN_QUAD,
    EASE_OUT_QUAD,
    EASE_IN_OUT_QUAD,
    EASE_IN_CUBIC,
    EASE_OUT_CUBIC,
    EASE_IN_OUT_CUBIC,
    EASE_IN_SINE,
    EASE_OUT_SINE,
    EASE_IN_OUT_SINE,
};





uint8_t easeInQuad8(uint8_t i);




uint8_t easeOutQuad8(uint8_t i);




uint8_t easeInOutQuad8(uint8_t i);




uint8_t easeInCubic8(uint8_t i);




uint8_t easeOutCubic8(uint8_t i);




uint8_t easeInOutCubic8(uint8_t i);




uint8_t easeInSine8(uint8_t i);




uint8_t easeOutSine8(uint8_t i);




uint8_t easeInOutSine8(uint8_t i);





uint16_t easeInQuad16(uint16_t i);



uint16_t easeOutQuad16(uint16_t i);



uint16_t easeInOutQuad16(uint16_t i);



uint16_t easeInCubic16(uint16_t i);



uint16_t easeOutCubic16(uint16_t i);



uint16_t easeInOutCubic16(uint16_t i);



uint16_t easeInSine16(uint16_t i);



uint16_t easeOutSine16(uint16_t i);



uint16_t easeInOutSine16(uint16_t i);

uint16_t ease16(EaseType type, uint16_t i);
void ease16(EaseType type, uint16_t* src, uint16_t* dst, uint16_t count);
uint8_t ease8(EaseType type, uint8_t i);
void ease8(EaseType type, uint8_t* src, uint8_t* dst, uint8_t count);




inline uint16_t ease16(EaseType type, uint16_t i) {
    switch (type) {
        case EASE_NONE: return i;
        case EASE_IN_QUAD: return easeInQuad16(i);
        case EASE_OUT_QUAD: return easeOutQuad16(i);
        case EASE_IN_OUT_QUAD: return easeInOutQuad16(i);
        case EASE_IN_CUBIC: return easeInCubic16(i);
        case EASE_OUT_CUBIC: return easeOutCubic16(i);
        case EASE_IN_OUT_CUBIC: return easeInOutCubic16(i);
        case EASE_IN_SINE: return easeInSine16(i);
        case EASE_OUT_SINE: return easeOutSine16(i);
        case EASE_IN_OUT_SINE: return easeInOutSine16(i);
        default: return i;
    }
}

inline void ease16(EaseType type, uint16_t* src, uint16_t* dst, uint16_t count) {
    switch (type) {
        case EASE_NONE: return;
        case EASE_IN_QUAD: {
            for (uint16_t i = 0; i < count; i++) {
                dst[i] = easeInQuad16(src[i]);
            }
            break;
        }
        case EASE_OUT_QUAD: {
            for (uint16_t i = 0; i < count; i++) {
                dst[i] = easeOutQuad16(src[i]);
            }
            break;
        }
        case EASE_IN_OUT_QUAD: {
            for (uint16_t i = 0; i < count; i++) {
                dst[i] = easeInOutQuad16(src[i]);
            }
            break;
        }
        case EASE_IN_CUBIC: {
            for (uint16_t i = 0; i < count; i++) {
                dst[i] = easeInCubic16(src[i]);
            }
            break;
        }
        case EASE_OUT_CUBIC: {
            for (uint16_t i = 0; i < count; i++) {
                dst[i] = easeOutCubic16(src[i]);
            }
            break;
        }
        case EASE_IN_OUT_CUBIC: {
            for (uint16_t i = 0; i < count; i++) {
                dst[i] = easeInOutCubic16(src[i]);
            }
            break;
        }
        case EASE_IN_SINE: {
            for (uint16_t i = 0; i < count; i++) {
                dst[i] = easeInSine16(src[i]);
            }
            break;
        }
        case EASE_OUT_SINE: {
            for (uint16_t i = 0; i < count; i++) {
                dst[i] = easeOutSine16(src[i]);
            }
            break;
        }
        case EASE_IN_OUT_SINE: {
            for (uint16_t i = 0; i < count; i++) {
                dst[i] = easeInOutSine16(src[i]);
            }
            break;
        }
    }
}

inline uint8_t ease8(EaseType type, uint8_t i) {
    switch (type) {
        case EASE_NONE: return i;
        case EASE_IN_QUAD: return easeInQuad8(i);
        case EASE_OUT_QUAD: return easeOutQuad8(i);
        case EASE_IN_OUT_QUAD: return easeInOutQuad8(i);
        case EASE_IN_CUBIC: return easeInCubic8(i);
        case EASE_OUT_CUBIC: return easeOutCubic8(i);
        case EASE_IN_OUT_CUBIC: return easeInOutCubic8(i);
        case EASE_IN_SINE: return easeInSine8(i);
        case EASE_OUT_SINE: return easeOutSine8(i);
        case EASE_IN_OUT_SINE: return easeInOutSine8(i);
        default: return i;
    }
}

inline void ease8(EaseType type, uint8_t* src, uint8_t* dst, uint8_t count) {
    switch (type) {
        case EASE_NONE: return;
        case EASE_IN_QUAD: {
            for (uint8_t i = 0; i < count; i++) {
                dst[i] = easeInQuad8(src[i]);
            }
            break;
        }
        case EASE_OUT_QUAD: {
            for (uint8_t i = 0; i < count; i++) {
                dst[i] = easeOutQuad8(src[i]);
            }
            break;
        }
        case EASE_IN_OUT_QUAD: {
            for (uint8_t i = 0; i < count; i++) {
                dst[i] = easeInOutQuad8(src[i]);
            }
            break;
        }
        case EASE_IN_CUBIC: {
            for (uint8_t i = 0; i < count; i++) {
                dst[i] = easeInCubic8(src[i]);
            }
            break;
        }
        case EASE_OUT_CUBIC: {
            for (uint8_t i = 0; i < count; i++) {
                dst[i] = easeOutCubic8(src[i]);
            }
            break;
        }
        case EASE_IN_OUT_CUBIC: {
            for (uint8_t i = 0; i < count; i++) {
                dst[i] = easeInOutCubic8(src[i]);
            }
            break;
        }
        case EASE_IN_SINE: {
            for (uint8_t i = 0; i < count; i++) {
                dst[i] = easeInSine8(src[i]);
            }
            break;
        }
        case EASE_OUT_SINE: {
            for (uint8_t i = 0; i < count; i++) {
                dst[i] = easeOutSine8(src[i]);
            }
            break;
        }
        case EASE_IN_OUT_SINE: {
            for (uint8_t i = 0; i < count; i++) {
                dst[i] = easeInOutSine8(src[i]);
            }
            break;
        }
    }
}

}
# 24 "../../src/lib8tion.h" 2



# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4


# 28 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 105 "/usr/include/string.h" 3 4
}
# 115 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
# 141 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 173 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) noexcept (true) __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 244 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 271 "/usr/include/string.h" 3 4
}
# 281 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 293 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 321 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 348 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 389 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))
    __attribute__ ((__access__ (__read_only__, 1, 2)))
    __attribute__ ((__access__ (__read_only__, 3, 4)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) noexcept (true);
# 444 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));




extern const char *strerrordesc_np (int __err) noexcept (true);

extern const char *strerrorname_np (int __err) noexcept (true);





extern char *strerror_l (int __errnum, locale_t __l) noexcept (true);



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 66 "/usr/include/strings.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/strings.h" 3 4
}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) noexcept (true) __attribute__ ((__const__));





extern int ffsl (long int __l) noexcept (true) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     noexcept (true) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) noexcept (true);



extern const char *sigabbrev_np (int __sig) noexcept (true);


extern const char *sigdescr_np (int __sig) noexcept (true);



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlcpy (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 3)));



extern size_t strlcat (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__read_write__, 1, 3)));




extern int strverscmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__read_write__, 1, 2)));







extern "C++" char *basename (char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 552 "/usr/include/string.h" 3 4
}
# 28 "../../src/lib8tion.h" 2
# 226 "../../src/lib8tion.h"
# 1 "../../src/lib8tion/math8.h" 1
       


# 1 "../../src/lib8tion/scale8.h" 1
       


# 1 "../../src/crgb.h" 1



       



# 1 "../../src/chsv.h" 1



       












# 16 "../../src/chsv.h"
struct CHSV {
    union {
        struct {
            union {



                uint8_t hue;
                uint8_t h;
            };
            union {


                uint8_t saturation;
                uint8_t sat;
                uint8_t s;
            };
            union {


                uint8_t value;
                uint8_t val;
                uint8_t v;
            };
        };





        uint8_t raw[3];
    };




    inline uint8_t& operator[] (uint8_t x) __attribute__((always_inline))
    {
        return raw[x];
    }


    inline const uint8_t& operator[] (uint8_t x) const __attribute__((always_inline))
    {
        return raw[x];
    }



    constexpr inline CHSV() __attribute__((always_inline)): h(0), s(0), v(0) { }





    constexpr inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
    {
    }


    constexpr inline CHSV(const CHSV& rhs) noexcept : h(rhs.h), s(rhs.s), v(rhs.v) { }


    inline CHSV& operator= (const CHSV& rhs) __attribute__((always_inline)) = default;






    inline CHSV& setHSV(uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
    {
        h = ih;
        s = is;
        v = iv;
        return *this;
    }
};


typedef enum {
    HUE_RED = 0,
    HUE_ORANGE = 32,
    HUE_YELLOW = 64,
    HUE_GREEN = 96,
    HUE_AQUA = 128,
    HUE_BLUE = 160,
    HUE_PURPLE = 192,
    HUE_PINK = 224
} HSVHue;




# 9 "../../src/crgb.h" 2

# 1 "../../src/color.h" 1
       




# 15 "../../src/color.h"
typedef enum {

    TypicalSMD5050=0xFFB0F0 ,

    TypicalLEDStrip=0xFFB0F0 ,



    Typical8mmPixel=0xFFE08C ,

    TypicalPixelString=0xFFE08C ,


    UncorrectedColor=0xFFFFFF

} LEDColorCorrection;
# 46 "../../src/color.h"
typedef enum {



    Candle=0xFF9329 ,

    Tungsten40W=0xFFC58F ,

    Tungsten100W=0xFFD6AA ,

    Halogen=0xFFF1E0 ,

    CarbonArc=0xFFFAF4 ,

    HighNoonSun=0xFFFFFB ,

    DirectSunlight=0xFFFFFF ,

    OvercastSky=0xC9E2FF ,

    ClearBlueSky=0x409CFF ,





    WarmFluorescent=0xFFF4E5 ,

    StandardFluorescent=0xF4FFFA ,

    CoolWhiteFluorescent=0xD4EBFF ,

    FullSpectrumFluorescent=0xFFF4F2 ,

    GrowLightFluorescent=0xFFEFF7 ,

    BlackLightFluorescent=0xA700FF ,

    MercuryVapor=0xD8F7FF ,

    SodiumVapor=0xFFD1B2 ,

    MetalHalide=0xF2FCFF ,

    HighPressureSodium=0xFFB74C ,



    UncorrectedTemperature=0xFFFFFF
} ColorTemperature;




# 11 "../../src/crgb.h" 2


# 1 "../../src/fl/template_magic.h" 1
       

# 1 "../../src/fl/type_traits.h" 1
       





# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 8 "../../src/fl/type_traits.h" 2



# 1 "../../src/fl/move.h" 1
       

namespace fl {



template <typename T> struct remove_reference {
    using type = T;
};


template <typename T> struct remove_reference<T &> {
    using type = T;
};


template <typename T> struct remove_reference<T &&> {
    using type = T;
};


template <typename T>
using remove_reference_t = typename remove_reference<T>::type;


template <typename T>
constexpr typename remove_reference<T>::type &&move(T &&t) noexcept {
    return static_cast<typename remove_reference<T>::type &&>(t);
}

}
# 12 "../../src/fl/type_traits.h" 2

namespace fl {



template <bool Condition, typename T = void> struct enable_if {};


template <typename T> struct enable_if<true, T> {
    using type = T;
};






template <bool Condition, typename T = void>
using enable_if_t = typename enable_if<Condition, T>::type;


template <typename Base, typename Derived> struct is_base_of {
  private:
    typedef uint8_t yes;
    typedef uint16_t no;
    static yes test(Base *);
    static no test(...);
    enum {
        kSizeDerived = sizeof(test(static_cast<Derived *>(nullptr))),
    };

  public:
    static constexpr bool value = (kSizeDerived == sizeof(yes));
};



template <typename Base, typename Derived> struct is_base_of_v_helper {
    static constexpr bool value = is_base_of<Base, Derived>::value;
};


template <typename T, typename U> struct is_same {
    static constexpr bool value = false;
};


template <typename T> struct is_same<T, T> {
    static constexpr bool value = true;
};


template <typename T, typename U> struct is_same_v_helper {
    static constexpr bool value = is_same<T, U>::value;
};



template <bool B, typename T, typename F> struct conditional {
    using type = T;
};

template <typename T, typename F> struct conditional<false, T, F> {
    using type = F;
};

template <bool B, typename T, typename F>
using conditional_t = typename conditional<B, T, F>::type;


template <typename T> struct is_array {
    static constexpr bool value = false;
};

template <typename T> struct is_array<T[]> {
    static constexpr bool value = true;
};

template <typename T, size_t N> struct is_array<T[N]> {
    static constexpr bool value = true;
};


template <typename T> struct remove_extent {
    using type = T;
};

template <typename T> struct remove_extent<T[]> {
    using type = T;
};

template <typename T, size_t N> struct remove_extent<T[N]> {
    using type = T;
};


template <typename T> struct is_function {
    static constexpr bool value = false;
};

template <typename Ret, typename... Args> struct is_function<Ret(Args...)> {
    static constexpr bool value = true;
};

template <typename Ret, typename... Args>
struct is_function<Ret(Args...) const> {
    static constexpr bool value = true;
};

template <typename Ret, typename... Args>
struct is_function<Ret(Args...) volatile> {
    static constexpr bool value = true;
};

template <typename Ret, typename... Args>
struct is_function<Ret(Args...) const volatile> {
    static constexpr bool value = true;
};


template <typename T> struct add_pointer {
    using type = T *;
};

template <typename T> struct add_pointer<T &> {
    using type = T *;
};

template <typename T> struct add_pointer<T &&> {
    using type = T *;
};

template <typename T> using add_pointer_t = typename add_pointer<T>::type;


template <typename T> struct remove_const {
    using type = T;
};

template <typename T> struct remove_const<const T> {
    using type = T;
};




template <typename T> struct is_lvalue_reference {
    static constexpr bool value = false;
};

template <typename T> struct is_lvalue_reference<T &> {
    static constexpr bool value = true;
};


template <typename T>
constexpr T &&forward(typename remove_reference<T>::type &t) noexcept {
    return static_cast<T &&>(t);
}


template <typename T>
constexpr T &&forward(typename remove_reference<T>::type &&t) noexcept {
    static_assert(!is_lvalue_reference<T>::value,
                  "Cannot forward an rvalue as an lvalue");
    return static_cast<T &&>(t);
}


template <typename T> struct remove_cv {
    using type = T;
};

template <typename T> struct remove_cv<const T> {
    using type = T;
};

template <typename T> struct remove_cv<volatile T> {
    using type = T;
};

template <typename T> struct remove_cv<const volatile T> {
    using type = T;
};

template <typename T> using remove_cv_t = typename remove_cv<T>::type;


template <typename T> struct decay {
  private:
    using U = typename remove_reference<T>::type;

  public:
    using type = typename conditional<
        is_array<U>::value, typename remove_extent<U>::type *,
        typename conditional<is_function<U>::value,
                             typename add_pointer<U>::type,
                             typename remove_cv<U>::type>::type>::type;
};

template <typename T> using decay_t = typename decay<T>::type;


template <typename T> struct is_pod {
    static constexpr bool value = false;
};


template <> struct is_pod<bool> {
    static constexpr bool value = true;
};
template <> struct is_pod<char> {
    static constexpr bool value = true;
};
template <> struct is_pod<signed char> {
    static constexpr bool value = true;
};
template <> struct is_pod<unsigned char> {
    static constexpr bool value = true;
};
template <> struct is_pod<short> {
    static constexpr bool value = true;
};
template <> struct is_pod<unsigned short> {
    static constexpr bool value = true;
};
template <> struct is_pod<int> {
    static constexpr bool value = true;
};
template <> struct is_pod<unsigned int> {
    static constexpr bool value = true;
};
template <> struct is_pod<long> {
    static constexpr bool value = true;
};
template <> struct is_pod<unsigned long> {
    static constexpr bool value = true;
};
template <> struct is_pod<long long> {
    static constexpr bool value = true;
};
template <> struct is_pod<unsigned long long> {
    static constexpr bool value = true;
};
template <> struct is_pod<float> {
    static constexpr bool value = true;
};
template <> struct is_pod<double> {
    static constexpr bool value = true;
};
template <> struct is_pod<long double> {
    static constexpr bool value = true;
};


template <typename T> struct is_pod_v_helper {
    static constexpr bool value = is_pod<T>::value;
};





template <typename T> struct is_member_function_pointer;
template <typename C, typename Ret, typename... A>
struct is_member_function_pointer<Ret (C::*)(A...)>;
template <typename C, typename Ret, typename... A>
struct is_member_function_pointer<Ret (C::*)(A...) const>;

template <typename T> struct is_member_function_pointer {
    static constexpr bool value = false;
};

template <typename C, typename Ret, typename... A>
struct is_member_function_pointer<Ret (C::*)(A...)> {
    static constexpr bool value = true;
};

template <typename C, typename Ret, typename... A>
struct is_member_function_pointer<Ret (C::*)(A...) const> {
    static constexpr bool value = true;
};




template <typename T> struct is_integral {
    static constexpr bool value = false;
};
template <> struct is_integral<bool> {
    static constexpr bool value = true;
};
template <> struct is_integral<char> {
    static constexpr bool value = true;
};
template <> struct is_integral<signed char> {
    static constexpr bool value = true;
};
template <> struct is_integral<unsigned char> {
    static constexpr bool value = true;
};
template <> struct is_integral<short> {
    static constexpr bool value = true;
};
template <> struct is_integral<unsigned short> {
    static constexpr bool value = true;
};
template <> struct is_integral<int> {
    static constexpr bool value = true;
};
template <> struct is_integral<unsigned int> {
    static constexpr bool value = true;
};
template <> struct is_integral<long> {
    static constexpr bool value = true;
};
template <> struct is_integral<unsigned long> {
    static constexpr bool value = true;
};
template <> struct is_integral<long long> {
    static constexpr bool value = true;
};
template <> struct is_integral<unsigned long long> {
    static constexpr bool value = true;
};

template <typename T> struct is_integral<const T> {
    static constexpr bool value = is_integral<T>::value;
};

template <typename T> struct is_integral<volatile T> {
    static constexpr bool value = is_integral<T>::value;
};

template <typename T> struct is_integral<T &> {
    static constexpr bool value = is_integral<T>::value;
};




template <typename T> struct is_floating_point {
    static constexpr bool value = false;
};
template <> struct is_floating_point<float> {
    static constexpr bool value = true;
};
template <> struct is_floating_point<double> {
    static constexpr bool value = true;
};
template <> struct is_floating_point<long double> {
    static constexpr bool value = true;
};

template <typename T> struct is_floating_point<const T> {
    static constexpr bool value = is_floating_point<T>::value;
};

template <typename T> struct is_floating_point<volatile T> {
    static constexpr bool value = is_floating_point<T>::value;
};

template <typename T> struct is_floating_point<T &> {
    static constexpr bool value = is_floating_point<T>::value;
};




template <typename T> struct is_signed {
    static constexpr bool value = false;
};
template <> struct is_signed<signed char> {
    static constexpr bool value = true;
};
template <> struct is_signed<short> {
    static constexpr bool value = true;
};
template <> struct is_signed<int> {
    static constexpr bool value = true;
};
template <> struct is_signed<long> {
    static constexpr bool value = true;
};
template <> struct is_signed<long long> {
    static constexpr bool value = true;
};
template <> struct is_signed<float> {
    static constexpr bool value = true;
};
template <> struct is_signed<double> {
    static constexpr bool value = true;
};
template <> struct is_signed<long double> {
    static constexpr bool value = true;
};






template <typename T> struct type_rank {
    static constexpr int value = 0;
};
template <> struct type_rank<bool> {
    static constexpr int value = 1;
};
template <> struct type_rank<signed char> {
    static constexpr int value = 2;
};
template <> struct type_rank<unsigned char> {
    static constexpr int value = 2;
};
template <> struct type_rank<char> {
    static constexpr int value = 2;
};
template <> struct type_rank<short> {
    static constexpr int value = 3;
};
template <> struct type_rank<unsigned short> {
    static constexpr int value = 3;
};
template <> struct type_rank<int> {
    static constexpr int value = 4;
};
template <> struct type_rank<unsigned int> {
    static constexpr int value = 4;
};
template <> struct type_rank<long> {
    static constexpr int value = 5;
};
template <> struct type_rank<unsigned long> {
    static constexpr int value = 5;
};
template <> struct type_rank<long long> {
    static constexpr int value = 6;
};
template <> struct type_rank<unsigned long long> {
    static constexpr int value = 6;
};
template <> struct type_rank<float> {
    static constexpr int value = 10;
};
template <> struct type_rank<double> {
    static constexpr int value = 11;
};
template <> struct type_rank<long double> {
    static constexpr int value = 12;
};
# 470 "../../src/fl/type_traits.h"
template <typename T, typename U>
struct choose_by_size {
    using type = typename conditional<
        (sizeof(T) > sizeof(U)), T,
        typename conditional<
            (sizeof(U) > sizeof(T)), U,
            void
        >::type
    >::type;
};


template <typename T, typename U>
struct choose_by_rank {
    using type = typename conditional<
        (type_rank<T>::value > type_rank<U>::value), T,
        typename conditional<
            (type_rank<U>::value > type_rank<T>::value), U,
            void
        >::type
    >::type;
};


template <typename T, typename U>
struct choose_by_signedness {
    static constexpr bool t_signed = is_signed<T>::value;
    static constexpr bool u_signed = is_signed<U>::value;
    static constexpr bool mixed_signedness = (t_signed != u_signed);

    using type = typename conditional<
        mixed_signedness && t_signed, T,
        typename conditional<
            mixed_signedness && u_signed, U,
            T
        >::type
    >::type;
};


template <typename T, typename U>
struct integer_promotion_impl {
    static constexpr bool same_size = (sizeof(T) == sizeof(U));
    static constexpr bool same_rank = (type_rank<T>::value == type_rank<U>::value);

    using by_size_result = typename choose_by_size<T, U>::type;
    using by_rank_result = typename choose_by_rank<T, U>::type;
    using by_signedness_result = typename choose_by_signedness<T, U>::type;

    using type = typename conditional<
        !same_size, by_size_result,
        typename conditional<
            same_size && !same_rank, by_rank_result,
            by_signedness_result
        >::type
    >::type;
};






template <typename T, typename U, typename = void> struct common_type_impl {
    using type = T;
};


template <typename T> struct common_type_impl<T, T> {
    using type = T;
};


template <typename T>
struct common_type_impl<T, float, typename enable_if<(is_integral<T>::value || is_floating_point<T>::value) && !is_same<T, float>::value>::type> {
    using type = float;
};

template <typename T>
struct common_type_impl<T, double, typename enable_if<(is_integral<T>::value || is_floating_point<T>::value) && !is_same<T, double>::value>::type> {
    using type = double;
};


template <typename T>
struct common_type_impl<float, T, typename enable_if<(is_integral<T>::value || is_floating_point<T>::value) && !is_same<T, float>::value>::type> {
    using type = float;
};

template <typename T>
struct common_type_impl<double, T, typename enable_if<(is_integral<T>::value || is_floating_point<T>::value) && !is_same<T, double>::value>::type> {
    using type = double;
};



template <>
struct common_type_impl<int8_t, uint8_t, void> {


};

template <>
struct common_type_impl<uint8_t, int8_t, void> {


};


template <typename T, typename U>
struct common_type_impl<T, U, typename enable_if<
    is_integral<T>::value && is_integral<U>::value &&
    !is_same<T, U>::value &&
    !((is_same<T, int8_t>::value && is_same<U, uint8_t>::value) ||
      (is_same<T, uint8_t>::value && is_same<U, int8_t>::value))
>::type> {
    using type = typename integer_promotion_impl<T, U>::type;
};


template <> struct common_type_impl<float, double> { using type = double; };
template <> struct common_type_impl<double, float> { using type = double; };
template <> struct common_type_impl<float, long double> { using type = long double; };
template <> struct common_type_impl<long double, float> { using type = long double; };
template <> struct common_type_impl<double, long double> { using type = long double; };
template <> struct common_type_impl<long double, double> { using type = long double; };

template <typename T, typename U> struct common_type {
    using type = typename common_type_impl<T, U>::type;
};

template <typename T, typename U>
using common_type_t = typename common_type<T, U>::type;
# 617 "../../src/fl/type_traits.h"
template <typename Base, typename Derived>
using is_derived = enable_if_t<is_base_of<Base, Derived>::value>;




template <typename T> struct has_member_swap {
  private:

    typedef uint8_t yes;
    typedef uint16_t no;



    template <typename U, void (U::*M)(U &)> struct helper {};


    template <typename U> static yes test(helper<U, &U::swap> *);


    template <typename> static no test(...);

  public:
    static constexpr bool value = sizeof(test<T>(nullptr)) == sizeof(yes);
};


template <typename T, bool = has_member_swap<T>::value> struct swap_impl;


template <typename T> struct swap_impl<T, false> {
    static void apply(T &a, T &b) {
        T tmp = a;
        a = b;
        b = tmp;
    }
};


template <typename T> struct swap_impl<T, true> {
    static void apply(T &a, T &b) { a.swap(b); }
};


template <typename T> void swap(T &a, T &b) {


    swap_impl<T>::apply(a, b);
}

template <typename T> void swap_by_copy(T &a, T &b) {


    T tmp = a;
    a = b;
    b = tmp;
}


template <typename T, typename... Types> struct contains_type;

template <typename T> struct contains_type<T> {
    static constexpr bool value = false;
};

template <typename T, typename U, typename... Rest>
struct contains_type<T, U, Rest...> {
    static constexpr bool value =
        fl::is_same<T, U>::value || contains_type<T, Rest...>::value;
};


template <typename... Types> struct max_size;

template <> struct max_size<> {
    static constexpr size_t value = 0;
};

template <typename T, typename... Rest> struct max_size<T, Rest...> {
    static constexpr size_t value = (sizeof(T) > max_size<Rest...>::value)
                                        ? sizeof(T)
                                        : max_size<Rest...>::value;
};


template <typename... Types> struct max_align;

template <> struct max_align<> {
    static constexpr size_t value = 1;
};

template <typename T, typename... Rest> struct max_align<T, Rest...> {
    static constexpr size_t value = (alignof(T) > max_align<Rest...>::value)
                                        ? alignof(T)
                                        : max_align<Rest...>::value;
};

}
# 4 "../../src/fl/template_magic.h" 2
# 14 "../../src/crgb.h" 2
# 1 "../../src/hsv2rgb.h" 1
       
# 59 "../../src/hsv2rgb.h"


struct CRGB;
struct CHSV;
# 71 "../../src/hsv2rgb.h"
void hsv2rgb_rainbow( const struct CHSV* phsv, struct CRGB * prgb, int numLeds);
void hsv2rgb_rainbow( const struct CHSV& hsv, struct CRGB& rgb);
CRGB hsv2rgb_rainbow( const struct CHSV& hsv);
# 90 "../../src/hsv2rgb.h"
void hsv2rgb_spectrum( const struct CHSV& hsv, struct CRGB& rgb);


CRGB hsv2rgb_spectrum( const struct CHSV& hsv);






void hsv2rgb_spectrum( const struct CHSV* phsv, struct CRGB * prgb, int numLeds);
# 114 "../../src/hsv2rgb.h"
void hsv2rgb_raw(const struct CHSV& hsv, struct CRGB & rgb);






void hsv2rgb_raw(const struct CHSV* phsv, struct CRGB * prgb, int numLeds);
# 134 "../../src/hsv2rgb.h"
void hsv2rgb_fullspectrum( const struct CHSV& hsv, struct CRGB& rgb);


CRGB hsv2rgb_fullspectrum( const struct CHSV& hsv);






void hsv2rgb_fullspectrum( const struct CHSV* phsv, struct CRGB * prgb, int numLeds);
# 183 "../../src/hsv2rgb.h"
CHSV rgb2hsv_approximate( const CRGB& rgb);



# 15 "../../src/crgb.h" 2




namespace fl {
class string;
class XYMap;
struct HSV16;
}


# 38 "../../src/crgb.h"
struct CRGB;
# 56 "../../src/crgb.h"
__attribute__((always_inline)) inline void hsv2rgb_dispatch( const struct CHSV* phsv, struct CRGB * prgb, int numLeds)
{
# 66 "../../src/crgb.h"
    hsv2rgb_rainbow(phsv, prgb, numLeds);

}

__attribute__((always_inline)) inline void hsv2rgb_dispatch( const struct CHSV& hsv, struct CRGB& rgb)
{







    hsv2rgb_rainbow(hsv, rgb);

}



struct CRGB {
    union {
        struct {
            union {
                uint8_t r;
                uint8_t red;
            };
            union {
                uint8_t g;
                uint8_t green;
            };
            union {
                uint8_t b;
                uint8_t blue;
            };
        };





        uint8_t raw[3];
    };

    static CRGB blend(const CRGB& p1, const CRGB& p2, fract8 amountOfP2);
    static CRGB blendAlphaMaxChannel(const CRGB& upper, const CRGB& lower);


    static void downscale(const CRGB* src, const fl::XYMap& srcXY, CRGB* dst, const fl::XYMap& dstXY);
    static void upscale(const CRGB* src, const fl::XYMap& srcXY, CRGB* dst, const fl::XYMap& dstXY);
# 128 "../../src/crgb.h"
    CRGB colorBoost(fl::EaseType saturation_function = fl::EASE_NONE, fl::EaseType luminance_function = fl::EASE_NONE) const;
    static void colorBoost(const CRGB* src, CRGB* dst, size_t count, fl::EaseType saturation_function = fl::EASE_NONE, fl::EaseType luminance_function = fl::EASE_NONE);




    fl::HSV16 toHSV16() const;




    __attribute__((always_inline)) inline uint8_t& operator[] (uint8_t x)
    {
        return raw[x];
    }




    __attribute__((always_inline)) inline const uint8_t& operator[] (uint8_t x) const
    {
        return raw[x];
    }






    __attribute__((always_inline)) inline CRGB() {
        r = 0;
        g = 0;
        b = 0;
    }






    constexpr CRGB(uint8_t ir, uint8_t ig, uint8_t ib) noexcept
        : r(ir), g(ig), b(ib)
    {
    }



    constexpr CRGB(uint32_t colorcode) noexcept
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
    {
    }

    constexpr uint32_t as_uint32_t() const noexcept {
        return uint32_t(0xff000000) |
               (uint32_t{r} << 16) |
               (uint32_t{g} << 8) |
               uint32_t{b};
    }



    constexpr CRGB(LEDColorCorrection colorcode) noexcept
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
    {
    }



    constexpr CRGB(ColorTemperature colorcode) noexcept
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
    {
    }


    __attribute__((always_inline)) inline CRGB(const CRGB& rhs) = default;


    __attribute__((always_inline)) inline CRGB(const CHSV& rhs)
    {
        hsv2rgb_dispatch( rhs, *this);
    }



    CRGB(const fl::HSV16& rhs);


    __attribute__((always_inline)) inline CRGB& operator= (const CRGB& rhs) = default;



    __attribute__((always_inline)) inline CRGB& operator= (const uint32_t colorcode)
    {
        r = (colorcode >> 16) & 0xFF;
        g = (colorcode >> 8) & 0xFF;
        b = (colorcode >> 0) & 0xFF;
        return *this;
    }





    __attribute__((always_inline)) inline CRGB& setRGB (uint8_t nr, uint8_t ng, uint8_t nb)
    {
        r = nr;
        g = ng;
        b = nb;
        return *this;
    }





    __attribute__((always_inline)) inline CRGB& setHSV (uint8_t hue, uint8_t sat, uint8_t val)
    {
        hsv2rgb_dispatch( CHSV(hue, sat, val), *this);
        return *this;
    }




    __attribute__((always_inline)) inline CRGB& setHue (uint8_t hue)
    {
        hsv2rgb_dispatch( CHSV(hue, 255, 255), *this);
        return *this;
    }


    __attribute__((always_inline)) inline CRGB& operator= (const CHSV& rhs)
    {
        hsv2rgb_dispatch( rhs, *this);
        return *this;
    }



    __attribute__((always_inline)) inline CRGB& setColorCode (uint32_t colorcode)
    {
        r = (colorcode >> 16) & 0xFF;
        g = (colorcode >> 8) & 0xFF;
        b = (colorcode >> 0) & 0xFF;
        return *this;
    }



    CRGB& operator+= (const CRGB& rhs);





    __attribute__((always_inline)) inline CRGB& addToRGB (uint8_t d);


    __attribute__((always_inline)) inline CRGB& operator-= (const CRGB& rhs);





    __attribute__((always_inline)) inline CRGB& subtractFromRGB(uint8_t d);


    __attribute__((always_inline)) inline CRGB& operator-- ();


    __attribute__((always_inline)) inline CRGB operator-- (int );


    __attribute__((always_inline)) inline CRGB& operator++ ();


    __attribute__((always_inline)) inline CRGB operator++ (int );


    __attribute__((always_inline)) inline CRGB& operator/= (uint8_t d )
    {
        r /= d;
        g /= d;
        b /= d;
        return *this;
    }


    __attribute__((always_inline)) inline CRGB& operator>>= (uint8_t d)
    {
        r >>= d;
        g >>= d;
        b >>= d;
        return *this;
    }



    __attribute__((always_inline)) inline CRGB& operator*= (uint8_t d);







    __attribute__((always_inline)) inline CRGB& nscale8_video (uint8_t scaledown);



    __attribute__((always_inline)) inline CRGB& operator%= (uint8_t scaledown);



    __attribute__((always_inline)) inline CRGB& fadeLightBy (uint8_t fadefactor );





    CRGB& nscale8 (uint8_t scaledown );





    __attribute__((always_inline)) inline CRGB& nscale8 (const CRGB & scaledown );

    constexpr CRGB nscale8_constexpr (const CRGB scaledown ) const;



    __attribute__((always_inline)) inline CRGB scale8 (uint8_t scaledown ) const;


    __attribute__((always_inline)) inline CRGB scale8 (const CRGB & scaledown ) const;



    CRGB& fadeToBlackBy (uint8_t fadefactor );


    __attribute__((always_inline)) inline CRGB& operator|= (const CRGB& rhs )
    {
        if( rhs.r > r) r = rhs.r;
        if( rhs.g > g) g = rhs.g;
        if( rhs.b > b) b = rhs.b;
        return *this;
    }


    __attribute__((always_inline)) inline CRGB& operator|= (uint8_t d )
    {
        if( d > r) r = d;
        if( d > g) g = d;
        if( d > b) b = d;
        return *this;
    }


    __attribute__((always_inline)) inline CRGB& operator&= (const CRGB& rhs )
    {
        if( rhs.r < r) r = rhs.r;
        if( rhs.g < g) g = rhs.g;
        if( rhs.b < b) b = rhs.b;
        return *this;
    }


    __attribute__((always_inline)) inline CRGB& operator&= (uint8_t d )
    {
        if( d < r) r = d;
        if( d < g) g = d;
        if( d < b) b = d;
        return *this;
    }


    constexpr explicit operator bool() const
    {
        return r || g || b;
    }


    constexpr explicit operator uint32_t() const
    {
        return uint32_t(0xff000000) |
               (uint32_t{r} << 16) |
               (uint32_t{g} << 8) |
               uint32_t{b};
    }


    constexpr CRGB operator-() const
    {
        return CRGB(255 - r, 255 - g, 255 - b);
    }
# 438 "../../src/crgb.h"
    fl::string toString() const;



    uint8_t getLuma() const;




    __attribute__((always_inline)) inline uint8_t getAverageLight() const;






    __attribute__((always_inline)) inline void maximizeBrightness( uint8_t limit = 255 ) {
        uint8_t max = red;
        if( green > max) max = green;
        if( blue > max) max = blue;


        if(max > 0) {
            uint16_t factor = ((uint16_t)(limit) * 256) / max;
            red = (red * factor) / 256;
            green = (green * factor) / 256;
            blue = (blue * factor) / 256;
        }
    }






    static CRGB computeAdjustment(uint8_t scale, const CRGB & colorCorrection, const CRGB & colorTemperature);


    CRGB lerp8( const CRGB& other, fract8 amountOf2) const;


    __attribute__((always_inline)) inline CRGB lerp16( const CRGB& other, fract16 frac) const;

    __attribute__((always_inline)) inline uint8_t getParity()
    {
        uint8_t sum = r + g + b;
        return (sum & 0x01);
    }
# 509 "../../src/crgb.h"
    __attribute__((always_inline)) inline void setParity( uint8_t parity)
    {
        uint8_t curparity = getParity();

        if( parity == curparity) return;

        if( parity ) {

            if( (b > 0) && (b < 255)) {
                if( r == g && g == b) {
                    ++r;
                    ++g;
                }
                ++b;
            } else if( (r > 0) && (r < 255)) {
                ++r;
            } else if( (g > 0) && (g < 255)) {
                ++g;
            } else {
                if( r == g && g == b) {
                    r ^= 0x01;
                    g ^= 0x01;
                }
                b ^= 0x01;
            }
        } else {

            if( b > 1) {
                if( r == g && g == b) {
                    --r;
                    --g;
                }
                --b;
            } else if( g > 1) {
                --g;
            } else if( r > 1) {
                --r;
            } else {
                if( r == g && g == b) {
                    r ^= 0x01;
                    g ^= 0x01;
                }
                b ^= 0x01;
            }
        }
    }


    typedef enum {
        AliceBlue=0xF0F8FF,
        Amethyst=0x9966CC,
        AntiqueWhite=0xFAEBD7,
        Aqua=0x00FFFF,
        Aquamarine=0x7FFFD4,
        Azure=0xF0FFFF,
        Beige=0xF5F5DC,
        Bisque=0xFFE4C4,
        Black=0x000000,
        BlanchedAlmond=0xFFEBCD,
        Blue=0x0000FF,
        BlueViolet=0x8A2BE2,
        Brown=0xA52A2A,
        BurlyWood=0xDEB887,
        CadetBlue=0x5F9EA0,
        Chartreuse=0x7FFF00,
        Chocolate=0xD2691E,
        Coral=0xFF7F50,
        CornflowerBlue=0x6495ED,
        Cornsilk=0xFFF8DC,
        Crimson=0xDC143C,
        Cyan=0x00FFFF,
        DarkBlue=0x00008B,
        DarkCyan=0x008B8B,
        DarkGoldenrod=0xB8860B,
        DarkGray=0xA9A9A9,
        DarkGrey=0xA9A9A9,
        DarkGreen=0x006400,
        DarkKhaki=0xBDB76B,
        DarkMagenta=0x8B008B,
        DarkOliveGreen=0x556B2F,
        DarkOrange=0xFF8C00,
        DarkOrchid=0x9932CC,
        DarkRed=0x8B0000,
        DarkSalmon=0xE9967A,
        DarkSeaGreen=0x8FBC8F,
        DarkSlateBlue=0x483D8B,
        DarkSlateGray=0x2F4F4F,
        DarkSlateGrey=0x2F4F4F,
        DarkTurquoise=0x00CED1,
        DarkViolet=0x9400D3,
        DeepPink=0xFF1493,
        DeepSkyBlue=0x00BFFF,
        DimGray=0x696969,
        DimGrey=0x696969,
        DodgerBlue=0x1E90FF,
        FireBrick=0xB22222,
        FloralWhite=0xFFFAF0,
        ForestGreen=0x228B22,
        Fuchsia=0xFF00FF,
        Gainsboro=0xDCDCDC,
        GhostWhite=0xF8F8FF,
        Gold=0xFFD700,
        Goldenrod=0xDAA520,
        Gray=0x808080,
        Grey=0x808080,
        Green=0x008000,
        GreenYellow=0xADFF2F,
        Honeydew=0xF0FFF0,
        HotPink=0xFF69B4,
        IndianRed=0xCD5C5C,
        Indigo=0x4B0082,
        Ivory=0xFFFFF0,
        Khaki=0xF0E68C,
        Lavender=0xE6E6FA,
        LavenderBlush=0xFFF0F5,
        LawnGreen=0x7CFC00,
        LemonChiffon=0xFFFACD,
        LightBlue=0xADD8E6,
        LightCoral=0xF08080,
        LightCyan=0xE0FFFF,
        LightGoldenrodYellow=0xFAFAD2,
        LightGreen=0x90EE90,
        LightGrey=0xD3D3D3,
        LightPink=0xFFB6C1,
        LightSalmon=0xFFA07A,
        LightSeaGreen=0x20B2AA,
        LightSkyBlue=0x87CEFA,
        LightSlateGray=0x778899,
        LightSlateGrey=0x778899,
        LightSteelBlue=0xB0C4DE,
        LightYellow=0xFFFFE0,
        Lime=0x00FF00,
        LimeGreen=0x32CD32,
        Linen=0xFAF0E6,
        Magenta=0xFF00FF,
        Maroon=0x800000,
        MediumAquamarine=0x66CDAA,
        MediumBlue=0x0000CD,
        MediumOrchid=0xBA55D3,
        MediumPurple=0x9370DB,
        MediumSeaGreen=0x3CB371,
        MediumSlateBlue=0x7B68EE,
        MediumSpringGreen=0x00FA9A,
        MediumTurquoise=0x48D1CC,
        MediumVioletRed=0xC71585,
        MidnightBlue=0x191970,
        MintCream=0xF5FFFA,
        MistyRose=0xFFE4E1,
        Moccasin=0xFFE4B5,
        NavajoWhite=0xFFDEAD,
        Navy=0x000080,
        OldLace=0xFDF5E6,
        Olive=0x808000,
        OliveDrab=0x6B8E23,
        Orange=0xFFA500,
        OrangeRed=0xFF4500,
        Orchid=0xDA70D6,
        PaleGoldenrod=0xEEE8AA,
        PaleGreen=0x98FB98,
        PaleTurquoise=0xAFEEEE,
        PaleVioletRed=0xDB7093,
        PapayaWhip=0xFFEFD5,
        PeachPuff=0xFFDAB9,
        Peru=0xCD853F,
        Pink=0xFFC0CB,
        Plaid=0xCC5533,
        Plum=0xDDA0DD,
        PowderBlue=0xB0E0E6,
        Purple=0x800080,
        Red=0xFF0000,
        RosyBrown=0xBC8F8F,
        RoyalBlue=0x4169E1,
        SaddleBrown=0x8B4513,
        Salmon=0xFA8072,
        SandyBrown=0xF4A460,
        SeaGreen=0x2E8B57,
        Seashell=0xFFF5EE,
        Sienna=0xA0522D,
        Silver=0xC0C0C0,
        SkyBlue=0x87CEEB,
        SlateBlue=0x6A5ACD,
        SlateGray=0x708090,
        SlateGrey=0x708090,
        Snow=0xFFFAFA,
        SpringGreen=0x00FF7F,
        SteelBlue=0x4682B4,
        Tan=0xD2B48C,
        Teal=0x008080,
        Thistle=0xD8BFD8,
        Tomato=0xFF6347,
        Turquoise=0x40E0D0,
        Violet=0xEE82EE,
        Wheat=0xF5DEB3,
        White=0xFFFFFF,
        WhiteSmoke=0xF5F5F5,
        Yellow=0xFFFF00,
        YellowGreen=0x9ACD32,





        FairyLight=0xFFE42D,


        FairyLightNCC=0xFF9D2A

    } HTMLColorCode;
};



__attribute__((always_inline)) inline bool operator== (const CRGB& lhs, const CRGB& rhs)
{
    return (lhs.r == rhs.r) && (lhs.g == rhs.g) && (lhs.b == rhs.b);
}


__attribute__((always_inline)) inline bool operator!= (const CRGB& lhs, const CRGB& rhs)
{
    return !(lhs == rhs);
}


__attribute__((always_inline)) inline bool operator== (const CHSV& lhs, const CHSV& rhs)
{
    return (lhs.h == rhs.h) && (lhs.s == rhs.s) && (lhs.v == rhs.v);
}


__attribute__((always_inline)) inline bool operator!= (const CHSV& lhs, const CHSV& rhs)
{
    return !(lhs == rhs);
}


__attribute__((always_inline)) inline bool operator< (const CRGB& lhs, const CRGB& rhs)
{
    uint16_t sl, sr;
    sl = lhs.r + lhs.g + lhs.b;
    sr = rhs.r + rhs.g + rhs.b;
    return sl < sr;
}


__attribute__((always_inline)) inline bool operator> (const CRGB& lhs, const CRGB& rhs)
{
    uint16_t sl, sr;
    sl = lhs.r + lhs.g + lhs.b;
    sr = rhs.r + rhs.g + rhs.b;
    return sl > sr;
}


__attribute__((always_inline)) inline bool operator>= (const CRGB& lhs, const CRGB& rhs)
{
    uint16_t sl, sr;
    sl = lhs.r + lhs.g + lhs.b;
    sr = rhs.r + rhs.g + rhs.b;
    return sl >= sr;
}


__attribute__((always_inline)) inline bool operator<= (const CRGB& lhs, const CRGB& rhs)
{
    uint16_t sl, sr;
    sl = lhs.r + lhs.g + lhs.b;
    sr = rhs.r + rhs.g + rhs.b;
    return sl <= sr;
}




__attribute__((always_inline)) inline CRGB operator/( const CRGB& p1, uint8_t d)
{
    return CRGB( p1.r/d, p1.g/d, p1.b/d);
}



__attribute__((always_inline)) inline CRGB operator&( const CRGB& p1, const CRGB& p2)
{
    return CRGB( p1.r < p2.r ? p1.r : p2.r,
                 p1.g < p2.g ? p1.g : p2.g,
                 p1.b < p2.b ? p1.b : p2.b);
}


__attribute__((always_inline)) inline CRGB operator|( const CRGB& p1, const CRGB& p2)
{
    return CRGB( p1.r > p2.r ? p1.r : p2.r,
                 p1.g > p2.g ? p1.g : p2.g,
                 p1.b > p2.b ? p1.b : p2.b);
}


__attribute__((always_inline)) inline CRGB operator+( const CRGB& p1, const CRGB& p2);


__attribute__((always_inline)) inline CRGB operator-( const CRGB& p1, const CRGB& p2);


__attribute__((always_inline)) inline CRGB operator*( const CRGB& p1, uint8_t d);


__attribute__((always_inline)) inline CRGB operator%( const CRGB& p1, uint8_t d);





# 5 "../../src/lib8tion/scale8.h" 2




 
# 9 "../../src/lib8tion/scale8.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wreturn-type"



# 41 "../../src/lib8tion/scale8.h"
__attribute__ ((always_inline)) static inline uint8_t scale8(uint8_t i, fract8 scale) {


    return (((uint16_t)i) * (1 + (uint16_t)(scale))) >> 8;
# 109 "../../src/lib8tion/scale8.h"
}

constexpr uint8_t scale8_constexpr(uint8_t i, fract8 scale) {
    return (((uint16_t)i) * (1 + (uint16_t)(scale))) >> 8;
}
# 124 "../../src/lib8tion/scale8.h"
__attribute__ ((always_inline)) static inline uint8_t scale8_video(uint8_t i, fract8 scale) {

    uint8_t j = (((int)i * (int)scale) >> 8) + ((i && scale) ? 1 : 0);



    return j;
# 162 "../../src/lib8tion/scale8.h"
}
# 177 "../../src/lib8tion/scale8.h"
__attribute__ ((always_inline)) static inline uint8_t scale8_LEAVING_R1_DIRTY(uint8_t i,
                                                         fract8 scale) {


    return (((uint16_t)i) * ((uint16_t)(scale) + 1)) >> 8;
# 213 "../../src/lib8tion/scale8.h"
}
# 224 "../../src/lib8tion/scale8.h"
__attribute__ ((always_inline)) static inline void nscale8_LEAVING_R1_DIRTY(uint8_t &i,
                                                       fract8 scale) {


    i = (((uint16_t)i) * ((uint16_t)(scale) + 1)) >> 8;
# 259 "../../src/lib8tion/scale8.h"
}
# 269 "../../src/lib8tion/scale8.h"
__attribute__ ((always_inline)) static inline uint8_t scale8_video_LEAVING_R1_DIRTY(uint8_t i,
                                                               fract8 scale) {

    uint8_t j = (((int)i * (int)scale) >> 8) + ((i && scale) ? 1 : 0);



    return j;
# 307 "../../src/lib8tion/scale8.h"
}
# 318 "../../src/lib8tion/scale8.h"
__attribute__ ((always_inline)) static inline void nscale8_video_LEAVING_R1_DIRTY(uint8_t &i,
                                                             fract8 scale) {

    i = (((int)i * (int)scale) >> 8) + ((i && scale) ? 1 : 0);
# 336 "../../src/lib8tion/scale8.h"
}



__attribute__ ((always_inline)) static inline void cleanup_R1() {




}

constexpr CRGB nscale8x3_constexpr(uint8_t r, uint8_t g, uint8_t b, fract8 scale) {
    return CRGB(((int)r * (int)(scale)) >> 8, ((int)g * (int)(scale)) >> 8,
                ((int)b * (int)(scale)) >> 8);
}
# 364 "../../src/lib8tion/scale8.h"
__attribute__ ((unused)) static inline void nscale8x3(uint8_t &r, uint8_t &g, uint8_t &b, fract8 scale) {


    uint16_t scale_fixed = scale + 1;
    r = (((uint16_t)r) * scale_fixed) >> 8;
    g = (((uint16_t)g) * scale_fixed) >> 8;
    b = (((uint16_t)b) * scale_fixed) >> 8;
# 384 "../../src/lib8tion/scale8.h"
}
# 398 "../../src/lib8tion/scale8.h"
__attribute__ ((unused)) static inline void nscale8x3_video(uint8_t &r, uint8_t &g, uint8_t &b,
                                fract8 scale) {

    uint8_t nonzeroscale = (scale != 0) ? 1 : 0;
    r = (r == 0) ? 0 : (((int)r * (int)(scale)) >> 8) + nonzeroscale;
    g = (g == 0) ? 0 : (((int)g * (int)(scale)) >> 8) + nonzeroscale;
    b = (b == 0) ? 0 : (((int)b * (int)(scale)) >> 8) + nonzeroscale;
# 413 "../../src/lib8tion/scale8.h"
}
# 424 "../../src/lib8tion/scale8.h"
__attribute__ ((unused)) static inline void nscale8x2(uint8_t &i, uint8_t &j, fract8 scale) {


    uint16_t scale_fixed = scale + 1;
    i = (((uint16_t)i) * scale_fixed) >> 8;
    j = (((uint16_t)j) * scale_fixed) >> 8;
# 441 "../../src/lib8tion/scale8.h"
}
# 454 "../../src/lib8tion/scale8.h"
__attribute__ ((unused)) static inline void nscale8x2_video(uint8_t &i, uint8_t &j, fract8 scale) {

    uint8_t nonzeroscale = (scale != 0) ? 1 : 0;
    i = (i == 0) ? 0 : (((int)i * (int)(scale)) >> 8) + nonzeroscale;
    j = (j == 0) ? 0 : (((int)j * (int)(scale)) >> 8) + nonzeroscale;







}
# 475 "../../src/lib8tion/scale8.h"
__attribute__ ((always_inline)) static inline uint16_t scale16by8(uint16_t i, fract8 scale) {
    if (scale == 0) {
        return 0;

    }

    uint16_t result;

    result = (((uint32_t)(i) * (1 + ((uint32_t)scale))) >> 8);



    return result;
# 539 "../../src/lib8tion/scale8.h"
}
# 548 "../../src/lib8tion/scale8.h"
__attribute__ ((unused)) static inline uint16_t scale16(uint16_t i, fract16 scale) {

    uint16_t result;

    result = ((uint32_t)(i) * (1 + (uint32_t)(scale))) / 65536;



    return result;
# 690 "../../src/lib8tion/scale8.h"
}
# 711 "../../src/lib8tion/scale8.h"
__attribute__ ((unused)) static inline uint8_t dim8_raw(uint8_t x) { return scale8(x, x); }



__attribute__ ((unused)) static inline uint8_t dim8_video(uint8_t x) { return scale8_video(x, x); }


__attribute__ ((unused)) static inline uint8_t dim8_lin(uint8_t x) {
    if (x & 0x80) {
        x = scale8(x, x);
    } else {
        x += 1;
        x /= 2;
    }
    return x;
}


__attribute__ ((unused)) static inline uint8_t brighten8_raw(uint8_t x) {
    uint8_t ix = 255 - x;
    return 255 - scale8(ix, ix);
}


__attribute__ ((unused)) static inline uint8_t brighten8_video(uint8_t x) {
    uint8_t ix = 255 - x;
    return 255 - scale8_video(ix, ix);
}


__attribute__ ((unused)) static inline uint8_t brighten8_lin(uint8_t x) {
    uint8_t ix = 255 - x;
    if (ix & 0x80) {
        ix = scale8(ix, ix);
    } else {
        ix += 1;
        ix /= 2;
    }
    return 255 - ix;
}






 
# 757 "../../src/lib8tion/scale8.h"
#pragma GCC diagnostic pop
# 5 "../../src/lib8tion/math8.h" 2

# 1 "../../src/lib8tion/intmap.h" 1



       






# 25 "../../src/lib8tion/intmap.h"
__attribute__ ((always_inline)) static inline uint16_t map8_to_16(uint8_t x) {
    return uint16_t(x) * 0x101;
}

__attribute__ ((always_inline)) static inline uint32_t map16_to_32(uint16_t x) {
    return uint32_t(x) * 0x10001;
}



__attribute__ ((always_inline)) static inline uint8_t map16_to_8(uint16_t x) {


    if (x == 0) {
        return 0;
    }
    if (x >= 0xff00) {
        return 0xff;
    }
    return uint8_t((x + 128) >> 8);
}

__attribute__ ((always_inline)) static inline uint16_t map32_to_16(uint32_t x) {


    if (x == 0) {
        return 0;
    }
    if (x >= 0xffff0000) {
        return 0xffff;
    }
    return uint16_t((x + 32768) >> 16);
}

__attribute__ ((always_inline)) static inline uint32_t map8_to_32(uint8_t x) {
    return uint32_t(x) * 0x1010101;
}





# 7 "../../src/lib8tion/math8.h" 2



# 32 "../../src/lib8tion/math8.h"
__attribute__ ((always_inline)) static inline uint8_t qadd8(uint8_t i, uint8_t j) {

    unsigned int t = i + j;
    if (t > 255)
        t = 255;
    return t;
# 59 "../../src/lib8tion/math8.h"
}





__attribute__ ((always_inline)) static inline int8_t qadd7(int8_t i, int8_t j) {

    int16_t t = i + j;
    if (t > 127)
        t = 127;
    else if (t < -128)
        t = -128;
    return t;
# 98 "../../src/lib8tion/math8.h"
}





__attribute__ ((always_inline)) static inline uint8_t qsub8(uint8_t i, uint8_t j) {

    int t = i - j;
    if (t < 0)
        t = 0;
    return t;
# 129 "../../src/lib8tion/math8.h"
}






__attribute__ ((always_inline)) static inline uint8_t add8(uint8_t i, uint8_t j) {

    int t = i + j;
    return t;







}






__attribute__ ((always_inline)) static inline uint16_t add8to16(uint8_t i, uint16_t j) {

    uint16_t t = i + j;
    return t;
# 168 "../../src/lib8tion/math8.h"
}






__attribute__ ((always_inline)) static inline uint8_t sub8(uint8_t i, uint8_t j) {

    int t = i - j;
    return t;







}







__attribute__ ((always_inline)) static inline uint8_t avg8(uint8_t i, uint8_t j) {

    return (i + j) >> 1;
# 209 "../../src/lib8tion/math8.h"
}







__attribute__ ((always_inline)) static inline uint16_t avg16(uint16_t i, uint16_t j) {

    return (uint32_t)((uint32_t)(i) + (uint32_t)(j)) >> 1;
# 238 "../../src/lib8tion/math8.h"
}







__attribute__ ((always_inline)) static inline uint8_t avg8r(uint8_t i, uint8_t j) {

    return (i + j + 1) >> 1;
# 264 "../../src/lib8tion/math8.h"
}







__attribute__ ((always_inline)) static inline uint16_t avg16r(uint16_t i, uint16_t j) {

    return (uint32_t)((uint32_t)(i) + (uint32_t)(j) + 1) >> 1;
# 298 "../../src/lib8tion/math8.h"
}
# 307 "../../src/lib8tion/math8.h"
__attribute__ ((always_inline)) static inline int8_t avg7(int8_t i, int8_t j) {

    return (i >> 1) + (j >> 1) + (i & 0x1);
# 320 "../../src/lib8tion/math8.h"
}
# 329 "../../src/lib8tion/math8.h"
__attribute__ ((always_inline)) static inline int16_t avg15(int16_t i, int16_t j) {

    return (i >> 1) + (j >> 1) + (i & 0x1);
# 349 "../../src/lib8tion/math8.h"
}
# 362 "../../src/lib8tion/math8.h"
__attribute__ ((always_inline)) static inline uint8_t mod8(uint8_t a, uint8_t m) {







    while (a >= m)
        a -= m;

    return a;
}
# 393 "../../src/lib8tion/math8.h"
__attribute__ ((unused)) static inline uint8_t addmod8(uint8_t a, uint8_t b, uint8_t m) {
# 402 "../../src/lib8tion/math8.h"
    a += b;
    while (a >= m)
        a -= m;

    return a;
}
# 426 "../../src/lib8tion/math8.h"
__attribute__ ((unused)) static inline uint8_t submod8(uint8_t a, uint8_t b, uint8_t m) {
# 435 "../../src/lib8tion/math8.h"
    a -= b;
    while (a >= m)
        a -= m;

    return a;
}






__attribute__ ((always_inline)) static inline uint8_t mul8(uint8_t i, uint8_t j) {

    return ((int)i * (int)(j)) & 0xFF;
# 465 "../../src/lib8tion/math8.h"
}





__attribute__ ((always_inline)) static inline uint8_t qmul8(uint8_t i, uint8_t j) {

    unsigned p = (unsigned)i * (unsigned)j;
    if (p > 255)
        p = 255;
    return p;
# 498 "../../src/lib8tion/math8.h"
}


__attribute__ ((always_inline)) static inline int8_t abs8(int8_t i) {

    if (i < 0)
        i = -i;
    return i;
# 520 "../../src/lib8tion/math8.h"
}




__attribute__ ((unused)) static inline uint8_t sqrt16(uint16_t x) {
    if (x <= 1) {
        return x;
    }

    uint8_t low = 1;
    uint8_t hi, mid;

    if (x > 7904) {
        hi = 255;
    } else {
        hi = (x >> 5) + 8;
    }

    do {
        mid = (low + hi) >> 1;
        if ((uint16_t)(mid * mid) > x) {
            hi = mid - 1;
        } else {
            if (mid == 255) {
                return 255;
            }
            low = mid + 1;
        }
    } while (hi >= low);

    return low - 1;
}

__attribute__ ((always_inline)) static inline uint8_t sqrt8(uint8_t x) {
    return sqrt16(map8_to_16(x));
}







__attribute__ ((unused)) static inline uint8_t blend8(uint8_t a, uint8_t b, uint8_t amountOfB) {
# 587 "../../src/lib8tion/math8.h"
    uint16_t partial;
    uint8_t result;




    partial = (a << 8) | b;


    partial += (b * amountOfB);
    partial -= (a * amountOfB);
# 608 "../../src/lib8tion/math8.h"
    result = partial >> 8;

    return result;
# 665 "../../src/lib8tion/math8.h"
}
# 684 "../../src/lib8tion/math8.h"

# 227 "../../src/lib8tion.h" 2

# 1 "../../src/lib8tion/random8.h" 1
       
# 42 "../../src/lib8tion/random8.h"
extern uint16_t rand16seed;



__attribute__ ((unused)) static inline uint8_t random8() {
    rand16seed = (rand16seed * ((uint16_t)(2053))) + ((uint16_t)(13849));


    return (uint8_t)(((uint8_t)(rand16seed & 0xFF)) +
                     ((uint8_t)(rand16seed >> 8)));
}



__attribute__ ((unused)) static inline uint16_t random16() {
    rand16seed = (rand16seed * ((uint16_t)(2053))) + ((uint16_t)(13849));
    return rand16seed;
}



__attribute__ ((unused)) static inline uint8_t random8(uint8_t lim) {
    uint8_t r = random8();
    r = (r * lim) >> 8;
    return r;
}




__attribute__ ((unused)) static inline uint8_t random8(uint8_t min, uint8_t lim) {
    uint8_t delta = lim - min;
    uint8_t r = random8(delta) + min;
    return r;
}



__attribute__ ((unused)) static inline uint16_t random16(uint16_t lim) {
    uint16_t r = random16();
    uint32_t p = (uint32_t)lim * (uint32_t)r;
    r = p >> 16;
    return r;
}




__attribute__ ((unused)) static inline uint16_t random16(uint16_t min, uint16_t lim) {
    uint16_t delta = lim - min;
    uint16_t r = random16(delta) + min;
    return r;
}


__attribute__ ((unused)) static inline void random16_set_seed(uint16_t seed) { rand16seed = seed; }


__attribute__ ((unused)) static inline uint16_t random16_get_seed() { return rand16seed; }


__attribute__ ((unused)) static inline void random16_add_entropy(uint16_t entropy) {
    rand16seed += entropy;
}
# 229 "../../src/lib8tion.h" 2
# 1 "../../src/lib8tion/trig8.h" 1
       
# 113 "../../src/lib8tion/trig8.h"
__attribute__ ((unused)) static inline int16_t sin16_C(uint16_t theta) {
    static const uint16_t base[] = {0, 6393, 12539, 18204,
                                    23170, 27245, 30273, 32137};
    static const uint8_t slope[] = {49, 48, 44, 38, 31, 23, 14, 4};

    uint16_t offset = (theta & 0x3FFF) >> 3;
    if (theta & 0x4000)
        offset = 2047 - offset;

    uint8_t section = offset / 256;
    uint16_t b = base[section];
    uint8_t m = slope[section];

    uint8_t secoffset8 = (uint8_t)(offset) / 2;

    uint16_t mx = m * secoffset8;
    int16_t y = mx + b;

    if (theta & 0x8000)
        y = -y;

    return y;
}
# 148 "../../src/lib8tion/trig8.h"
__attribute__ ((unused)) static inline int16_t cos16(uint16_t theta) { return sin16_C(theta + 16384); }







const uint8_t b_m16_interleave[] = {0, 49, 49, 41, 90, 27, 117, 10};
# 231 "../../src/lib8tion/trig8.h"
__attribute__ ((unused)) static inline uint8_t sin8_C(uint8_t theta) {
    uint8_t offset = theta;
    if (theta & 0x40) {
        offset = (uint8_t)255 - offset;
    }
    offset &= 0x3F;

    uint8_t secoffset = offset & 0x0F;
    if (theta & 0x40)
        ++secoffset;

    uint8_t section = offset >> 4;
    uint8_t s2 = section * 2;
    const uint8_t *p = b_m16_interleave;
    p += s2;
    uint8_t b = *p;
    ++p;
    uint8_t m16 = *p;

    uint8_t mx = (m16 * secoffset) >> 4;

    int8_t y = mx + b;
    if (theta & 0x80)
        y = -y;

    y += 128;

    return y;
}
# 271 "../../src/lib8tion/trig8.h"
__attribute__ ((unused)) static inline uint8_t cos8(uint8_t theta) { return sin8_C(theta + 64); }
# 230 "../../src/lib8tion.h" 2







# 247 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline float sfract15ToFloat( sfract15 y)
{
    return y / 32768.0;
}




__attribute__ ((unused)) static inline sfract15 floatToSfract15( float f)
{
    return f * 32768.0;
}
# 283 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline uint8_t lerp8by8( uint8_t a, uint8_t b, fract8 frac)
{
    uint8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
    }
    return result;
}



__attribute__ ((unused)) static inline uint16_t lerp16by16( uint16_t a, uint16_t b, fract16 frac)
{
    uint16_t result;
    if( b > a ) {
        uint16_t delta = b - a;
        uint16_t scaled = scale16(delta, frac);
        result = a + scaled;
    } else {
        uint16_t delta = a - b;
        uint16_t scaled = scale16( delta, frac);
        result = a - scaled;
    }
    return result;
}



__attribute__ ((unused)) static inline uint16_t lerp16by8( uint16_t a, uint16_t b, fract8 frac)
{
    uint16_t result;
    if( b > a) {
        uint16_t delta = b - a;
        uint16_t scaled = scale16by8( delta, frac);
        result = a + scaled;
    } else {
        uint16_t delta = a - b;
        uint16_t scaled = scale16by8( delta, frac);
        result = a - scaled;
    }
    return result;
}



__attribute__ ((unused)) static inline int16_t lerp15by8( int16_t a, int16_t b, fract8 frac)
{
    int16_t result;
    if( b > a) {
        uint16_t delta = b - a;
        uint16_t scaled = scale16by8( delta, frac);
        result = a + scaled;
    } else {
        uint16_t delta = a - b;
        uint16_t scaled = scale16by8( delta, frac);
        result = a - scaled;
    }
    return result;
}



__attribute__ ((unused)) static inline int16_t lerp15by16( int16_t a, int16_t b, fract16 frac)
{
    int16_t result;
    if( b > a) {
        uint16_t delta = b - a;
        uint16_t scaled = scale16( delta, frac);
        result = a + scaled;
    } else {
        uint16_t delta = a - b;
        uint16_t scaled = scale16( delta, frac);
        result = a - scaled;
    }
    return result;
}
# 387 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline uint8_t map8( uint8_t in, uint8_t rangeStart, uint8_t rangeEnd)
{
    uint8_t rangeWidth = rangeEnd - rangeStart;
    uint8_t out = scale8( in, rangeWidth);
    out += rangeStart;
    return out;
}
# 408 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline uint8_t ease8InOutQuad( uint8_t i)
{
    uint8_t j = i;
    if( j & 0x80 ) {
        j = 255 - j;
    }
    uint8_t jj = scale8( j, j);
    uint8_t jj2 = jj << 1;
    if( i & 0x80 ) {
        jj2 = 255 - jj2;
    }
    return jj2;
}
# 451 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline uint16_t ease16InOutQuad( uint16_t i)
{




    uint16_t j = i;
    if (j & 0x8000) {
        j = 65535 - j;
    }
    uint16_t jj = scale16(j, j);
    uint16_t jj2 = jj << 1;
    if (i & 0x8000) {
        jj2 = 65535 - jj2;
    }
    return jj2;
}

__attribute__ ((unused)) static inline uint16_t ease16InOutCubic(uint16_t i) {
# 478 "../../src/lib8tion.h"
    uint32_t ii = scale16(i, i);
    uint32_t iii = scale16(ii, i);


    uint32_t r1 = (3 * ii) - (2 * iii);


    if (r1 > 65535) {
        return 65535;
    }
    return (uint16_t)r1;
}




__attribute__ ((unused)) static inline fract8 ease8InOutCubic( fract8 i)
{
    uint8_t ii = scale8_LEAVING_R1_DIRTY( i, i);
    uint8_t iii = scale8_LEAVING_R1_DIRTY( ii, i);

    uint16_t r1 = (3 * (uint16_t)(ii)) - ( 2 * (uint16_t)(iii));





    uint8_t result = r1;


    if( r1 & 0x100 ) {
        result = 255;
    }
    return result;
}
# 523 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline fract8 ease8InOutApprox( fract8 i)
{
    if( i < 64) {

        i /= 2;
    } else if( i > (255 - 64)) {

        i = 255 - i;
        i /= 2;
        i = 255 - i;
    } else {

        i -= 64;
        i += (i / 2);
        i += 32;
    }

    return i;
}
# 598 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline uint8_t triwave8(uint8_t in)
{
    if( in & 0x80) {
        in = 255 - in;
    }
    uint8_t out = in << 1;
    return out;
}
# 617 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline uint8_t quadwave8(uint8_t in)
{
    return ease8InOutQuad( triwave8( in));
}




__attribute__ ((unused)) static inline uint8_t cubicwave8(uint8_t in)
{
    return ease8InOutCubic( triwave8( in));
}
# 654 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline uint8_t squarewave8( uint8_t in, uint8_t pulsewidth=128)
{
    if( in < pulsewidth || (pulsewidth == 255)) {
        return 255;
    } else {
        return 0;
    }
}
# 749 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline uint16_t beat88( accum88 beats_per_minute_88, uint32_t timebase = 0)
{
# 759 "../../src/lib8tion.h"
    return (((millis()) - timebase) * beats_per_minute_88 * 280) >> 16;
}




__attribute__ ((unused)) static inline uint16_t beat16( accum88 beats_per_minute, uint32_t timebase = 0)
{

    if( beats_per_minute < 256) beats_per_minute <<= 8;
    return beat88(beats_per_minute, timebase);
}




__attribute__ ((unused)) static inline uint8_t beat8( accum88 beats_per_minute, uint32_t timebase = 0)
{
    return beat16( beats_per_minute, timebase) >> 8;
}
# 791 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline uint16_t beatsin88( accum88 beats_per_minute_88, uint16_t lowest = 0, uint16_t highest = 65535,
                              uint32_t timebase = 0, uint16_t phase_offset = 0)
{
    uint16_t beat = beat88( beats_per_minute_88, timebase);
    uint16_t beatsin = (sin16_C( beat + phase_offset) + 32768);
    uint16_t rangewidth = highest - lowest;
    uint16_t scaledbeat = scale16( beatsin, rangewidth);
    uint16_t result = lowest + scaledbeat;
    return result;
}
# 809 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline uint16_t beatsin16( accum88 beats_per_minute, uint16_t lowest = 0, uint16_t highest = 65535,
                               uint32_t timebase = 0, uint16_t phase_offset = 0)
{
    uint16_t beat = beat16( beats_per_minute, timebase);
    uint16_t beatsin = (sin16_C( beat + phase_offset) + 32768);
    uint16_t rangewidth = highest - lowest;
    uint16_t scaledbeat = scale16( beatsin, rangewidth);
    uint16_t result = lowest + scaledbeat;
    return result;
}
# 827 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline uint8_t beatsin8( accum88 beats_per_minute, uint8_t lowest = 0, uint8_t highest = 255,
                            uint32_t timebase = 0, uint8_t phase_offset = 0)
{
    uint8_t beat = beat8( beats_per_minute, timebase);
    uint8_t beatsin = sin8_C( beat + phase_offset);
    uint8_t rangewidth = highest - lowest;
    uint8_t scaledbeat = scale8( beatsin, rangewidth);
    uint8_t result = lowest + scaledbeat;
    return result;
}
# 850 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline uint16_t seconds16()
{
    uint32_t ms = millis();
    uint16_t s16;
    s16 = ms / 1000;
    return s16;
}



__attribute__ ((unused)) static inline uint16_t minutes16()
{
    uint32_t ms = millis();
    uint16_t m16;
    m16 = (ms / (60000L)) & 0xFFFF;
    return m16;
}



__attribute__ ((unused)) static inline uint8_t hours8()
{
    uint32_t ms = millis();
    uint8_t h8;
    h8 = (ms / (3600000L)) & 0xFF;
    return h8;
}
# 892 "../../src/lib8tion.h"
__attribute__ ((unused)) static inline uint16_t div1024_32_16( uint32_t in32)
{
    uint16_t out16;
# 909 "../../src/lib8tion.h"
    out16 = (in32 >> 10) & 0xFFFF;

    return out16;
}




__attribute__ ((unused)) static inline uint16_t bseconds16()
{
    uint32_t ms = millis();
    uint16_t s16;
    s16 = div1024_32_16( ms);
    return s16;
}
# 1020 "../../src/lib8tion.h"
class CEveryNMillis { public: uint32_t mPrevTrigger; uint32_t mPeriod; CEveryNMillis() { reset(); mPeriod = 1; }; CEveryNMillis(uint32_t period) { reset(); setPeriod(period); }; void setPeriod( uint32_t period) { mPeriod = period; }; uint32_t getTime() { return (uint32_t)(millis()); }; uint32_t getPeriod() { return mPeriod; }; uint32_t getElapsed() { return getTime() - mPrevTrigger; } uint32_t getRemaining() { return mPeriod - getElapsed(); } uint32_t getLastTriggerTime() { return mPrevTrigger; } bool ready() { bool isReady = (getElapsed() >= mPeriod); if( isReady ) { reset(); } return isReady; } void reset() { mPrevTrigger = getTime(); }; void trigger() { mPrevTrigger = getTime() - mPeriod; }; operator bool() { return ready(); } };;


class CEveryNSeconds { public: uint16_t mPrevTrigger; uint16_t mPeriod; CEveryNSeconds() { reset(); mPeriod = 1; }; CEveryNSeconds(uint16_t period) { reset(); setPeriod(period); }; void setPeriod( uint16_t period) { mPeriod = period; }; uint16_t getTime() { return (uint16_t)(seconds16()); }; uint16_t getPeriod() { return mPeriod; }; uint16_t getElapsed() { return getTime() - mPrevTrigger; } uint16_t getRemaining() { return mPeriod - getElapsed(); } uint16_t getLastTriggerTime() { return mPrevTrigger; } bool ready() { bool isReady = (getElapsed() >= mPeriod); if( isReady ) { reset(); } return isReady; } void reset() { mPrevTrigger = getTime(); }; void trigger() { mPrevTrigger = getTime() - mPeriod; }; operator bool() { return ready(); } };;


class CEveryNBSeconds { public: uint16_t mPrevTrigger; uint16_t mPeriod; CEveryNBSeconds() { reset(); mPeriod = 1; }; CEveryNBSeconds(uint16_t period) { reset(); setPeriod(period); }; void setPeriod( uint16_t period) { mPeriod = period; }; uint16_t getTime() { return (uint16_t)(bseconds16()); }; uint16_t getPeriod() { return mPeriod; }; uint16_t getElapsed() { return getTime() - mPrevTrigger; } uint16_t getRemaining() { return mPeriod - getElapsed(); } uint16_t getLastTriggerTime() { return mPrevTrigger; } bool ready() { bool isReady = (getElapsed() >= mPeriod); if( isReady ) { reset(); } return isReady; } void reset() { mPrevTrigger = getTime(); }; void trigger() { mPrevTrigger = getTime() - mPeriod; }; operator bool() { return ready(); } };;


class CEveryNMinutes { public: uint16_t mPrevTrigger; uint16_t mPeriod; CEveryNMinutes() { reset(); mPeriod = 1; }; CEveryNMinutes(uint16_t period) { reset(); setPeriod(period); }; void setPeriod( uint16_t period) { mPeriod = period; }; uint16_t getTime() { return (uint16_t)(minutes16()); }; uint16_t getPeriod() { return mPeriod; }; uint16_t getElapsed() { return getTime() - mPrevTrigger; } uint16_t getRemaining() { return mPeriod - getElapsed(); } uint16_t getLastTriggerTime() { return mPrevTrigger; } bool ready() { bool isReady = (getElapsed() >= mPeriod); if( isReady ) { reset(); } return isReady; } void reset() { mPrevTrigger = getTime(); }; void trigger() { mPrevTrigger = getTime() - mPeriod; }; operator bool() { return ready(); } };;


class CEveryNHours { public: uint8_t mPrevTrigger; uint8_t mPeriod; CEveryNHours() { reset(); mPeriod = 1; }; CEveryNHours(uint8_t period) { reset(); setPeriod(period); }; void setPeriod( uint8_t period) { mPeriod = period; }; uint8_t getTime() { return (uint8_t)(hours8()); }; uint8_t getPeriod() { return mPeriod; }; uint8_t getElapsed() { return getTime() - mPrevTrigger; } uint8_t getRemaining() { return mPeriod - getElapsed(); } uint8_t getLastTriggerTime() { return mPrevTrigger; } bool ready() { bool isReady = (getElapsed() >= mPeriod); if( isReady ) { reset(); } return isReady; } void reset() { mPrevTrigger = getTime(); }; void trigger() { mPrevTrigger = getTime() - mPeriod; }; operator bool() { return ready(); } };;





class CEveryNMillisDynamic {
public:
    uint32_t mPrevTrigger;
    uint32_t mPeriod;

    CEveryNMillisDynamic(uint32_t period) : mPeriod(period) { reset(); };
    uint32_t getTime() { return millis(); };
    uint32_t getPeriod() const { return mPeriod; };
    uint32_t getElapsed() { return getTime() - mPrevTrigger; }
    uint32_t getRemaining() { return getPeriod() - getElapsed(); }
    uint32_t getLastTriggerTime() { return mPrevTrigger; }
    bool ready() {
        bool isReady = (getElapsed() >= getPeriod());
        if( isReady ) { reset(); }
        return isReady;
    }
    void reset() { mPrevTrigger = getTime(); };
    void trigger() { mPrevTrigger = getTime() - getPeriod(); };
    void setPeriod(uint32_t period) { mPeriod = period; }

    operator bool() { return ready(); }
};
# 1068 "../../src/lib8tion.h"
class CEveryNMillisRandom {
public:
    uint32_t mPrevTrigger;
    uint32_t mPeriod;
    uint32_t mMinPeriod;
    uint32_t mMaxPeriod;

    CEveryNMillisRandom(uint32_t minPeriod, uint32_t maxPeriod)
      : mMinPeriod(minPeriod), mMaxPeriod(maxPeriod)
    {
        computeNext();
        reset();
    }

    void computeNext() {

        uint32_t range = mMaxPeriod - mMinPeriod + 1;
        mPeriod = mMinPeriod + random16(range);
    }

    uint32_t getTime() const { return millis(); }

    bool ready() {
        uint32_t now = getTime();
        if (now - mPrevTrigger >= mPeriod) {
            mPrevTrigger = now;
            computeNext();
            return true;
        }
        return false;
    }

    void reset() { mPrevTrigger = getTime(); }
};
# 1246 "../../src/lib8tion.h"

# 8 "../../src/pixeltypes.h" 2

# 1 "../../src/eorder.h" 1



       









enum EOrder {
 RGB=0012,
 RBG=0021,
 GRB=0102,
 GBR=0120,
 BRG=0201,
 BGR=0210
};


enum EOrderW {
 W3 = 0x3,
 W2 = 0x2,
 W1 = 0x1,
 W0 = 0x0,
 WDefault = W3
};


# 10 "../../src/pixeltypes.h" 2

# 1 "../../src/crgb.hpp" 1



       







# 1 "../../src/fl/str.h" 1
       
# 14 "../../src/fl/str.h"
# 1 "../../src/fl/geometry.h" 1
       

# 1 "../../src/fl/math.h" 1
       


# 1 "/usr/include/c++/14/math.h" 1 3
# 36 "/usr/include/c++/14/math.h" 3
# 1 "/usr/include/c++/14/cmath" 1 3
# 39 "/usr/include/c++/14/cmath" 3
       
# 40 "/usr/include/c++/14/cmath" 3

# 1 "/usr/include/c++/14/bits/requires_hosted.h" 1 3
# 31 "/usr/include/c++/14/bits/requires_hosted.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 1 3
# 33 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 3
       
# 34 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 3
# 308 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 3

# 308 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;


#pragma GCC visibility push(default)


  extern "C++" __attribute__ ((__noreturn__, __always_inline__))
  inline void __terminate() noexcept
  {
    void terminate() noexcept __attribute__ ((__noreturn__,__cold__));
    terminate();
  }
#pragma GCC visibility pop
}
# 341 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 534 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)




  __attribute__((__always_inline__))
  constexpr inline bool
  __is_constant_evaluated() noexcept
  {





    return __builtin_is_constant_evaluated();



  }
#pragma GCC visibility pop
}
# 573 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)

  extern "C++" __attribute__ ((__noreturn__))
  void
  __glibcxx_assert_fail
    (const char* __file, int __line, const char* __function,
     const char* __condition)
  noexcept;
#pragma GCC visibility pop
}
# 604 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 3
namespace std
{
  __attribute__((__always_inline__,__visibility__("default")))
  inline void
  __glibcxx_assert_fail()
  { }
}
# 683 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/14/bits/os_defines.h" 1 3
# 684 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 2 3


# 1 "/usr/include/x86_64-linux-gnu/c++/14/bits/cpu_defines.h" 1 3
# 687 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 2 3
# 828 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 3
namespace __gnu_cxx
{
  typedef __decltype(0.0bf16) __bfloat16_t;
}
# 890 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 3
# 1 "/usr/include/c++/14/pstl/pstl_config.h" 1 3
# 891 "/usr/include/x86_64-linux-gnu/c++/14/bits/c++config.h" 2 3
# 32 "/usr/include/c++/14/bits/requires_hosted.h" 2 3
# 42 "/usr/include/c++/14/cmath" 2 3


# 1 "/usr/include/c++/14/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/14/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/14/bits/cpp_type_traits.h" 3


# 1 "/usr/include/c++/14/bits/version.h" 1 3
# 47 "/usr/include/c++/14/bits/version.h" 3
       
# 48 "/usr/include/c++/14/bits/version.h" 3
# 39 "/usr/include/c++/14/bits/cpp_type_traits.h" 2 3
# 68 "/usr/include/c++/14/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 185 "/usr/include/c++/14/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 273 "/usr/include/c++/14/bits/cpp_type_traits.h" 3
__extension__ template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; __extension__ template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 290 "/usr/include/c++/14/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 367 "/usr/include/c++/14/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  enum class byte : unsigned char;

  template<>
    struct __is_byte<byte>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 471 "/usr/include/c++/14/bits/cpp_type_traits.h" 3
  template<typename> struct iterator_traits;


  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable
    {
      enum { __value = __is_trivially_copyable(_Tp) };
    };




  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable<volatile _Tp>
    {
      enum { __value = 0 };
    };


  template<typename _OutputIter, typename _InputIter>
    struct __memcpyable
    {
      enum { __value = 0 };
    };

  template<typename _Tp>
    struct __memcpyable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcpyable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };






  template<typename _Iter1, typename _Iter2>
    struct __memcmpable
    {
      enum { __value = 0 };
    };


  template<typename _Tp>
    struct __memcmpable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<const _Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };







  template<typename _Tp, bool _TreatAsBytes =



 __is_byte<_Tp>::__value

    >
    struct __is_memcmp_ordered
    {
      static const bool __value = _Tp(-1) > _Tp(1);
    };

  template<typename _Tp>
    struct __is_memcmp_ordered<_Tp, false>
    {
      static const bool __value = false;
    };


  template<typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>
    struct __is_memcmp_ordered_with
    {
      static const bool __value = __is_memcmp_ordered<_Tp>::__value
 && __is_memcmp_ordered<_Up>::__value;
    };

  template<typename _Tp, typename _Up>
    struct __is_memcmp_ordered_with<_Tp, _Up, false>
    {
      static const bool __value = false;
    };
# 580 "/usr/include/c++/14/bits/cpp_type_traits.h" 3
  template<>
    struct __is_memcmp_ordered_with<std::byte, std::byte, true>
    { static constexpr bool __value = true; };

  template<typename _Tp, bool _SameSize>
    struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize>
    { static constexpr bool __value = false; };

  template<typename _Up, bool _SameSize>
    struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize>
    { static constexpr bool __value = false; };





  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
   
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 45 "/usr/include/c++/14/cmath" 2 3
# 1 "/usr/include/c++/14/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/14/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/14/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    constexpr
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    constexpr
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  constexpr bool
  __is_null_pointer(std::nullptr_t)
  { return true; }




  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };
# 225 "/usr/include/c++/14/ext/type_traits.h" 3
  template<typename... _Tp>
    using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));



  template<typename _Tp, typename _Up>
    using __promote_2 = __promote<__promoted_t<_Tp, _Up>>;

  template<typename _Tp, typename _Up, typename _Vp>
    using __promote_3 = __promote<__promoted_t<_Tp, _Up, _Vp>>;

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    using __promote_4 = __promote<__promoted_t<_Tp, _Up, _Vp, _Wp>>;
# 269 "/usr/include/c++/14/ext/type_traits.h" 3

}
}
# 46 "/usr/include/c++/14/cmath" 2 3

# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 131 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 132 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 44 "/usr/include/math.h" 2 3 4
# 156 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 157 "/usr/include/math.h" 2 3 4
# 167 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 208 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 209 "/usr/include/math.h" 2 3 4
# 251 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 252 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };


# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-macros.h" 1 3 4
# 276 "/usr/include/math.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbit (double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinf (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnan (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) noexcept (true);


extern int __issignaling (double __value) noexcept (true)
     __attribute__ ((__const__));
# 282 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern double acos (double __x) noexcept (true); extern double __acos (double __x) noexcept (true);

 extern double asin (double __x) noexcept (true); extern double __asin (double __x) noexcept (true);

 extern double atan (double __x) noexcept (true); extern double __atan (double __x) noexcept (true);

 extern double atan2 (double __y, double __x) noexcept (true); extern double __atan2 (double __y, double __x) noexcept (true);


 extern double cos (double __x) noexcept (true); extern double __cos (double __x) noexcept (true);

 extern double sin (double __x) noexcept (true); extern double __sin (double __x) noexcept (true);

 extern double tan (double __x) noexcept (true); extern double __tan (double __x) noexcept (true);



extern double acospi (double __x) noexcept (true); extern double __acospi (double __x) noexcept (true);

extern double asinpi (double __x) noexcept (true); extern double __asinpi (double __x) noexcept (true);

extern double atanpi (double __x) noexcept (true); extern double __atanpi (double __x) noexcept (true);

extern double atan2pi (double __y, double __x) noexcept (true); extern double __atan2pi (double __y, double __x) noexcept (true);


 extern double cospi (double __x) noexcept (true); extern double __cospi (double __x) noexcept (true);

 extern double sinpi (double __x) noexcept (true); extern double __sinpi (double __x) noexcept (true);

 extern double tanpi (double __x) noexcept (true); extern double __tanpi (double __x) noexcept (true);





 extern double cosh (double __x) noexcept (true); extern double __cosh (double __x) noexcept (true);

 extern double sinh (double __x) noexcept (true); extern double __sinh (double __x) noexcept (true);

 extern double tanh (double __x) noexcept (true); extern double __tanh (double __x) noexcept (true);



 extern void sincos (double __x, double *__sinx, double *__cosx) noexcept (true); extern void __sincos (double __x, double *__sinx, double *__cosx) noexcept (true)
                                                        ;




 extern double acosh (double __x) noexcept (true); extern double __acosh (double __x) noexcept (true);

 extern double asinh (double __x) noexcept (true); extern double __asinh (double __x) noexcept (true);

 extern double atanh (double __x) noexcept (true); extern double __atanh (double __x) noexcept (true);





 extern double exp (double __x) noexcept (true); extern double __exp (double __x) noexcept (true);


extern double frexp (double __x, int *__exponent) noexcept (true); extern double __frexp (double __x, int *__exponent) noexcept (true);


extern double ldexp (double __x, int __exponent) noexcept (true); extern double __ldexp (double __x, int __exponent) noexcept (true);


 extern double log (double __x) noexcept (true); extern double __log (double __x) noexcept (true);


 extern double log10 (double __x) noexcept (true); extern double __log10 (double __x) noexcept (true);


extern double modf (double __x, double *__iptr) noexcept (true); extern double __modf (double __x, double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern double exp10 (double __x) noexcept (true); extern double __exp10 (double __x) noexcept (true);


extern double exp2m1 (double __x) noexcept (true); extern double __exp2m1 (double __x) noexcept (true);


extern double exp10m1 (double __x) noexcept (true); extern double __exp10m1 (double __x) noexcept (true);


extern double log2p1 (double __x) noexcept (true); extern double __log2p1 (double __x) noexcept (true);


extern double log10p1 (double __x) noexcept (true); extern double __log10p1 (double __x) noexcept (true);


 extern double logp1 (double __x) noexcept (true); extern double __logp1 (double __x) noexcept (true);




 extern double expm1 (double __x) noexcept (true); extern double __expm1 (double __x) noexcept (true);


 extern double log1p (double __x) noexcept (true); extern double __log1p (double __x) noexcept (true);


extern double logb (double __x) noexcept (true); extern double __logb (double __x) noexcept (true);




 extern double exp2 (double __x) noexcept (true); extern double __exp2 (double __x) noexcept (true);


 extern double log2 (double __x) noexcept (true); extern double __log2 (double __x) noexcept (true);






 extern double pow (double __x, double __y) noexcept (true); extern double __pow (double __x, double __y) noexcept (true);


extern double sqrt (double __x) noexcept (true); extern double __sqrt (double __x) noexcept (true);



 extern double hypot (double __x, double __y) noexcept (true); extern double __hypot (double __x, double __y) noexcept (true);




 extern double cbrt (double __x) noexcept (true); extern double __cbrt (double __x) noexcept (true);






extern double ceil (double __x) noexcept (true) __attribute__ ((__const__));


extern double fabs (double __x) noexcept (true) __attribute__ ((__const__));


extern double floor (double __x) noexcept (true) __attribute__ ((__const__));


extern double fmod (double __x, double __y) noexcept (true); extern double __fmod (double __x, double __y) noexcept (true);
# 216 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern double drem (double __x, double __y) noexcept (true); extern double __drem (double __x, double __y) noexcept (true);



extern double significand (double __x) noexcept (true); extern double __significand (double __x) noexcept (true);






extern double copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double nan (const char *__tagb) noexcept (true); extern double __nan (const char *__tagb) noexcept (true);
# 253 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0 (double) noexcept (true); extern double __j0 (double) noexcept (true);
extern double j1 (double) noexcept (true); extern double __j1 (double) noexcept (true);
extern double jn (int, double) noexcept (true); extern double __jn (int, double) noexcept (true);
extern double y0 (double) noexcept (true); extern double __y0 (double) noexcept (true);
extern double y1 (double) noexcept (true); extern double __y1 (double) noexcept (true);
extern double yn (int, double) noexcept (true); extern double __yn (int, double) noexcept (true);





 extern double erf (double) noexcept (true); extern double __erf (double) noexcept (true);
 extern double erfc (double) noexcept (true); extern double __erfc (double) noexcept (true);
extern double lgamma (double) noexcept (true); extern double __lgamma (double) noexcept (true);




extern double tgamma (double) noexcept (true); extern double __tgamma (double) noexcept (true);





extern double gamma (double) noexcept (true); extern double __gamma (double) noexcept (true);







extern double lgamma_r (double, int *__signgamp) noexcept (true); extern double __lgamma_r (double, int *__signgamp) noexcept (true);






extern double rint (double __x) noexcept (true); extern double __rint (double __x) noexcept (true);


extern double nextafter (double __x, double __y) noexcept (true); extern double __nextafter (double __x, double __y) noexcept (true);

extern double nexttoward (double __x, long double __y) noexcept (true); extern double __nexttoward (double __x, long double __y) noexcept (true);




extern double nextdown (double __x) noexcept (true); extern double __nextdown (double __x) noexcept (true);

extern double nextup (double __x) noexcept (true); extern double __nextup (double __x) noexcept (true);



extern double remainder (double __x, double __y) noexcept (true); extern double __remainder (double __x, double __y) noexcept (true);



extern double scalbn (double __x, int __n) noexcept (true); extern double __scalbn (double __x, int __n) noexcept (true);



extern int ilogb (double __x) noexcept (true); extern int __ilogb (double __x) noexcept (true);




extern long int llogb (double __x) noexcept (true); extern long int __llogb (double __x) noexcept (true);




extern double scalbln (double __x, long int __n) noexcept (true); extern double __scalbln (double __x, long int __n) noexcept (true);



extern double nearbyint (double __x) noexcept (true); extern double __nearbyint (double __x) noexcept (true);



extern double round (double __x) noexcept (true) __attribute__ ((__const__));



extern double trunc (double __x) noexcept (true) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) noexcept (true); extern double __remquo (double __x, double __y, int *__quo) noexcept (true);






extern long int lrint (double __x) noexcept (true); extern long int __lrint (double __x) noexcept (true);
__extension__
extern long long int llrint (double __x) noexcept (true); extern long long int __llrint (double __x) noexcept (true);



extern long int lround (double __x) noexcept (true); extern long int __lround (double __x) noexcept (true);
__extension__
extern long long int llround (double __x) noexcept (true); extern long long int __llround (double __x) noexcept (true);



extern double fdim (double __x, double __y) noexcept (true); extern double __fdim (double __x, double __y) noexcept (true);



extern double fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) noexcept (true); extern double __fma (double __x, double __y, double __z) noexcept (true);




extern double roundeven (double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalize (double *__cx, const double *__x) noexcept (true);






extern double fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorder (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) noexcept (true); extern double __getpayload (const double *__x) noexcept (true);


extern int setpayload (double *__x, double __payload) noexcept (true);


extern int setpayloadsig (double *__x, double __payload) noexcept (true);







extern double scalb (double __x, double __n) noexcept (true); extern double __scalb (double __x, double __n) noexcept (true);
# 283 "/usr/include/math.h" 2 3 4
# 298 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf (float __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) noexcept (true);


extern int __issignalingf (float __value) noexcept (true)
     __attribute__ ((__const__));
# 299 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern float acosf (float __x) noexcept (true); extern float __acosf (float __x) noexcept (true);

 extern float asinf (float __x) noexcept (true); extern float __asinf (float __x) noexcept (true);

 extern float atanf (float __x) noexcept (true); extern float __atanf (float __x) noexcept (true);

 extern float atan2f (float __y, float __x) noexcept (true); extern float __atan2f (float __y, float __x) noexcept (true);


 extern float cosf (float __x) noexcept (true); extern float __cosf (float __x) noexcept (true);

 extern float sinf (float __x) noexcept (true); extern float __sinf (float __x) noexcept (true);

 extern float tanf (float __x) noexcept (true); extern float __tanf (float __x) noexcept (true);



extern float acospif (float __x) noexcept (true); extern float __acospif (float __x) noexcept (true);

extern float asinpif (float __x) noexcept (true); extern float __asinpif (float __x) noexcept (true);

extern float atanpif (float __x) noexcept (true); extern float __atanpif (float __x) noexcept (true);

extern float atan2pif (float __y, float __x) noexcept (true); extern float __atan2pif (float __y, float __x) noexcept (true);


 extern float cospif (float __x) noexcept (true); extern float __cospif (float __x) noexcept (true);

 extern float sinpif (float __x) noexcept (true); extern float __sinpif (float __x) noexcept (true);

 extern float tanpif (float __x) noexcept (true); extern float __tanpif (float __x) noexcept (true);





 extern float coshf (float __x) noexcept (true); extern float __coshf (float __x) noexcept (true);

 extern float sinhf (float __x) noexcept (true); extern float __sinhf (float __x) noexcept (true);

 extern float tanhf (float __x) noexcept (true); extern float __tanhf (float __x) noexcept (true);



 extern void sincosf (float __x, float *__sinx, float *__cosx) noexcept (true); extern void __sincosf (float __x, float *__sinx, float *__cosx) noexcept (true)
                                                        ;




 extern float acoshf (float __x) noexcept (true); extern float __acoshf (float __x) noexcept (true);

 extern float asinhf (float __x) noexcept (true); extern float __asinhf (float __x) noexcept (true);

 extern float atanhf (float __x) noexcept (true); extern float __atanhf (float __x) noexcept (true);





 extern float expf (float __x) noexcept (true); extern float __expf (float __x) noexcept (true);


extern float frexpf (float __x, int *__exponent) noexcept (true); extern float __frexpf (float __x, int *__exponent) noexcept (true);


extern float ldexpf (float __x, int __exponent) noexcept (true); extern float __ldexpf (float __x, int __exponent) noexcept (true);


 extern float logf (float __x) noexcept (true); extern float __logf (float __x) noexcept (true);


 extern float log10f (float __x) noexcept (true); extern float __log10f (float __x) noexcept (true);


extern float modff (float __x, float *__iptr) noexcept (true); extern float __modff (float __x, float *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern float exp10f (float __x) noexcept (true); extern float __exp10f (float __x) noexcept (true);


extern float exp2m1f (float __x) noexcept (true); extern float __exp2m1f (float __x) noexcept (true);


extern float exp10m1f (float __x) noexcept (true); extern float __exp10m1f (float __x) noexcept (true);


extern float log2p1f (float __x) noexcept (true); extern float __log2p1f (float __x) noexcept (true);


extern float log10p1f (float __x) noexcept (true); extern float __log10p1f (float __x) noexcept (true);


 extern float logp1f (float __x) noexcept (true); extern float __logp1f (float __x) noexcept (true);




 extern float expm1f (float __x) noexcept (true); extern float __expm1f (float __x) noexcept (true);


 extern float log1pf (float __x) noexcept (true); extern float __log1pf (float __x) noexcept (true);


extern float logbf (float __x) noexcept (true); extern float __logbf (float __x) noexcept (true);




 extern float exp2f (float __x) noexcept (true); extern float __exp2f (float __x) noexcept (true);


 extern float log2f (float __x) noexcept (true); extern float __log2f (float __x) noexcept (true);






 extern float powf (float __x, float __y) noexcept (true); extern float __powf (float __x, float __y) noexcept (true);


extern float sqrtf (float __x) noexcept (true); extern float __sqrtf (float __x) noexcept (true);



 extern float hypotf (float __x, float __y) noexcept (true); extern float __hypotf (float __x, float __y) noexcept (true);




 extern float cbrtf (float __x) noexcept (true); extern float __cbrtf (float __x) noexcept (true);






extern float ceilf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fabsf (float __x) noexcept (true) __attribute__ ((__const__));


extern float floorf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) noexcept (true); extern float __fmodf (float __x, float __y) noexcept (true);
# 210 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern float dremf (float __x, float __y) noexcept (true); extern float __dremf (float __x, float __y) noexcept (true);



extern float significandf (float __x) noexcept (true); extern float __significandf (float __x) noexcept (true);






extern float copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float nanf (const char *__tagb) noexcept (true); extern float __nanf (const char *__tagb) noexcept (true);
# 246 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));





extern float j0f (float) noexcept (true); extern float __j0f (float) noexcept (true);
extern float j1f (float) noexcept (true); extern float __j1f (float) noexcept (true);
extern float jnf (int, float) noexcept (true); extern float __jnf (int, float) noexcept (true);
extern float y0f (float) noexcept (true); extern float __y0f (float) noexcept (true);
extern float y1f (float) noexcept (true); extern float __y1f (float) noexcept (true);
extern float ynf (int, float) noexcept (true); extern float __ynf (int, float) noexcept (true);





 extern float erff (float) noexcept (true); extern float __erff (float) noexcept (true);
 extern float erfcf (float) noexcept (true); extern float __erfcf (float) noexcept (true);
extern float lgammaf (float) noexcept (true); extern float __lgammaf (float) noexcept (true);




extern float tgammaf (float) noexcept (true); extern float __tgammaf (float) noexcept (true);





extern float gammaf (float) noexcept (true); extern float __gammaf (float) noexcept (true);







extern float lgammaf_r (float, int *__signgamp) noexcept (true); extern float __lgammaf_r (float, int *__signgamp) noexcept (true);






extern float rintf (float __x) noexcept (true); extern float __rintf (float __x) noexcept (true);


extern float nextafterf (float __x, float __y) noexcept (true); extern float __nextafterf (float __x, float __y) noexcept (true);

extern float nexttowardf (float __x, long double __y) noexcept (true); extern float __nexttowardf (float __x, long double __y) noexcept (true);




extern float nextdownf (float __x) noexcept (true); extern float __nextdownf (float __x) noexcept (true);

extern float nextupf (float __x) noexcept (true); extern float __nextupf (float __x) noexcept (true);



extern float remainderf (float __x, float __y) noexcept (true); extern float __remainderf (float __x, float __y) noexcept (true);



extern float scalbnf (float __x, int __n) noexcept (true); extern float __scalbnf (float __x, int __n) noexcept (true);



extern int ilogbf (float __x) noexcept (true); extern int __ilogbf (float __x) noexcept (true);




extern long int llogbf (float __x) noexcept (true); extern long int __llogbf (float __x) noexcept (true);




extern float scalblnf (float __x, long int __n) noexcept (true); extern float __scalblnf (float __x, long int __n) noexcept (true);



extern float nearbyintf (float __x) noexcept (true); extern float __nearbyintf (float __x) noexcept (true);



extern float roundf (float __x) noexcept (true) __attribute__ ((__const__));



extern float truncf (float __x) noexcept (true) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) noexcept (true); extern float __remquof (float __x, float __y, int *__quo) noexcept (true);






extern long int lrintf (float __x) noexcept (true); extern long int __lrintf (float __x) noexcept (true);
__extension__
extern long long int llrintf (float __x) noexcept (true); extern long long int __llrintf (float __x) noexcept (true);



extern long int lroundf (float __x) noexcept (true); extern long int __lroundf (float __x) noexcept (true);
__extension__
extern long long int llroundf (float __x) noexcept (true); extern long long int __llroundf (float __x) noexcept (true);



extern float fdimf (float __x, float __y) noexcept (true); extern float __fdimf (float __x, float __y) noexcept (true);



extern float fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) noexcept (true); extern float __fmaf (float __x, float __y, float __z) noexcept (true);




extern float roundevenf (float __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef (float *__cx, const float *__x) noexcept (true);






extern float fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) noexcept (true); extern float __getpayloadf (const float *__x) noexcept (true);


extern int setpayloadf (float *__x, float __payload) noexcept (true);


extern int setpayloadsigf (float *__x, float __payload) noexcept (true);







extern float scalbf (float __x, float __n) noexcept (true); extern float __scalbf (float __x, float __n) noexcept (true);
# 300 "/usr/include/math.h" 2 3 4
# 367 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitl (long double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) noexcept (true);


extern int __issignalingl (long double __value) noexcept (true)
     __attribute__ ((__const__));
# 368 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern long double acosl (long double __x) noexcept (true); extern long double __acosl (long double __x) noexcept (true);

 extern long double asinl (long double __x) noexcept (true); extern long double __asinl (long double __x) noexcept (true);

 extern long double atanl (long double __x) noexcept (true); extern long double __atanl (long double __x) noexcept (true);

 extern long double atan2l (long double __y, long double __x) noexcept (true); extern long double __atan2l (long double __y, long double __x) noexcept (true);


 extern long double cosl (long double __x) noexcept (true); extern long double __cosl (long double __x) noexcept (true);

 extern long double sinl (long double __x) noexcept (true); extern long double __sinl (long double __x) noexcept (true);

 extern long double tanl (long double __x) noexcept (true); extern long double __tanl (long double __x) noexcept (true);



extern long double acospil (long double __x) noexcept (true); extern long double __acospil (long double __x) noexcept (true);

extern long double asinpil (long double __x) noexcept (true); extern long double __asinpil (long double __x) noexcept (true);

extern long double atanpil (long double __x) noexcept (true); extern long double __atanpil (long double __x) noexcept (true);

extern long double atan2pil (long double __y, long double __x) noexcept (true); extern long double __atan2pil (long double __y, long double __x) noexcept (true);


 extern long double cospil (long double __x) noexcept (true); extern long double __cospil (long double __x) noexcept (true);

 extern long double sinpil (long double __x) noexcept (true); extern long double __sinpil (long double __x) noexcept (true);

 extern long double tanpil (long double __x) noexcept (true); extern long double __tanpil (long double __x) noexcept (true);





 extern long double coshl (long double __x) noexcept (true); extern long double __coshl (long double __x) noexcept (true);

 extern long double sinhl (long double __x) noexcept (true); extern long double __sinhl (long double __x) noexcept (true);

 extern long double tanhl (long double __x) noexcept (true); extern long double __tanhl (long double __x) noexcept (true);



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true)
                                                        ;




 extern long double acoshl (long double __x) noexcept (true); extern long double __acoshl (long double __x) noexcept (true);

 extern long double asinhl (long double __x) noexcept (true); extern long double __asinhl (long double __x) noexcept (true);

 extern long double atanhl (long double __x) noexcept (true); extern long double __atanhl (long double __x) noexcept (true);





 extern long double expl (long double __x) noexcept (true); extern long double __expl (long double __x) noexcept (true);


extern long double frexpl (long double __x, int *__exponent) noexcept (true); extern long double __frexpl (long double __x, int *__exponent) noexcept (true);


extern long double ldexpl (long double __x, int __exponent) noexcept (true); extern long double __ldexpl (long double __x, int __exponent) noexcept (true);


 extern long double logl (long double __x) noexcept (true); extern long double __logl (long double __x) noexcept (true);


 extern long double log10l (long double __x) noexcept (true); extern long double __log10l (long double __x) noexcept (true);


extern long double modfl (long double __x, long double *__iptr) noexcept (true); extern long double __modfl (long double __x, long double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern long double exp10l (long double __x) noexcept (true); extern long double __exp10l (long double __x) noexcept (true);


extern long double exp2m1l (long double __x) noexcept (true); extern long double __exp2m1l (long double __x) noexcept (true);


extern long double exp10m1l (long double __x) noexcept (true); extern long double __exp10m1l (long double __x) noexcept (true);


extern long double log2p1l (long double __x) noexcept (true); extern long double __log2p1l (long double __x) noexcept (true);


extern long double log10p1l (long double __x) noexcept (true); extern long double __log10p1l (long double __x) noexcept (true);


 extern long double logp1l (long double __x) noexcept (true); extern long double __logp1l (long double __x) noexcept (true);




 extern long double expm1l (long double __x) noexcept (true); extern long double __expm1l (long double __x) noexcept (true);


 extern long double log1pl (long double __x) noexcept (true); extern long double __log1pl (long double __x) noexcept (true);


extern long double logbl (long double __x) noexcept (true); extern long double __logbl (long double __x) noexcept (true);




 extern long double exp2l (long double __x) noexcept (true); extern long double __exp2l (long double __x) noexcept (true);


 extern long double log2l (long double __x) noexcept (true); extern long double __log2l (long double __x) noexcept (true);






 extern long double powl (long double __x, long double __y) noexcept (true); extern long double __powl (long double __x, long double __y) noexcept (true);


extern long double sqrtl (long double __x) noexcept (true); extern long double __sqrtl (long double __x) noexcept (true);



 extern long double hypotl (long double __x, long double __y) noexcept (true); extern long double __hypotl (long double __x, long double __y) noexcept (true);




 extern long double cbrtl (long double __x) noexcept (true); extern long double __cbrtl (long double __x) noexcept (true);






extern long double ceill (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fabsl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double floorl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) noexcept (true); extern long double __fmodl (long double __x, long double __y) noexcept (true);
# 210 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) noexcept (true); extern long double __dreml (long double __x, long double __y) noexcept (true);



extern long double significandl (long double __x) noexcept (true); extern long double __significandl (long double __x) noexcept (true);






extern long double copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) noexcept (true); extern long double __nanl (const char *__tagb) noexcept (true);
# 246 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));





extern long double j0l (long double) noexcept (true); extern long double __j0l (long double) noexcept (true);
extern long double j1l (long double) noexcept (true); extern long double __j1l (long double) noexcept (true);
extern long double jnl (int, long double) noexcept (true); extern long double __jnl (int, long double) noexcept (true);
extern long double y0l (long double) noexcept (true); extern long double __y0l (long double) noexcept (true);
extern long double y1l (long double) noexcept (true); extern long double __y1l (long double) noexcept (true);
extern long double ynl (int, long double) noexcept (true); extern long double __ynl (int, long double) noexcept (true);





 extern long double erfl (long double) noexcept (true); extern long double __erfl (long double) noexcept (true);
 extern long double erfcl (long double) noexcept (true); extern long double __erfcl (long double) noexcept (true);
extern long double lgammal (long double) noexcept (true); extern long double __lgammal (long double) noexcept (true);




extern long double tgammal (long double) noexcept (true); extern long double __tgammal (long double) noexcept (true);





extern long double gammal (long double) noexcept (true); extern long double __gammal (long double) noexcept (true);







extern long double lgammal_r (long double, int *__signgamp) noexcept (true); extern long double __lgammal_r (long double, int *__signgamp) noexcept (true);






extern long double rintl (long double __x) noexcept (true); extern long double __rintl (long double __x) noexcept (true);


extern long double nextafterl (long double __x, long double __y) noexcept (true); extern long double __nextafterl (long double __x, long double __y) noexcept (true);

extern long double nexttowardl (long double __x, long double __y) noexcept (true); extern long double __nexttowardl (long double __x, long double __y) noexcept (true);




extern long double nextdownl (long double __x) noexcept (true); extern long double __nextdownl (long double __x) noexcept (true);

extern long double nextupl (long double __x) noexcept (true); extern long double __nextupl (long double __x) noexcept (true);



extern long double remainderl (long double __x, long double __y) noexcept (true); extern long double __remainderl (long double __x, long double __y) noexcept (true);



extern long double scalbnl (long double __x, int __n) noexcept (true); extern long double __scalbnl (long double __x, int __n) noexcept (true);



extern int ilogbl (long double __x) noexcept (true); extern int __ilogbl (long double __x) noexcept (true);




extern long int llogbl (long double __x) noexcept (true); extern long int __llogbl (long double __x) noexcept (true);




extern long double scalblnl (long double __x, long int __n) noexcept (true); extern long double __scalblnl (long double __x, long int __n) noexcept (true);



extern long double nearbyintl (long double __x) noexcept (true); extern long double __nearbyintl (long double __x) noexcept (true);



extern long double roundl (long double __x) noexcept (true) __attribute__ ((__const__));



extern long double truncl (long double __x) noexcept (true) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) noexcept (true); extern long double __remquol (long double __x, long double __y, int *__quo) noexcept (true);






extern long int lrintl (long double __x) noexcept (true); extern long int __lrintl (long double __x) noexcept (true);
__extension__
extern long long int llrintl (long double __x) noexcept (true); extern long long int __llrintl (long double __x) noexcept (true);



extern long int lroundl (long double __x) noexcept (true); extern long int __lroundl (long double __x) noexcept (true);
__extension__
extern long long int llroundl (long double __x) noexcept (true); extern long long int __llroundl (long double __x) noexcept (true);



extern long double fdiml (long double __x, long double __y) noexcept (true); extern long double __fdiml (long double __x, long double __y) noexcept (true);



extern long double fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) noexcept (true); extern long double __fmal (long double __x, long double __y, long double __z) noexcept (true);




extern long double roundevenl (long double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizel (long double *__cx, const long double *__x) noexcept (true);






extern long double fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) noexcept (true); extern long double __getpayloadl (const long double *__x) noexcept (true);


extern int setpayloadl (long double *__x, long double __payload) noexcept (true);


extern int setpayloadsigl (long double *__x, long double __payload) noexcept (true);







extern long double scalbl (long double __x, long double __n) noexcept (true); extern long double __scalbl (long double __x, long double __n) noexcept (true);
# 369 "/usr/include/math.h" 2 3 4
# 419 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float32 acosf32 (_Float32 __x) noexcept (true); extern _Float32 __acosf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinf32 (_Float32 __x) noexcept (true); extern _Float32 __asinf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanf32 (_Float32 __x) noexcept (true); extern _Float32 __atanf32 (_Float32 __x) noexcept (true);

 extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) noexcept (true); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) noexcept (true);


 extern _Float32 cosf32 (_Float32 __x) noexcept (true); extern _Float32 __cosf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinf32 (_Float32 __x) noexcept (true); extern _Float32 __sinf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanf32 (_Float32 __x) noexcept (true); extern _Float32 __tanf32 (_Float32 __x) noexcept (true);



extern _Float32 acospif32 (_Float32 __x) noexcept (true); extern _Float32 __acospif32 (_Float32 __x) noexcept (true);

extern _Float32 asinpif32 (_Float32 __x) noexcept (true); extern _Float32 __asinpif32 (_Float32 __x) noexcept (true);

extern _Float32 atanpif32 (_Float32 __x) noexcept (true); extern _Float32 __atanpif32 (_Float32 __x) noexcept (true);

extern _Float32 atan2pif32 (_Float32 __y, _Float32 __x) noexcept (true); extern _Float32 __atan2pif32 (_Float32 __y, _Float32 __x) noexcept (true);


 extern _Float32 cospif32 (_Float32 __x) noexcept (true); extern _Float32 __cospif32 (_Float32 __x) noexcept (true);

 extern _Float32 sinpif32 (_Float32 __x) noexcept (true); extern _Float32 __sinpif32 (_Float32 __x) noexcept (true);

 extern _Float32 tanpif32 (_Float32 __x) noexcept (true); extern _Float32 __tanpif32 (_Float32 __x) noexcept (true);





 extern _Float32 coshf32 (_Float32 __x) noexcept (true); extern _Float32 __coshf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinhf32 (_Float32 __x) noexcept (true); extern _Float32 __sinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanhf32 (_Float32 __x) noexcept (true); extern _Float32 __tanhf32 (_Float32 __x) noexcept (true);



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true)
                                                        ;




 extern _Float32 acoshf32 (_Float32 __x) noexcept (true); extern _Float32 __acoshf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinhf32 (_Float32 __x) noexcept (true); extern _Float32 __asinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanhf32 (_Float32 __x) noexcept (true); extern _Float32 __atanhf32 (_Float32 __x) noexcept (true);





 extern _Float32 expf32 (_Float32 __x) noexcept (true); extern _Float32 __expf32 (_Float32 __x) noexcept (true);


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) noexcept (true); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) noexcept (true);


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) noexcept (true); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) noexcept (true);


 extern _Float32 logf32 (_Float32 __x) noexcept (true); extern _Float32 __logf32 (_Float32 __x) noexcept (true);


 extern _Float32 log10f32 (_Float32 __x) noexcept (true); extern _Float32 __log10f32 (_Float32 __x) noexcept (true);


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32 exp10f32 (_Float32 __x) noexcept (true); extern _Float32 __exp10f32 (_Float32 __x) noexcept (true);


extern _Float32 exp2m1f32 (_Float32 __x) noexcept (true); extern _Float32 __exp2m1f32 (_Float32 __x) noexcept (true);


extern _Float32 exp10m1f32 (_Float32 __x) noexcept (true); extern _Float32 __exp10m1f32 (_Float32 __x) noexcept (true);


extern _Float32 log2p1f32 (_Float32 __x) noexcept (true); extern _Float32 __log2p1f32 (_Float32 __x) noexcept (true);


extern _Float32 log10p1f32 (_Float32 __x) noexcept (true); extern _Float32 __log10p1f32 (_Float32 __x) noexcept (true);


 extern _Float32 logp1f32 (_Float32 __x) noexcept (true); extern _Float32 __logp1f32 (_Float32 __x) noexcept (true);




 extern _Float32 expm1f32 (_Float32 __x) noexcept (true); extern _Float32 __expm1f32 (_Float32 __x) noexcept (true);


 extern _Float32 log1pf32 (_Float32 __x) noexcept (true); extern _Float32 __log1pf32 (_Float32 __x) noexcept (true);


extern _Float32 logbf32 (_Float32 __x) noexcept (true); extern _Float32 __logbf32 (_Float32 __x) noexcept (true);




 extern _Float32 exp2f32 (_Float32 __x) noexcept (true); extern _Float32 __exp2f32 (_Float32 __x) noexcept (true);


 extern _Float32 log2f32 (_Float32 __x) noexcept (true); extern _Float32 __log2f32 (_Float32 __x) noexcept (true);






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) noexcept (true);


extern _Float32 sqrtf32 (_Float32 __x) noexcept (true); extern _Float32 __sqrtf32 (_Float32 __x) noexcept (true);



 extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) noexcept (true);




 extern _Float32 cbrtf32 (_Float32 __x) noexcept (true); extern _Float32 __cbrtf32 (_Float32 __x) noexcept (true);






extern _Float32 ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) noexcept (true);
# 231 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) noexcept (true); extern _Float32 __nanf32 (const char *__tagb) noexcept (true);
# 253 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) noexcept (true); extern _Float32 __j0f32 (_Float32) noexcept (true);
extern _Float32 j1f32 (_Float32) noexcept (true); extern _Float32 __j1f32 (_Float32) noexcept (true);
extern _Float32 jnf32 (int, _Float32) noexcept (true); extern _Float32 __jnf32 (int, _Float32) noexcept (true);
extern _Float32 y0f32 (_Float32) noexcept (true); extern _Float32 __y0f32 (_Float32) noexcept (true);
extern _Float32 y1f32 (_Float32) noexcept (true); extern _Float32 __y1f32 (_Float32) noexcept (true);
extern _Float32 ynf32 (int, _Float32) noexcept (true); extern _Float32 __ynf32 (int, _Float32) noexcept (true);





 extern _Float32 erff32 (_Float32) noexcept (true); extern _Float32 __erff32 (_Float32) noexcept (true);
 extern _Float32 erfcf32 (_Float32) noexcept (true); extern _Float32 __erfcf32 (_Float32) noexcept (true);
extern _Float32 lgammaf32 (_Float32) noexcept (true); extern _Float32 __lgammaf32 (_Float32) noexcept (true);




extern _Float32 tgammaf32 (_Float32) noexcept (true); extern _Float32 __tgammaf32 (_Float32) noexcept (true);
# 285 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) noexcept (true); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) noexcept (true);






extern _Float32 rintf32 (_Float32 __x) noexcept (true); extern _Float32 __rintf32 (_Float32 __x) noexcept (true);


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true);






extern _Float32 nextdownf32 (_Float32 __x) noexcept (true); extern _Float32 __nextdownf32 (_Float32 __x) noexcept (true);

extern _Float32 nextupf32 (_Float32 __x) noexcept (true); extern _Float32 __nextupf32 (_Float32 __x) noexcept (true);



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 scalbnf32 (_Float32 __x, int __n) noexcept (true); extern _Float32 __scalbnf32 (_Float32 __x, int __n) noexcept (true);



extern int ilogbf32 (_Float32 __x) noexcept (true); extern int __ilogbf32 (_Float32 __x) noexcept (true);




extern long int llogbf32 (_Float32 __x) noexcept (true); extern long int __llogbf32 (_Float32 __x) noexcept (true);




extern _Float32 scalblnf32 (_Float32 __x, long int __n) noexcept (true); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) noexcept (true);



extern _Float32 nearbyintf32 (_Float32 __x) noexcept (true); extern _Float32 __nearbyintf32 (_Float32 __x) noexcept (true);



extern _Float32 roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true);






extern long int lrintf32 (_Float32 __x) noexcept (true); extern long int __lrintf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llrintf32 (_Float32 __x) noexcept (true); extern long long int __llrintf32 (_Float32 __x) noexcept (true);



extern long int lroundf32 (_Float32 __x) noexcept (true); extern long int __lroundf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llroundf32 (_Float32 __x) noexcept (true); extern long long int __llroundf32 (_Float32 __x) noexcept (true);



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));



extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true);




extern _Float32 roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) noexcept (true);






extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) noexcept (true); extern _Float32 __getpayloadf32 (const _Float32 *__x) noexcept (true);


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) noexcept (true);


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) noexcept (true);
# 420 "/usr/include/math.h" 2 3 4
# 436 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float64 acosf64 (_Float64 __x) noexcept (true); extern _Float64 __acosf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinf64 (_Float64 __x) noexcept (true); extern _Float64 __asinf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanf64 (_Float64 __x) noexcept (true); extern _Float64 __atanf64 (_Float64 __x) noexcept (true);

 extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) noexcept (true); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) noexcept (true);


 extern _Float64 cosf64 (_Float64 __x) noexcept (true); extern _Float64 __cosf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinf64 (_Float64 __x) noexcept (true); extern _Float64 __sinf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanf64 (_Float64 __x) noexcept (true); extern _Float64 __tanf64 (_Float64 __x) noexcept (true);



extern _Float64 acospif64 (_Float64 __x) noexcept (true); extern _Float64 __acospif64 (_Float64 __x) noexcept (true);

extern _Float64 asinpif64 (_Float64 __x) noexcept (true); extern _Float64 __asinpif64 (_Float64 __x) noexcept (true);

extern _Float64 atanpif64 (_Float64 __x) noexcept (true); extern _Float64 __atanpif64 (_Float64 __x) noexcept (true);

extern _Float64 atan2pif64 (_Float64 __y, _Float64 __x) noexcept (true); extern _Float64 __atan2pif64 (_Float64 __y, _Float64 __x) noexcept (true);


 extern _Float64 cospif64 (_Float64 __x) noexcept (true); extern _Float64 __cospif64 (_Float64 __x) noexcept (true);

 extern _Float64 sinpif64 (_Float64 __x) noexcept (true); extern _Float64 __sinpif64 (_Float64 __x) noexcept (true);

 extern _Float64 tanpif64 (_Float64 __x) noexcept (true); extern _Float64 __tanpif64 (_Float64 __x) noexcept (true);





 extern _Float64 coshf64 (_Float64 __x) noexcept (true); extern _Float64 __coshf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinhf64 (_Float64 __x) noexcept (true); extern _Float64 __sinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanhf64 (_Float64 __x) noexcept (true); extern _Float64 __tanhf64 (_Float64 __x) noexcept (true);



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true)
                                                        ;




 extern _Float64 acoshf64 (_Float64 __x) noexcept (true); extern _Float64 __acoshf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinhf64 (_Float64 __x) noexcept (true); extern _Float64 __asinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanhf64 (_Float64 __x) noexcept (true); extern _Float64 __atanhf64 (_Float64 __x) noexcept (true);





 extern _Float64 expf64 (_Float64 __x) noexcept (true); extern _Float64 __expf64 (_Float64 __x) noexcept (true);


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) noexcept (true); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) noexcept (true);


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) noexcept (true); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) noexcept (true);


 extern _Float64 logf64 (_Float64 __x) noexcept (true); extern _Float64 __logf64 (_Float64 __x) noexcept (true);


 extern _Float64 log10f64 (_Float64 __x) noexcept (true); extern _Float64 __log10f64 (_Float64 __x) noexcept (true);


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64 exp10f64 (_Float64 __x) noexcept (true); extern _Float64 __exp10f64 (_Float64 __x) noexcept (true);


extern _Float64 exp2m1f64 (_Float64 __x) noexcept (true); extern _Float64 __exp2m1f64 (_Float64 __x) noexcept (true);


extern _Float64 exp10m1f64 (_Float64 __x) noexcept (true); extern _Float64 __exp10m1f64 (_Float64 __x) noexcept (true);


extern _Float64 log2p1f64 (_Float64 __x) noexcept (true); extern _Float64 __log2p1f64 (_Float64 __x) noexcept (true);


extern _Float64 log10p1f64 (_Float64 __x) noexcept (true); extern _Float64 __log10p1f64 (_Float64 __x) noexcept (true);


 extern _Float64 logp1f64 (_Float64 __x) noexcept (true); extern _Float64 __logp1f64 (_Float64 __x) noexcept (true);




 extern _Float64 expm1f64 (_Float64 __x) noexcept (true); extern _Float64 __expm1f64 (_Float64 __x) noexcept (true);


 extern _Float64 log1pf64 (_Float64 __x) noexcept (true); extern _Float64 __log1pf64 (_Float64 __x) noexcept (true);


extern _Float64 logbf64 (_Float64 __x) noexcept (true); extern _Float64 __logbf64 (_Float64 __x) noexcept (true);




 extern _Float64 exp2f64 (_Float64 __x) noexcept (true); extern _Float64 __exp2f64 (_Float64 __x) noexcept (true);


 extern _Float64 log2f64 (_Float64 __x) noexcept (true); extern _Float64 __log2f64 (_Float64 __x) noexcept (true);






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float64 sqrtf64 (_Float64 __x) noexcept (true); extern _Float64 __sqrtf64 (_Float64 __x) noexcept (true);



 extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) noexcept (true);




 extern _Float64 cbrtf64 (_Float64 __x) noexcept (true); extern _Float64 __cbrtf64 (_Float64 __x) noexcept (true);






extern _Float64 ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 231 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) noexcept (true); extern _Float64 __nanf64 (const char *__tagb) noexcept (true);
# 253 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) noexcept (true); extern _Float64 __j0f64 (_Float64) noexcept (true);
extern _Float64 j1f64 (_Float64) noexcept (true); extern _Float64 __j1f64 (_Float64) noexcept (true);
extern _Float64 jnf64 (int, _Float64) noexcept (true); extern _Float64 __jnf64 (int, _Float64) noexcept (true);
extern _Float64 y0f64 (_Float64) noexcept (true); extern _Float64 __y0f64 (_Float64) noexcept (true);
extern _Float64 y1f64 (_Float64) noexcept (true); extern _Float64 __y1f64 (_Float64) noexcept (true);
extern _Float64 ynf64 (int, _Float64) noexcept (true); extern _Float64 __ynf64 (int, _Float64) noexcept (true);





 extern _Float64 erff64 (_Float64) noexcept (true); extern _Float64 __erff64 (_Float64) noexcept (true);
 extern _Float64 erfcf64 (_Float64) noexcept (true); extern _Float64 __erfcf64 (_Float64) noexcept (true);
extern _Float64 lgammaf64 (_Float64) noexcept (true); extern _Float64 __lgammaf64 (_Float64) noexcept (true);




extern _Float64 tgammaf64 (_Float64) noexcept (true); extern _Float64 __tgammaf64 (_Float64) noexcept (true);
# 285 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) noexcept (true); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) noexcept (true);






extern _Float64 rintf64 (_Float64 __x) noexcept (true); extern _Float64 __rintf64 (_Float64 __x) noexcept (true);


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true);






extern _Float64 nextdownf64 (_Float64 __x) noexcept (true); extern _Float64 __nextdownf64 (_Float64 __x) noexcept (true);

extern _Float64 nextupf64 (_Float64 __x) noexcept (true); extern _Float64 __nextupf64 (_Float64 __x) noexcept (true);



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 scalbnf64 (_Float64 __x, int __n) noexcept (true); extern _Float64 __scalbnf64 (_Float64 __x, int __n) noexcept (true);



extern int ilogbf64 (_Float64 __x) noexcept (true); extern int __ilogbf64 (_Float64 __x) noexcept (true);




extern long int llogbf64 (_Float64 __x) noexcept (true); extern long int __llogbf64 (_Float64 __x) noexcept (true);




extern _Float64 scalblnf64 (_Float64 __x, long int __n) noexcept (true); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) noexcept (true);



extern _Float64 nearbyintf64 (_Float64 __x) noexcept (true); extern _Float64 __nearbyintf64 (_Float64 __x) noexcept (true);



extern _Float64 roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true);






extern long int lrintf64 (_Float64 __x) noexcept (true); extern long int __lrintf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llrintf64 (_Float64 __x) noexcept (true); extern long long int __llrintf64 (_Float64 __x) noexcept (true);



extern long int lroundf64 (_Float64 __x) noexcept (true); extern long int __lroundf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llroundf64 (_Float64 __x) noexcept (true); extern long long int __llroundf64 (_Float64 __x) noexcept (true);



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));



extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);




extern _Float64 roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) noexcept (true);






extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) noexcept (true); extern _Float64 __getpayloadf64 (const _Float64 *__x) noexcept (true);


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) noexcept (true);


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) noexcept (true);
# 437 "/usr/include/math.h" 2 3 4
# 450 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern int __issignalingf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));
# 451 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float128 acosf128 (_Float128 __x) noexcept (true); extern _Float128 __acosf128 (_Float128 __x) noexcept (true);

 extern _Float128 asinf128 (_Float128 __x) noexcept (true); extern _Float128 __asinf128 (_Float128 __x) noexcept (true);

 extern _Float128 atanf128 (_Float128 __x) noexcept (true); extern _Float128 __atanf128 (_Float128 __x) noexcept (true);

 extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) noexcept (true); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) noexcept (true);


 extern _Float128 cosf128 (_Float128 __x) noexcept (true); extern _Float128 __cosf128 (_Float128 __x) noexcept (true);

 extern _Float128 sinf128 (_Float128 __x) noexcept (true); extern _Float128 __sinf128 (_Float128 __x) noexcept (true);

 extern _Float128 tanf128 (_Float128 __x) noexcept (true); extern _Float128 __tanf128 (_Float128 __x) noexcept (true);



extern _Float128 acospif128 (_Float128 __x) noexcept (true); extern _Float128 __acospif128 (_Float128 __x) noexcept (true);

extern _Float128 asinpif128 (_Float128 __x) noexcept (true); extern _Float128 __asinpif128 (_Float128 __x) noexcept (true);

extern _Float128 atanpif128 (_Float128 __x) noexcept (true); extern _Float128 __atanpif128 (_Float128 __x) noexcept (true);

extern _Float128 atan2pif128 (_Float128 __y, _Float128 __x) noexcept (true); extern _Float128 __atan2pif128 (_Float128 __y, _Float128 __x) noexcept (true);


 extern _Float128 cospif128 (_Float128 __x) noexcept (true); extern _Float128 __cospif128 (_Float128 __x) noexcept (true);

 extern _Float128 sinpif128 (_Float128 __x) noexcept (true); extern _Float128 __sinpif128 (_Float128 __x) noexcept (true);

 extern _Float128 tanpif128 (_Float128 __x) noexcept (true); extern _Float128 __tanpif128 (_Float128 __x) noexcept (true);





 extern _Float128 coshf128 (_Float128 __x) noexcept (true); extern _Float128 __coshf128 (_Float128 __x) noexcept (true);

 extern _Float128 sinhf128 (_Float128 __x) noexcept (true); extern _Float128 __sinhf128 (_Float128 __x) noexcept (true);

 extern _Float128 tanhf128 (_Float128 __x) noexcept (true); extern _Float128 __tanhf128 (_Float128 __x) noexcept (true);



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) noexcept (true); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) noexcept (true)
                                                        ;




 extern _Float128 acoshf128 (_Float128 __x) noexcept (true); extern _Float128 __acoshf128 (_Float128 __x) noexcept (true);

 extern _Float128 asinhf128 (_Float128 __x) noexcept (true); extern _Float128 __asinhf128 (_Float128 __x) noexcept (true);

 extern _Float128 atanhf128 (_Float128 __x) noexcept (true); extern _Float128 __atanhf128 (_Float128 __x) noexcept (true);





 extern _Float128 expf128 (_Float128 __x) noexcept (true); extern _Float128 __expf128 (_Float128 __x) noexcept (true);


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) noexcept (true); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) noexcept (true);


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) noexcept (true); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) noexcept (true);


 extern _Float128 logf128 (_Float128 __x) noexcept (true); extern _Float128 __logf128 (_Float128 __x) noexcept (true);


 extern _Float128 log10f128 (_Float128 __x) noexcept (true); extern _Float128 __log10f128 (_Float128 __x) noexcept (true);


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) noexcept (true); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float128 exp10f128 (_Float128 __x) noexcept (true); extern _Float128 __exp10f128 (_Float128 __x) noexcept (true);


extern _Float128 exp2m1f128 (_Float128 __x) noexcept (true); extern _Float128 __exp2m1f128 (_Float128 __x) noexcept (true);


extern _Float128 exp10m1f128 (_Float128 __x) noexcept (true); extern _Float128 __exp10m1f128 (_Float128 __x) noexcept (true);


extern _Float128 log2p1f128 (_Float128 __x) noexcept (true); extern _Float128 __log2p1f128 (_Float128 __x) noexcept (true);


extern _Float128 log10p1f128 (_Float128 __x) noexcept (true); extern _Float128 __log10p1f128 (_Float128 __x) noexcept (true);


 extern _Float128 logp1f128 (_Float128 __x) noexcept (true); extern _Float128 __logp1f128 (_Float128 __x) noexcept (true);




 extern _Float128 expm1f128 (_Float128 __x) noexcept (true); extern _Float128 __expm1f128 (_Float128 __x) noexcept (true);


 extern _Float128 log1pf128 (_Float128 __x) noexcept (true); extern _Float128 __log1pf128 (_Float128 __x) noexcept (true);


extern _Float128 logbf128 (_Float128 __x) noexcept (true); extern _Float128 __logbf128 (_Float128 __x) noexcept (true);




 extern _Float128 exp2f128 (_Float128 __x) noexcept (true); extern _Float128 __exp2f128 (_Float128 __x) noexcept (true);


 extern _Float128 log2f128 (_Float128 __x) noexcept (true); extern _Float128 __log2f128 (_Float128 __x) noexcept (true);






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float128 sqrtf128 (_Float128 __x) noexcept (true); extern _Float128 __sqrtf128 (_Float128 __x) noexcept (true);



 extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) noexcept (true);




 extern _Float128 cbrtf128 (_Float128 __x) noexcept (true); extern _Float128 __cbrtf128 (_Float128 __x) noexcept (true);






extern _Float128 ceilf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 231 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) noexcept (true); extern _Float128 __nanf128 (const char *__tagb) noexcept (true);
# 253 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) noexcept (true); extern _Float128 __j0f128 (_Float128) noexcept (true);
extern _Float128 j1f128 (_Float128) noexcept (true); extern _Float128 __j1f128 (_Float128) noexcept (true);
extern _Float128 jnf128 (int, _Float128) noexcept (true); extern _Float128 __jnf128 (int, _Float128) noexcept (true);
extern _Float128 y0f128 (_Float128) noexcept (true); extern _Float128 __y0f128 (_Float128) noexcept (true);
extern _Float128 y1f128 (_Float128) noexcept (true); extern _Float128 __y1f128 (_Float128) noexcept (true);
extern _Float128 ynf128 (int, _Float128) noexcept (true); extern _Float128 __ynf128 (int, _Float128) noexcept (true);





 extern _Float128 erff128 (_Float128) noexcept (true); extern _Float128 __erff128 (_Float128) noexcept (true);
 extern _Float128 erfcf128 (_Float128) noexcept (true); extern _Float128 __erfcf128 (_Float128) noexcept (true);
extern _Float128 lgammaf128 (_Float128) noexcept (true); extern _Float128 __lgammaf128 (_Float128) noexcept (true);




extern _Float128 tgammaf128 (_Float128) noexcept (true); extern _Float128 __tgammaf128 (_Float128) noexcept (true);
# 285 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) noexcept (true); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) noexcept (true);






extern _Float128 rintf128 (_Float128 __x) noexcept (true); extern _Float128 __rintf128 (_Float128 __x) noexcept (true);


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) noexcept (true);






extern _Float128 nextdownf128 (_Float128 __x) noexcept (true); extern _Float128 __nextdownf128 (_Float128 __x) noexcept (true);

extern _Float128 nextupf128 (_Float128 __x) noexcept (true); extern _Float128 __nextupf128 (_Float128 __x) noexcept (true);



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) noexcept (true);



extern _Float128 scalbnf128 (_Float128 __x, int __n) noexcept (true); extern _Float128 __scalbnf128 (_Float128 __x, int __n) noexcept (true);



extern int ilogbf128 (_Float128 __x) noexcept (true); extern int __ilogbf128 (_Float128 __x) noexcept (true);




extern long int llogbf128 (_Float128 __x) noexcept (true); extern long int __llogbf128 (_Float128 __x) noexcept (true);




extern _Float128 scalblnf128 (_Float128 __x, long int __n) noexcept (true); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) noexcept (true);



extern _Float128 nearbyintf128 (_Float128 __x) noexcept (true); extern _Float128 __nearbyintf128 (_Float128 __x) noexcept (true);



extern _Float128 roundf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) noexcept (true); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) noexcept (true);






extern long int lrintf128 (_Float128 __x) noexcept (true); extern long int __lrintf128 (_Float128 __x) noexcept (true);
__extension__
extern long long int llrintf128 (_Float128 __x) noexcept (true); extern long long int __llrintf128 (_Float128 __x) noexcept (true);



extern long int lroundf128 (_Float128 __x) noexcept (true); extern long int __lroundf128 (_Float128 __x) noexcept (true);
__extension__
extern long long int llroundf128 (_Float128 __x) noexcept (true); extern long long int __llroundf128 (_Float128 __x) noexcept (true);



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) noexcept (true);



extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));



extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);




extern _Float128 roundevenf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) noexcept (true);






extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern _Float128 fmaximumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf128 (const _Float128 *__x, const _Float128 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf128 (const _Float128 *__x, const _Float128 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float128 getpayloadf128 (const _Float128 *__x) noexcept (true); extern _Float128 __getpayloadf128 (const _Float128 *__x) noexcept (true);


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) noexcept (true);


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) noexcept (true);
# 454 "/usr/include/math.h" 2 3 4
# 470 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float32x acosf32x (_Float32x __x) noexcept (true); extern _Float32x __acosf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinf32x (_Float32x __x) noexcept (true); extern _Float32x __asinf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanf32x (_Float32x __x) noexcept (true); extern _Float32x __atanf32x (_Float32x __x) noexcept (true);

 extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) noexcept (true); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) noexcept (true);


 extern _Float32x cosf32x (_Float32x __x) noexcept (true); extern _Float32x __cosf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinf32x (_Float32x __x) noexcept (true); extern _Float32x __sinf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanf32x (_Float32x __x) noexcept (true); extern _Float32x __tanf32x (_Float32x __x) noexcept (true);



extern _Float32x acospif32x (_Float32x __x) noexcept (true); extern _Float32x __acospif32x (_Float32x __x) noexcept (true);

extern _Float32x asinpif32x (_Float32x __x) noexcept (true); extern _Float32x __asinpif32x (_Float32x __x) noexcept (true);

extern _Float32x atanpif32x (_Float32x __x) noexcept (true); extern _Float32x __atanpif32x (_Float32x __x) noexcept (true);

extern _Float32x atan2pif32x (_Float32x __y, _Float32x __x) noexcept (true); extern _Float32x __atan2pif32x (_Float32x __y, _Float32x __x) noexcept (true);


 extern _Float32x cospif32x (_Float32x __x) noexcept (true); extern _Float32x __cospif32x (_Float32x __x) noexcept (true);

 extern _Float32x sinpif32x (_Float32x __x) noexcept (true); extern _Float32x __sinpif32x (_Float32x __x) noexcept (true);

 extern _Float32x tanpif32x (_Float32x __x) noexcept (true); extern _Float32x __tanpif32x (_Float32x __x) noexcept (true);





 extern _Float32x coshf32x (_Float32x __x) noexcept (true); extern _Float32x __coshf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinhf32x (_Float32x __x) noexcept (true); extern _Float32x __sinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanhf32x (_Float32x __x) noexcept (true); extern _Float32x __tanhf32x (_Float32x __x) noexcept (true);



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true)
                                                        ;




 extern _Float32x acoshf32x (_Float32x __x) noexcept (true); extern _Float32x __acoshf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinhf32x (_Float32x __x) noexcept (true); extern _Float32x __asinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanhf32x (_Float32x __x) noexcept (true); extern _Float32x __atanhf32x (_Float32x __x) noexcept (true);





 extern _Float32x expf32x (_Float32x __x) noexcept (true); extern _Float32x __expf32x (_Float32x __x) noexcept (true);


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) noexcept (true); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) noexcept (true);


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) noexcept (true); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) noexcept (true);


 extern _Float32x logf32x (_Float32x __x) noexcept (true); extern _Float32x __logf32x (_Float32x __x) noexcept (true);


 extern _Float32x log10f32x (_Float32x __x) noexcept (true); extern _Float32x __log10f32x (_Float32x __x) noexcept (true);


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32x exp10f32x (_Float32x __x) noexcept (true); extern _Float32x __exp10f32x (_Float32x __x) noexcept (true);


extern _Float32x exp2m1f32x (_Float32x __x) noexcept (true); extern _Float32x __exp2m1f32x (_Float32x __x) noexcept (true);


extern _Float32x exp10m1f32x (_Float32x __x) noexcept (true); extern _Float32x __exp10m1f32x (_Float32x __x) noexcept (true);


extern _Float32x log2p1f32x (_Float32x __x) noexcept (true); extern _Float32x __log2p1f32x (_Float32x __x) noexcept (true);


extern _Float32x log10p1f32x (_Float32x __x) noexcept (true); extern _Float32x __log10p1f32x (_Float32x __x) noexcept (true);


 extern _Float32x logp1f32x (_Float32x __x) noexcept (true); extern _Float32x __logp1f32x (_Float32x __x) noexcept (true);




 extern _Float32x expm1f32x (_Float32x __x) noexcept (true); extern _Float32x __expm1f32x (_Float32x __x) noexcept (true);


 extern _Float32x log1pf32x (_Float32x __x) noexcept (true); extern _Float32x __log1pf32x (_Float32x __x) noexcept (true);


extern _Float32x logbf32x (_Float32x __x) noexcept (true); extern _Float32x __logbf32x (_Float32x __x) noexcept (true);




 extern _Float32x exp2f32x (_Float32x __x) noexcept (true); extern _Float32x __exp2f32x (_Float32x __x) noexcept (true);


 extern _Float32x log2f32x (_Float32x __x) noexcept (true); extern _Float32x __log2f32x (_Float32x __x) noexcept (true);






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32x sqrtf32x (_Float32x __x) noexcept (true); extern _Float32x __sqrtf32x (_Float32x __x) noexcept (true);



 extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) noexcept (true);




 extern _Float32x cbrtf32x (_Float32x __x) noexcept (true); extern _Float32x __cbrtf32x (_Float32x __x) noexcept (true);






extern _Float32x ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 231 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) noexcept (true); extern _Float32x __nanf32x (const char *__tagb) noexcept (true);
# 253 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) noexcept (true); extern _Float32x __j0f32x (_Float32x) noexcept (true);
extern _Float32x j1f32x (_Float32x) noexcept (true); extern _Float32x __j1f32x (_Float32x) noexcept (true);
extern _Float32x jnf32x (int, _Float32x) noexcept (true); extern _Float32x __jnf32x (int, _Float32x) noexcept (true);
extern _Float32x y0f32x (_Float32x) noexcept (true); extern _Float32x __y0f32x (_Float32x) noexcept (true);
extern _Float32x y1f32x (_Float32x) noexcept (true); extern _Float32x __y1f32x (_Float32x) noexcept (true);
extern _Float32x ynf32x (int, _Float32x) noexcept (true); extern _Float32x __ynf32x (int, _Float32x) noexcept (true);





 extern _Float32x erff32x (_Float32x) noexcept (true); extern _Float32x __erff32x (_Float32x) noexcept (true);
 extern _Float32x erfcf32x (_Float32x) noexcept (true); extern _Float32x __erfcf32x (_Float32x) noexcept (true);
extern _Float32x lgammaf32x (_Float32x) noexcept (true); extern _Float32x __lgammaf32x (_Float32x) noexcept (true);




extern _Float32x tgammaf32x (_Float32x) noexcept (true); extern _Float32x __tgammaf32x (_Float32x) noexcept (true);
# 285 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true);






extern _Float32x rintf32x (_Float32x __x) noexcept (true); extern _Float32x __rintf32x (_Float32x __x) noexcept (true);


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true);






extern _Float32x nextdownf32x (_Float32x __x) noexcept (true); extern _Float32x __nextdownf32x (_Float32x __x) noexcept (true);

extern _Float32x nextupf32x (_Float32x __x) noexcept (true); extern _Float32x __nextupf32x (_Float32x __x) noexcept (true);



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x scalbnf32x (_Float32x __x, int __n) noexcept (true); extern _Float32x __scalbnf32x (_Float32x __x, int __n) noexcept (true);



extern int ilogbf32x (_Float32x __x) noexcept (true); extern int __ilogbf32x (_Float32x __x) noexcept (true);




extern long int llogbf32x (_Float32x __x) noexcept (true); extern long int __llogbf32x (_Float32x __x) noexcept (true);




extern _Float32x scalblnf32x (_Float32x __x, long int __n) noexcept (true); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) noexcept (true);



extern _Float32x nearbyintf32x (_Float32x __x) noexcept (true); extern _Float32x __nearbyintf32x (_Float32x __x) noexcept (true);



extern _Float32x roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true);






extern long int lrintf32x (_Float32x __x) noexcept (true); extern long int __lrintf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llrintf32x (_Float32x __x) noexcept (true); extern long long int __llrintf32x (_Float32x __x) noexcept (true);



extern long int lroundf32x (_Float32x __x) noexcept (true); extern long int __lroundf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llroundf32x (_Float32x __x) noexcept (true); extern long long int __llroundf32x (_Float32x __x) noexcept (true);



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));



extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);




extern _Float32x roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) noexcept (true);






extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) noexcept (true); extern _Float32x __getpayloadf32x (const _Float32x *__x) noexcept (true);


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) noexcept (true);


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) noexcept (true);
# 471 "/usr/include/math.h" 2 3 4
# 487 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float64x acosf64x (_Float64x __x) noexcept (true); extern _Float64x __acosf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinf64x (_Float64x __x) noexcept (true); extern _Float64x __asinf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanf64x (_Float64x __x) noexcept (true); extern _Float64x __atanf64x (_Float64x __x) noexcept (true);

 extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) noexcept (true); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) noexcept (true);


 extern _Float64x cosf64x (_Float64x __x) noexcept (true); extern _Float64x __cosf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinf64x (_Float64x __x) noexcept (true); extern _Float64x __sinf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanf64x (_Float64x __x) noexcept (true); extern _Float64x __tanf64x (_Float64x __x) noexcept (true);



extern _Float64x acospif64x (_Float64x __x) noexcept (true); extern _Float64x __acospif64x (_Float64x __x) noexcept (true);

extern _Float64x asinpif64x (_Float64x __x) noexcept (true); extern _Float64x __asinpif64x (_Float64x __x) noexcept (true);

extern _Float64x atanpif64x (_Float64x __x) noexcept (true); extern _Float64x __atanpif64x (_Float64x __x) noexcept (true);

extern _Float64x atan2pif64x (_Float64x __y, _Float64x __x) noexcept (true); extern _Float64x __atan2pif64x (_Float64x __y, _Float64x __x) noexcept (true);


 extern _Float64x cospif64x (_Float64x __x) noexcept (true); extern _Float64x __cospif64x (_Float64x __x) noexcept (true);

 extern _Float64x sinpif64x (_Float64x __x) noexcept (true); extern _Float64x __sinpif64x (_Float64x __x) noexcept (true);

 extern _Float64x tanpif64x (_Float64x __x) noexcept (true); extern _Float64x __tanpif64x (_Float64x __x) noexcept (true);





 extern _Float64x coshf64x (_Float64x __x) noexcept (true); extern _Float64x __coshf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinhf64x (_Float64x __x) noexcept (true); extern _Float64x __sinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanhf64x (_Float64x __x) noexcept (true); extern _Float64x __tanhf64x (_Float64x __x) noexcept (true);



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true)
                                                        ;




 extern _Float64x acoshf64x (_Float64x __x) noexcept (true); extern _Float64x __acoshf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinhf64x (_Float64x __x) noexcept (true); extern _Float64x __asinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanhf64x (_Float64x __x) noexcept (true); extern _Float64x __atanhf64x (_Float64x __x) noexcept (true);





 extern _Float64x expf64x (_Float64x __x) noexcept (true); extern _Float64x __expf64x (_Float64x __x) noexcept (true);


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) noexcept (true); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) noexcept (true);


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) noexcept (true); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) noexcept (true);


 extern _Float64x logf64x (_Float64x __x) noexcept (true); extern _Float64x __logf64x (_Float64x __x) noexcept (true);


 extern _Float64x log10f64x (_Float64x __x) noexcept (true); extern _Float64x __log10f64x (_Float64x __x) noexcept (true);


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64x exp10f64x (_Float64x __x) noexcept (true); extern _Float64x __exp10f64x (_Float64x __x) noexcept (true);


extern _Float64x exp2m1f64x (_Float64x __x) noexcept (true); extern _Float64x __exp2m1f64x (_Float64x __x) noexcept (true);


extern _Float64x exp10m1f64x (_Float64x __x) noexcept (true); extern _Float64x __exp10m1f64x (_Float64x __x) noexcept (true);


extern _Float64x log2p1f64x (_Float64x __x) noexcept (true); extern _Float64x __log2p1f64x (_Float64x __x) noexcept (true);


extern _Float64x log10p1f64x (_Float64x __x) noexcept (true); extern _Float64x __log10p1f64x (_Float64x __x) noexcept (true);


 extern _Float64x logp1f64x (_Float64x __x) noexcept (true); extern _Float64x __logp1f64x (_Float64x __x) noexcept (true);




 extern _Float64x expm1f64x (_Float64x __x) noexcept (true); extern _Float64x __expm1f64x (_Float64x __x) noexcept (true);


 extern _Float64x log1pf64x (_Float64x __x) noexcept (true); extern _Float64x __log1pf64x (_Float64x __x) noexcept (true);


extern _Float64x logbf64x (_Float64x __x) noexcept (true); extern _Float64x __logbf64x (_Float64x __x) noexcept (true);




 extern _Float64x exp2f64x (_Float64x __x) noexcept (true); extern _Float64x __exp2f64x (_Float64x __x) noexcept (true);


 extern _Float64x log2f64x (_Float64x __x) noexcept (true); extern _Float64x __log2f64x (_Float64x __x) noexcept (true);






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64x sqrtf64x (_Float64x __x) noexcept (true); extern _Float64x __sqrtf64x (_Float64x __x) noexcept (true);



 extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) noexcept (true);




 extern _Float64x cbrtf64x (_Float64x __x) noexcept (true); extern _Float64x __cbrtf64x (_Float64x __x) noexcept (true);






extern _Float64x ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 231 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) noexcept (true); extern _Float64x __nanf64x (const char *__tagb) noexcept (true);
# 253 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) noexcept (true); extern _Float64x __j0f64x (_Float64x) noexcept (true);
extern _Float64x j1f64x (_Float64x) noexcept (true); extern _Float64x __j1f64x (_Float64x) noexcept (true);
extern _Float64x jnf64x (int, _Float64x) noexcept (true); extern _Float64x __jnf64x (int, _Float64x) noexcept (true);
extern _Float64x y0f64x (_Float64x) noexcept (true); extern _Float64x __y0f64x (_Float64x) noexcept (true);
extern _Float64x y1f64x (_Float64x) noexcept (true); extern _Float64x __y1f64x (_Float64x) noexcept (true);
extern _Float64x ynf64x (int, _Float64x) noexcept (true); extern _Float64x __ynf64x (int, _Float64x) noexcept (true);





 extern _Float64x erff64x (_Float64x) noexcept (true); extern _Float64x __erff64x (_Float64x) noexcept (true);
 extern _Float64x erfcf64x (_Float64x) noexcept (true); extern _Float64x __erfcf64x (_Float64x) noexcept (true);
extern _Float64x lgammaf64x (_Float64x) noexcept (true); extern _Float64x __lgammaf64x (_Float64x) noexcept (true);




extern _Float64x tgammaf64x (_Float64x) noexcept (true); extern _Float64x __tgammaf64x (_Float64x) noexcept (true);
# 285 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true);






extern _Float64x rintf64x (_Float64x __x) noexcept (true); extern _Float64x __rintf64x (_Float64x __x) noexcept (true);


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true);






extern _Float64x nextdownf64x (_Float64x __x) noexcept (true); extern _Float64x __nextdownf64x (_Float64x __x) noexcept (true);

extern _Float64x nextupf64x (_Float64x __x) noexcept (true); extern _Float64x __nextupf64x (_Float64x __x) noexcept (true);



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x scalbnf64x (_Float64x __x, int __n) noexcept (true); extern _Float64x __scalbnf64x (_Float64x __x, int __n) noexcept (true);



extern int ilogbf64x (_Float64x __x) noexcept (true); extern int __ilogbf64x (_Float64x __x) noexcept (true);




extern long int llogbf64x (_Float64x __x) noexcept (true); extern long int __llogbf64x (_Float64x __x) noexcept (true);




extern _Float64x scalblnf64x (_Float64x __x, long int __n) noexcept (true); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) noexcept (true);



extern _Float64x nearbyintf64x (_Float64x __x) noexcept (true); extern _Float64x __nearbyintf64x (_Float64x __x) noexcept (true);



extern _Float64x roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true);






extern long int lrintf64x (_Float64x __x) noexcept (true); extern long int __lrintf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llrintf64x (_Float64x __x) noexcept (true); extern long long int __llrintf64x (_Float64x __x) noexcept (true);



extern long int lroundf64x (_Float64x __x) noexcept (true); extern long int __lroundf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llroundf64x (_Float64x __x) noexcept (true); extern long long int __llroundf64x (_Float64x __x) noexcept (true);



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));



extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);




extern _Float64x roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) noexcept (true);






extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) noexcept (true); extern _Float64x __getpayloadf64x (const _Float64x *__x) noexcept (true);


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) noexcept (true);


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) noexcept (true);
# 488 "/usr/include/math.h" 2 3 4
# 535 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) noexcept (true);


extern float fdiv (double __x, double __y) noexcept (true);


extern float ffma (double __x, double __y, double __z) noexcept (true);


extern float fmul (double __x, double __y) noexcept (true);


extern float fsqrt (double __x) noexcept (true);


extern float fsub (double __x, double __y) noexcept (true);
# 536 "/usr/include/math.h" 2 3 4
# 556 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) noexcept (true);


extern float fdivl (long double __x, long double __y) noexcept (true);


extern float ffmal (long double __x, long double __y, long double __z) noexcept (true);


extern float fmull (long double __x, long double __y) noexcept (true);


extern float fsqrtl (long double __x) noexcept (true);


extern float fsubl (long double __x, long double __y) noexcept (true);
# 557 "/usr/include/math.h" 2 3 4
# 585 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) noexcept (true);


extern double ddivl (long double __x, long double __y) noexcept (true);


extern double dfmal (long double __x, long double __y, long double __z) noexcept (true);


extern double dmull (long double __x, long double __y) noexcept (true);


extern double dsqrtl (long double __x) noexcept (true);


extern double dsubl (long double __x, long double __y) noexcept (true);
# 586 "/usr/include/math.h" 2 3 4
# 666 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32sqrtf32x (_Float32x __x) noexcept (true);


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 667 "/usr/include/math.h" 2 3 4
# 676 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32sqrtf64 (_Float64 __x) noexcept (true);


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 677 "/usr/include/math.h" 2 3 4
# 686 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32sqrtf64x (_Float64x __x) noexcept (true);


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 687 "/usr/include/math.h" 2 3 4
# 696 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32divf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float32 f32mulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32sqrtf128 (_Float128 __x) noexcept (true);


extern _Float32 f32subf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 697 "/usr/include/math.h" 2 3 4
# 716 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xfmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xsqrtf64 (_Float64 __x) noexcept (true);


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 717 "/usr/include/math.h" 2 3 4
# 726 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xfmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xsqrtf64x (_Float64x __x) noexcept (true);


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 727 "/usr/include/math.h" 2 3 4
# 736 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xdivf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float32x f32xmulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xsqrtf128 (_Float128 __x) noexcept (true);


extern _Float32x f32xsubf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 737 "/usr/include/math.h" 2 3 4
# 756 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64sqrtf64x (_Float64x __x) noexcept (true);


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 757 "/usr/include/math.h" 2 3 4
# 766 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64divf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float64 f64mulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64sqrtf128 (_Float128 __x) noexcept (true);


extern _Float64 f64subf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 767 "/usr/include/math.h" 2 3 4
# 786 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64x f64xaddf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xdivf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float64x f64xmulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xsqrtf128 (_Float128 __x) noexcept (true);


extern _Float64x f64xsubf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 787 "/usr/include/math.h" 2 3 4
# 823 "/usr/include/math.h" 3 4
extern int signgam;
# 903 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1024 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     noexcept (true) __attribute__ ((__const__));
# 46 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }

inline int iscanonical (_Float128 __val) { return ((void) (__typeof (__val)) (__val), 1); }

}
# 1025 "/usr/include/math.h" 2 3 4
# 1036 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}



inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }

}
# 1067 "/usr/include/math.h" 3 4
extern "C++" {
# 1098 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1333 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (long double __x, long double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};


template<> struct __iseqsig_type<_Float32>
{
  static int __call (_Float32 __x, _Float32 __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};



template<> struct __iseqsig_type<_Float64>
{
  static int __call (_Float64 __x, _Float64 __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};





template<> struct __iseqsig_type<_Float128>
{
  static int __call (_Float128 __x, _Float128 __y) throw ()
  {

    return __iseqsigf128 (__x, __y);



  }
};



template<> struct __iseqsig_type<_Float32x>
{
  static int __call (_Float32x __x, _Float32x __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};



template<> struct __iseqsig_type<_Float64x>
{
  static int __call (_Float64x __x, _Float64x __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};


template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 48 "/usr/include/c++/14/cmath" 2 3

# 1 "/usr/include/c++/14/bits/std_abs.h" 1 3
# 33 "/usr/include/c++/14/bits/std_abs.h" 3
       
# 34 "/usr/include/c++/14/bits/std_abs.h" 3




# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 59 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) noexcept (true) ;



extern double atof (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) noexcept (true) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));






extern long int strtol (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtol")


     __attribute__ ((__nonnull__ (1)));
extern unsigned long int strtoul (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoul")



     __attribute__ ((__nonnull__ (1)));

__extension__
extern long long int strtoq (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoll")


     __attribute__ ((__nonnull__ (1)));
__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoull")



     __attribute__ ((__nonnull__ (1)));

__extension__
extern long long int strtoll (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoll")


     __attribute__ ((__nonnull__ (1)));
__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoull")



     __attribute__ ((__nonnull__ (1)));
# 278 "/usr/include/stdlib.h" 3 4
extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 298 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 340 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));





extern long int strtol_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtol_l")



     __attribute__ ((__nonnull__ (1, 4)));
extern unsigned long int strtoul_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtoul_l")




     __attribute__ ((__nonnull__ (1, 4)));
__extension__
extern long long int strtoll_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtoll_l")




     __attribute__ ((__nonnull__ (1, 4)));
__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtoull_l")




     __attribute__ ((__nonnull__ (1, 4)));
# 415 "/usr/include/stdlib.h" 3 4
extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 436 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 505 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) noexcept (true) ;


extern long int a64l (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;







typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 102 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 153 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_size[2] ;
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
  unsigned int __unused_initialized_1;
  unsigned int __unused_initialized_2;
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


}
# 515 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) noexcept (true);


extern void srandom (unsigned int __seed) noexcept (true);





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) noexcept (true) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) noexcept (true);

extern void srand (unsigned int __seed) noexcept (true);



extern int rand_r (unsigned int *__seed) noexcept (true);







extern double drand48 (void) noexcept (true);
extern double erand48 (unsigned short int __xsubi[3]) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) noexcept (true);
extern long int nrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) noexcept (true);
extern long int jrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) noexcept (true);
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) noexcept (true) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern __uint32_t arc4random (void)
     noexcept (true) ;


extern void arc4random_buf (void *__buf, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern __uint32_t arc4random_uniform (__uint32_t __upper_bound)
     noexcept (true) ;




extern void *malloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));


extern void free (void *__ptr) noexcept (true);







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)))
    __attribute__ ((__malloc__ (__builtin_free, 1)));


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__ (reallocarray, 1)));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) noexcept (true);





}
# 707 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
     __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) noexcept (true) __attribute__ ((__noreturn__)) __attribute__ ((__cold__));



extern int atexit (void (*__func) (void)) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     noexcept (true) __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 749 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void _Exit (int __status) noexcept (true) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) noexcept (true);
# 814 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 827 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 837 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 849 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 859 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 870 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 881 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 891 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 901 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 913 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 923 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__malloc__))
     __attribute__ ((__malloc__ (__builtin_free, 1))) ;
# 940 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) noexcept (true) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) noexcept (true) __attribute__ ((__const__)) ;
extern long int labs (long int __x) noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     noexcept (true) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
# 1012 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) noexcept (true);


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) noexcept (true);


extern int wctomb (char *__s, wchar_t __wchar) noexcept (true);



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) noexcept (true)
    __attribute__ ((__access__ (__read_only__, 2)));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     noexcept (true)
  __attribute__ ((__access__ (__write_only__, 1, 3)))
  __attribute__ ((__access__ (__read_only__, 2)));






extern int rpmatch (const char *__response) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 1099 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) noexcept (true);



extern int unlockpt (int __fd) noexcept (true);




extern char *ptsname (int __fd) noexcept (true) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1155 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1156 "/usr/include/stdlib.h" 2 3 4
# 1167 "/usr/include/stdlib.h" 3 4
}
# 39 "/usr/include/c++/14/bits/std_abs.h" 2 3







extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 70 "/usr/include/c++/14/bits/std_abs.h" 3
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  __extension__ inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 135 "/usr/include/c++/14/bits/std_abs.h" 3
  __extension__ inline constexpr
  __float128
  abs(__float128 __x)
  {



    return __builtin_fabsf128(__x);




  }



}
}
# 50 "/usr/include/c++/14/cmath" 2 3






# 1 "/usr/include/c++/14/bits/version.h" 1 3
# 47 "/usr/include/c++/14/bits/version.h" 3
       
# 48 "/usr/include/c++/14/bits/version.h" 3
# 57 "/usr/include/c++/14/cmath" 2 3
# 83 "/usr/include/c++/14/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 400 "/usr/include/c++/14/cmath" 3
  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 1053 "/usr/include/c++/14/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }
# 1100 "/usr/include/c++/14/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1820 "/usr/include/c++/14/cmath" 3
  using ::acosf;


  using ::acosl;



  using ::asinf;


  using ::asinl;



  using ::atanf;


  using ::atanl;



  using ::atan2f;


  using ::atan2l;



  using ::ceilf;


  using ::ceill;



  using ::cosf;


  using ::cosl;



  using ::coshf;


  using ::coshl;



  using ::expf;


  using ::expl;



  using ::fabsf;


  using ::fabsl;



  using ::floorf;


  using ::floorl;



  using ::fmodf;


  using ::fmodl;



  using ::frexpf;


  using ::frexpl;



  using ::ldexpf;


  using ::ldexpl;



  using ::logf;


  using ::logl;



  using ::log10f;


  using ::log10l;



  using ::modff;


  using ::modfl;



  using ::powf;


  using ::powl;



  using ::sinf;


  using ::sinl;



  using ::sinhf;


  using ::sinhl;



  using ::sqrtf;


  using ::sqrtl;



  using ::tanf;


  using ::tanl;



  using ::tanhf;


  using ::tanhl;
# 2085 "/usr/include/c++/14/cmath" 3
  using ::double_t;
  using ::float_t;



  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 3682 "/usr/include/c++/14/cmath" 3
  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }

  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }







  template<typename _Tp>
    inline _Tp
    __hypot3(_Tp __x, _Tp __y, _Tp __z)
    {
      __x = std::abs(__x);
      __y = std::abs(__y);
      __z = std::abs(__z);
      if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
 return __a * std::sqrt((__x / __a) * (__x / __a)
          + (__y / __a) * (__y / __a)
          + (__z / __a) * (__z / __a));
      else
 return {};
    }

  inline float
  hypot(float __x, float __y, float __z)
  { return std::__hypot3<float>(__x, __y, __z); }

  inline double
  hypot(double __x, double __y, double __z)
  { return std::__hypot3<double>(__x, __y, __z); }

  inline long double
  hypot(long double __x, long double __y, long double __z)
  { return std::__hypot3<long double>(__x, __y, __z); }

  template<typename _Tp, typename _Up, typename _Vp>
    __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>
    hypot(_Tp __x, _Up __y, _Vp __z)
    {
      using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
      return std::__hypot3<__type>(__x, __y, __z);
    }
# 3902 "/usr/include/c++/14/cmath" 3

}


# 1 "/usr/include/c++/14/bits/specfun.h" 1 3
# 37 "/usr/include/c++/14/bits/specfun.h" 3
# 1 "/usr/include/c++/14/bits/version.h" 1 3
# 47 "/usr/include/c++/14/bits/version.h" 3
       
# 48 "/usr/include/c++/14/bits/version.h" 3
# 38 "/usr/include/c++/14/bits/specfun.h" 2 3





# 1 "/usr/include/c++/14/bits/stl_algobase.h" 1 3
# 60 "/usr/include/c++/14/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/14/bits/functexcept.h" 1 3
# 40 "/usr/include/c++/14/bits/functexcept.h" 3
# 1 "/usr/include/c++/14/bits/exception_defines.h" 1 3
# 41 "/usr/include/c++/14/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));

  void
  __throw_bad_array_new_length(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__,__cold__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__,__cold__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__,__cold__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__,__cold__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_ios_failure(const char*, int) __attribute__((__noreturn__,__cold__));


  void
  __throw_system_error(int) __attribute__((__noreturn__,__cold__));


  void
  __throw_future_error(int) __attribute__((__noreturn__,__cold__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__,__cold__));
# 140 "/usr/include/c++/14/bits/functexcept.h" 3

}
# 61 "/usr/include/c++/14/bits/stl_algobase.h" 2 3


# 1 "/usr/include/c++/14/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/14/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/14/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 50 "/usr/include/c++/14/ext/numeric_traits.h" 3
  template<typename _Tp>
    struct __is_integer_nonstrict
    : public std::__is_integer<_Tp>
    {
      using std::__is_integer<_Tp>::__value;


      enum { __width = __value ? sizeof(_Tp) * 8 : 0 };
    };

  template<typename _Value>
    struct __numeric_traits_integer
    {

      static_assert(__is_integer_nonstrict<_Value>::__value,
      "invalid specialization");




      static const bool __is_signed = (_Value)(-1) < 0;
      static const int __digits
 = __is_integer_nonstrict<_Value>::__width - __is_signed;


      static const _Value __max = __is_signed
 ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)
 : ~(_Value)0;
      static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 137 "/usr/include/c++/14/ext/numeric_traits.h" 3
  template<typename _Tp>
    using __int_traits = __numeric_traits_integer<_Tp>;
# 157 "/usr/include/c++/14/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;






  template<typename _Value>
    struct __numeric_traits
    : public __numeric_traits_integer<_Value>
    { };

  template<>
    struct __numeric_traits<float>
    : public __numeric_traits_floating<float>
    { };

  template<>
    struct __numeric_traits<double>
    : public __numeric_traits_floating<double>
    { };

  template<>
    struct __numeric_traits<long double>
    : public __numeric_traits_floating<long double>
    { };
# 238 "/usr/include/c++/14/ext/numeric_traits.h" 3

}
# 64 "/usr/include/c++/14/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/14/bits/stl_pair.h" 1 3
# 60 "/usr/include/c++/14/bits/stl_pair.h" 3
# 1 "/usr/include/c++/14/type_traits" 1 3
# 32 "/usr/include/c++/14/type_traits" 3
       
# 33 "/usr/include/c++/14/type_traits" 3
# 63 "/usr/include/c++/14/type_traits" 3
# 1 "/usr/include/c++/14/bits/version.h" 1 3
# 47 "/usr/include/c++/14/bits/version.h" 3
       
# 48 "/usr/include/c++/14/bits/version.h" 3
# 64 "/usr/include/c++/14/type_traits" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp>
    class reference_wrapper;
# 86 "/usr/include/c++/14/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      using value_type = _Tp;
      using type = integral_constant<_Tp, __v>;
      constexpr operator value_type() const noexcept { return value; }


      constexpr value_type operator()() const noexcept { return value; }

    };
# 106 "/usr/include/c++/14/type_traits" 3
  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;



  using true_type = __bool_constant<true>;


  using false_type = __bool_constant<false>;




  template<bool __v>
    using bool_constant = __bool_constant<__v>;






  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { using type = _Tp; };


  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

  template<bool>
    struct __conditional
    {
      template<typename _Tp, typename>
 using type = _Tp;
    };

  template<>
    struct __conditional<false>
    {
      template<typename, typename _Up>
 using type = _Up;
    };


  template<bool _Cond, typename _If, typename _Else>
    using __conditional_t
      = typename __conditional<_Cond>::template type<_If, _Else>;


  template <typename _Type>
    struct __type_identity
    { using type = _Type; };

  template<typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

  namespace __detail
  {

    template<typename _Tp, typename...>
      using __first_t = _Tp;


    template<typename... _Bn>
      auto __or_fn(int) -> __first_t<false_type,
         __enable_if_t<!bool(_Bn::value)>...>;

    template<typename... _Bn>
      auto __or_fn(...) -> true_type;

    template<typename... _Bn>
      auto __and_fn(int) -> __first_t<true_type,
          __enable_if_t<bool(_Bn::value)>...>;

    template<typename... _Bn>
      auto __and_fn(...) -> false_type;
  }




  template<typename... _Bn>
    struct __or_
    : decltype(__detail::__or_fn<_Bn...>(0))
    { };

  template<typename... _Bn>
    struct __and_
    : decltype(__detail::__and_fn<_Bn...>(0))
    { };

  template<typename _Pp>
    struct __not_
    : __bool_constant<!bool(_Pp::value)>
    { };





  template<typename... _Bn>
    inline constexpr bool __or_v = __or_<_Bn...>::value;
  template<typename... _Bn>
    inline constexpr bool __and_v = __and_<_Bn...>::value;

  namespace __detail
  {
    template<typename , typename _B1, typename... _Bn>
      struct __disjunction_impl
      { using type = _B1; };

    template<typename _B1, typename _B2, typename... _Bn>
      struct __disjunction_impl<__enable_if_t<!bool(_B1::value)>, _B1, _B2, _Bn...>
      { using type = typename __disjunction_impl<void, _B2, _Bn...>::type; };

    template<typename , typename _B1, typename... _Bn>
      struct __conjunction_impl
      { using type = _B1; };

    template<typename _B1, typename _B2, typename... _Bn>
      struct __conjunction_impl<__enable_if_t<bool(_B1::value)>, _B1, _B2, _Bn...>
      { using type = typename __conjunction_impl<void, _B2, _Bn...>::type; };
  }


  template<typename... _Bn>
    struct conjunction
    : __detail::__conjunction_impl<void, _Bn...>::type
    { };

  template<>
    struct conjunction<>
    : true_type
    { };

  template<typename... _Bn>
    struct disjunction
    : __detail::__disjunction_impl<void, _Bn...>::type
    { };

  template<>
    struct disjunction<>
    : false_type
    { };

  template<typename _Pp>
    struct negation
    : __not_<_Pp>::type
    { };




  template<typename... _Bn>
    inline constexpr bool conjunction_v = conjunction<_Bn...>::value;

  template<typename... _Bn>
    inline constexpr bool disjunction_v = disjunction<_Bn...>::value;

  template<typename _Pp>
    inline constexpr bool negation_v = negation<_Pp>::value;





  template<typename>
    struct is_reference;
  template<typename>
    struct is_function;
  template<typename>
    struct is_void;
  template<typename>
    struct remove_cv;
  template<typename>
    struct is_const;


  template<typename>
    struct __is_array_unknown_bounds;




  template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
    { return {}; }

  template <typename _TypeIdentity,
      typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
      is_reference<_NestedType>,
      is_function<_NestedType>,
      is_void<_NestedType>,
      __is_array_unknown_bounds<_NestedType>
    >::type __is_complete_or_unbounded(_TypeIdentity)
    { return {}; }


  template<typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;





  template<typename _Tp>
    struct is_void
    : public false_type { };

  template<>
    struct is_void<void>
    : public true_type { };

  template<>
    struct is_void<const void>
    : public true_type { };

  template<>
    struct is_void<volatile void>
    : public true_type { };

  template<>
    struct is_void<const volatile void>
    : public true_type { };


  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };




  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };







  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  __extension__
  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  __extension__
  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 460 "/usr/include/c++/14/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 513 "/usr/include/c++/14/type_traits" 3
  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };




  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    { };



  template<typename _Tp>
    struct is_array
    : public __bool_constant<__is_array(_Tp)>
    { };
# 545 "/usr/include/c++/14/type_traits" 3
  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };



  template<typename _Tp>
    struct is_member_object_pointer
    : public __bool_constant<__is_member_object_pointer(_Tp)>
    { };
# 601 "/usr/include/c++/14/type_traits" 3
  template<typename _Tp>
    struct is_member_function_pointer
    : public __bool_constant<__is_member_function_pointer(_Tp)>
    { };
# 622 "/usr/include/c++/14/type_traits" 3
  template<typename _Tp>
    struct is_enum
    : public __bool_constant<__is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public __bool_constant<__is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public __bool_constant<__is_class(_Tp)>
    { };



  template<typename _Tp>
    struct is_function
    : public __bool_constant<__is_function(_Tp)>
    { };
# 661 "/usr/include/c++/14/type_traits" 3
  template<typename _Tp>
    struct is_null_pointer
    : public false_type { };

  template<>
    struct is_null_pointer<std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<const std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<volatile std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<const volatile std::nullptr_t>
    : public true_type { };



  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { } __attribute__ ((__deprecated__ ("use '" "std::is_null_pointer" "' instead")));






  template<typename _Tp>
    struct is_reference
    : public __bool_constant<__is_reference(_Tp)>
    { };
# 715 "/usr/include/c++/14/type_traits" 3
  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };



  template<typename _Tp>
    struct is_object
    : public __bool_constant<__is_object(_Tp)>
    { };
# 741 "/usr/include/c++/14/type_traits" 3
  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __bool_constant<!is_fundamental<_Tp>::value> { };



  template<typename _Tp>
    struct is_member_pointer
    : public __bool_constant<__is_member_pointer(_Tp)>
    { };
# 779 "/usr/include/c++/14/type_traits" 3
  template<typename, typename>
    struct is_same;


  template<typename _Tp, typename... _Types>
    using __is_one_of = __or_<is_same<_Tp, _Types>...>;


  __extension__
  template<typename _Tp>
    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,
   signed char, signed short, signed int, signed long,
   signed long long

   , signed __int128
# 804 "/usr/include/c++/14/type_traits" 3
   >;


  __extension__
  template<typename _Tp>
    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,
   unsigned char, unsigned short, unsigned int, unsigned long,
   unsigned long long

   , unsigned __int128
# 824 "/usr/include/c++/14/type_traits" 3
   >;


  template<typename _Tp>
    using __is_standard_integer
      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;


  template<typename...> using __void_t = void;





  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public __bool_constant<__is_trivial(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copyable
    : public __bool_constant<__is_trivially_copyable(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_standard_layout
    : public __bool_constant<__is_standard_layout(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };






  template<typename _Tp>
    struct
   
    is_pod
    : public __bool_constant<__is_pod(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct
    [[__deprecated__]]
    is_literal_type
    : public __bool_constant<__is_literal_type(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_empty
    : public __bool_constant<__is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public __bool_constant<__is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public __bool_constant<__is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public __bool_constant<__is_abstract(_Tp)>
    { };


  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public __bool_constant<_Tp(-1) < _Tp(0)>
    { };



  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
    { };


  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);


  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename>
    struct remove_all_extents;


  template<typename _Tp>
    struct __is_array_known_bounds
    : public false_type
    { };

  template<typename _Tp, size_t _Size>
    struct __is_array_known_bounds<_Tp[_Size]>
    : public true_type
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public false_type
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds<_Tp[]>
    : public true_type
    { };
# 1006 "/usr/include/c++/14/type_traits" 3
  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };







  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_constructible_impl
      = __bool_constant<__is_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __is_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename = void>
    struct __add_lvalue_reference_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, __void_t<_Tp&>>
    { using type = _Tp&; };

  template<typename _Tp>
    using __add_lval_ref_t = typename __add_lvalue_reference_helper<_Tp>::type;



  template<typename _Tp>
    struct is_copy_constructible
    : public __is_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename = void>
    struct __add_rvalue_reference_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, __void_t<_Tp&&>>
    { using type = _Tp&&; };

  template<typename _Tp>
    using __add_rval_ref_t = typename __add_rvalue_reference_helper<_Tp>::type;



  template<typename _Tp>
    struct is_move_constructible
    : public __is_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_nothrow_constructible_impl
      = __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __is_nothrow_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_assignable_impl = __bool_constant<__is_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_assignable
    : public __is_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_assignable_impl<__add_lval_ref_t<_Tp>,
      __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_assignable_impl<__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_nothrow_assignable_impl
      = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __is_nothrow_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,
       __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,
       __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_trivially_constructible_impl
      = __bool_constant<__is_trivially_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __is_trivially_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public __is_trivially_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };
# 1319 "/usr/include/c++/14/type_traits" 3
  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      using type = decltype(__test(declval<_Tp>()));
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<__is_constructible_impl<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>::type
    { };



  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_trivially_assignable_impl
      = __bool_constant<__is_trivially_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __is_trivially_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,
         __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,
         __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct has_virtual_destructor
    : public __bool_constant<__has_virtual_destructor(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint = 0>
    struct extent
    : public integral_constant<size_t, 0> { };

  template<typename _Tp, size_t _Size>
    struct extent<_Tp[_Size], 0>
    : public integral_constant<size_t, _Size> { };

  template<typename _Tp, unsigned _Uint, size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public extent<_Tp, _Uint - 1>::type { };

  template<typename _Tp>
    struct extent<_Tp[], 0>
    : public integral_constant<size_t, 0> { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public extent<_Tp, _Uint - 1>::type { };






  template<typename _Tp, typename _Up>
    struct is_same
    : public __bool_constant<__is_same(_Tp, _Up)>
    { };
# 1491 "/usr/include/c++/14/type_traits" 3
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public __bool_constant<__is_base_of(_Base, _Derived)>
    { };


  template<typename _From, typename _To>
    struct is_convertible
    : public __bool_constant<__is_convertible(_From, _To)>
    { };
# 1540 "/usr/include/c++/14/type_traits" 3
  template<typename _ToElementType, typename _FromElementType>
    using __is_array_convertible
      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;
# 1600 "/usr/include/c++/14/type_traits" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wc++14-extensions"
  template<typename _Tp, typename... _Args>
    struct __is_nothrow_new_constructible_impl
    : __bool_constant<
 noexcept(::new(std::declval<void*>()) _Tp(std::declval<_Args>()...))
      >
    { };

  template<typename _Tp, typename... _Args>
    inline constexpr bool __is_nothrow_new_constructible
      = __and_<is_constructible<_Tp, _Args...>,
        __is_nothrow_new_constructible_impl<_Tp, _Args...>>::value;
#pragma GCC diagnostic pop




  template<typename _Tp>
    struct remove_const
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { using type = _Tp; };


  template<typename _Tp>
    struct remove_volatile
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { using type = _Tp; };



  template<typename _Tp>
    struct remove_cv
    { using type = __remove_cv(_Tp); };
# 1659 "/usr/include/c++/14/type_traits" 3
  template<typename _Tp>
    struct add_const
    { using type = _Tp const; };


  template<typename _Tp>
    struct add_volatile
    { using type = _Tp volatile; };


  template<typename _Tp>
    struct add_cv
    { using type = _Tp const volatile; };



  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;






  template<typename _Tp>
    struct remove_reference
    { using type = __remove_reference(_Tp); };
# 1721 "/usr/include/c++/14/type_traits" 3
  template<typename _Tp>
    struct add_lvalue_reference
    { using type = __add_lval_ref_t<_Tp>; };


  template<typename _Tp>
    struct add_rvalue_reference
    { using type = __add_rval_ref_t<_Tp>; };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;







  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { using __type = _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { using __type = volatile _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { using __type = const _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { using __type = const volatile _Unqualified; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      using __match = __cv_selector<_Unqualified, _IsConst, _IsVol>;

    public:
      using __type = typename __match::__type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { using __type = _Tp; };

  template<>
    struct __make_unsigned<char>
    { using __type = unsigned char; };

  template<>
    struct __make_unsigned<signed char>
    { using __type = unsigned char; };

  template<>
    struct __make_unsigned<short>
    { using __type = unsigned short; };

  template<>
    struct __make_unsigned<int>
    { using __type = unsigned int; };

  template<>
    struct __make_unsigned<long>
    { using __type = unsigned long; };

  template<>
    struct __make_unsigned<long long>
    { using __type = unsigned long long; };


  __extension__
  template<>
    struct __make_unsigned<__int128>
    { using __type = unsigned __int128; };
# 1834 "/usr/include/c++/14/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = __is_enum(_Tp)>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };





  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
# 1908 "/usr/include/c++/14/type_traits" 3
  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_unsigned
    { using type = typename __make_unsigned_selector<_Tp>::__type; };


  template<> struct make_unsigned<bool>;
  template<> struct make_unsigned<bool const>;
  template<> struct make_unsigned<bool volatile>;
  template<> struct make_unsigned<bool const volatile>;




  template<typename _Tp>
    struct __make_signed
    { using __type = _Tp; };

  template<>
    struct __make_signed<char>
    { using __type = signed char; };

  template<>
    struct __make_signed<unsigned char>
    { using __type = signed char; };

  template<>
    struct __make_signed<unsigned short>
    { using __type = signed short; };

  template<>
    struct __make_signed<unsigned int>
    { using __type = signed int; };

  template<>
    struct __make_signed<unsigned long>
    { using __type = signed long; };

  template<>
    struct __make_signed<unsigned long long>
    { using __type = signed long long; };


  __extension__
  template<>
    struct __make_signed<unsigned __int128>
    { using __type = __int128; };
# 1994 "/usr/include/c++/14/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = __is_enum(_Tp)>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      using __unsigned_type = typename __make_unsigned_selector<_Tp>::__type;

    public:
      using __type = typename __make_signed_selector<__unsigned_type>::__type;
    };





  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
# 2040 "/usr/include/c++/14/type_traits" 3
  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_signed
    { using type = typename __make_signed_selector<_Tp>::__type; };


  template<> struct make_signed<bool>;
  template<> struct make_signed<bool const>;
  template<> struct make_signed<bool volatile>;
  template<> struct make_signed<bool const volatile>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { using type = _Tp; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { using type = _Tp; };


  template<typename _Tp>
    struct remove_all_extents
    { using type = _Tp; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { using type = typename remove_all_extents<_Tp>::type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { using type = typename remove_all_extents<_Tp>::type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;






  template<typename _Tp>
    struct remove_pointer
    { using type = __remove_pointer(_Tp); };
# 2139 "/usr/include/c++/14/type_traits" 3
  template<typename _Tp, typename = void>
    struct __add_pointer_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, __void_t<_Tp*>>
    { using type = _Tp*; };


  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };

  template<typename _Tp>
    struct add_pointer<_Tp&>
    { using type = _Tp*; };

  template<typename _Tp>
    struct add_pointer<_Tp&&>
    { using type = _Tp*; };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2194 "/usr/include/c++/14/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct
   
    aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 2240 "/usr/include/c++/14/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct
   
    aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      using type = typename aligned_storage<_S_len, alignment_value>::type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;
#pragma GCC diagnostic pop





  template<typename _Up>
    struct __decay_selector
    : __conditional_t<is_const<const _Up>::value,
        remove_cv<_Up>,
        add_pointer<_Up>>
    { };

  template<typename _Up, size_t _Nm>
    struct __decay_selector<_Up[_Nm]>
    { using type = _Up*; };

  template<typename _Up>
    struct __decay_selector<_Up[]>
    { using type = _Up*; };




  template<typename _Tp>
    struct decay
    { using type = typename __decay_selector<_Tp>::type; };

  template<typename _Tp>
    struct decay<_Tp&>
    { using type = typename __decay_selector<_Tp>::type; };

  template<typename _Tp>
    struct decay<_Tp&&>
    { using type = typename __decay_selector<_Tp>::type; };




  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      using __type = _Tp;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      using __type = _Tp&;
    };


  template<typename _Tp>
    using __decay_t = typename decay<_Tp>::type;

  template<typename _Tp>
    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;





  template<typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;




  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { using type = _Iftrue; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { using type = _Iffalse; };


  template<typename... _Tp>
    struct common_type;
# 2355 "/usr/include/c++/14/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { using type = _Tp; };

  struct __failure_type
  { };

  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      using __cond_t
 = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());



    template<typename _Tp, typename _Up>
      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
      _S_test(int);
# 2382 "/usr/include/c++/14/type_traits" 3
    template<typename, typename>
      static __failure_type
      _S_test_2(...);

    template<typename _Tp, typename _Up>
      static decltype(_S_test_2<_Tp, _Up>(0))
      _S_test(...);
  };


  template<>
    struct common_type<>
    { };


  template<typename _Tp0>
    struct common_type<_Tp0>
    : public common_type<_Tp0, _Tp0>
    { };


  template<typename _Tp1, typename _Tp2,
    typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {


      using type = common_type<_Dp1, _Dp2>;
    };

  template<typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
    : private __do_common_type_impl
    {


      using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };


  template<typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
    : public __common_type_impl<_Tp1, _Tp2>::type
    { };

  template<typename...>
    struct __common_type_pack
    { };

  template<typename, typename, typename = void>
    struct __common_type_fold;


  template<typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>,
    __common_type_pack<_Rp...>>
    { };




  template<typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
         __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...>
    { };


  template<typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    { };

  template<typename _Tp, bool = __is_enum(_Tp)>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };



  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };


  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };






  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    struct result_of;




  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg, _Args...>(0));
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg, _Args...>(0));
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg>(0));
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg>(0));
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      using _Argval = __remove_cvref_t<_Arg>;
      using _MemPtr = _Res _Class::*;
      using type = typename __conditional_t<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      using _Argval = typename remove_reference<_Arg>::type;
      using _MemPtr = _Res _Class::*;
      using type = typename __conditional_t<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      using type = __failure_type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      using type = decltype(_S_test<_Functor, _ArgTypes...>(0));
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };


  template<typename _Fn, typename... _Args>
    using __invoke_result_t = typename __invoke_result<_Fn, _Args...>::type;


  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { } __attribute__ ((__deprecated__ ("use '" "std::invoke_result" "' instead")));


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
#pragma GCC diagnostic pop


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;




  template<typename...> using void_t = void;
# 2759 "/usr/include/c++/14/type_traits" 3
  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using type = _Default;
      using __is_detected = false_type;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using type = _Op<_Args...>;
      using __is_detected = true_type;
    };

  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;



  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2801 "/usr/include/c++/14/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };


  template<typename _Tp>
   
    inline
    _Require<__not_<__is_tuple_like<_Tp>>,
      is_move_constructible<_Tp>,
      is_move_assignable<_Tp>>
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
   
    inline
    __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);


  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };






  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    inline constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    inline constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;



  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      using type = decltype(__test<_Tp, _Up>(0));
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      using type = decltype(__test<_Tp&>(0));
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      using type = decltype(__test<_Tp, _Up>(0));
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      using type = decltype(__test<_Tp&>(0));
    };



  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp, typename _Up>
    inline constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    inline constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;
# 3023 "/usr/include/c++/14/type_traits" 3
  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl
    : false_type
    {
      using __nothrow_conv = false_type;
    };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    {
      using __nothrow_conv = true_type;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:

      using _Res_t = typename _Result::type;



      static _Res_t _S_get() noexcept;


      template<typename _Tp>
 static void _S_conv(__type_identity_t<_Tp>) noexcept;


      template<typename _Tp,
        bool _Nothrow = noexcept(_S_conv<_Tp>(_S_get())),
        typename = decltype(_S_conv<_Tp>(_S_get())),

        bool _Dangle = __reference_converts_from_temporary(_Tp, _Res_t)



       >
 static __bool_constant<_Nothrow && !_Dangle>
 _S_test(int);

      template<typename _Tp, bool = false>
 static false_type
 _S_test(...);

    public:

      using type = decltype(_S_test<_Ret, true>(1));


      using __nothrow_conv = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
#pragma GCC diagnostic pop




  template<typename _Functor, typename... _ArgTypes>
    struct invoke_result
    : public __invoke_result<_Functor, _ArgTypes...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>{}),
 "_Functor must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _Args>
    using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;


  template<typename _Fn, typename... _ArgTypes>
    struct is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_invocable_r
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable
    : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,
      __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };





  template<typename _Result, typename _Ret>
    using __is_nt_invocable_impl
      = typename __is_invocable_impl<_Result, _Ret>::__nothrow_conv;



  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable_r
    : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
             __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };
# 3251 "/usr/include/c++/14/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_void_v = is_void<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_integral_v = is_integral<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;


template <typename _Tp>
  inline constexpr bool is_array_v = __is_array(_Tp);
# 3272 "/usr/include/c++/14/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v = false;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v<_Tp&> = true;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v = false;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v<_Tp&&> = true;


template <typename _Tp>
  inline constexpr bool is_member_object_pointer_v =
    __is_member_object_pointer(_Tp);







template <typename _Tp>
  inline constexpr bool is_member_function_pointer_v =
    __is_member_function_pointer(_Tp);






template <typename _Tp>
  inline constexpr bool is_enum_v = __is_enum(_Tp);
template <typename _Tp>
  inline constexpr bool is_union_v = __is_union(_Tp);
template <typename _Tp>
  inline constexpr bool is_class_v = __is_class(_Tp);



template <typename _Tp>
  inline constexpr bool is_reference_v = __is_reference(_Tp);
# 3323 "/usr/include/c++/14/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;


template <typename _Tp>
  inline constexpr bool is_object_v = __is_object(_Tp);





template <typename _Tp>
  inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_compound_v = !is_fundamental_v<_Tp>;


template <typename _Tp>
  inline constexpr bool is_member_pointer_v = __is_member_pointer(_Tp);





template <typename _Tp>
  inline constexpr bool is_const_v = false;
template <typename _Tp>
  inline constexpr bool is_const_v<const _Tp> = true;


template <typename _Tp>
  inline constexpr bool is_function_v = __is_function(_Tp);
# 3366 "/usr/include/c++/14/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_volatile_v = false;
template <typename _Tp>
  inline constexpr bool is_volatile_v<volatile _Tp> = true;

template <typename _Tp>
  inline constexpr bool is_trivial_v = __is_trivial(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);
template <typename _Tp>
  inline constexpr bool is_standard_layout_v = __is_standard_layout(_Tp);
template <typename _Tp>
 
  inline constexpr bool is_pod_v = __is_pod(_Tp);
template <typename _Tp>
  [[__deprecated__]]
  inline constexpr bool is_literal_type_v = __is_literal_type(_Tp);
template <typename _Tp>
  inline constexpr bool is_empty_v = __is_empty(_Tp);
template <typename _Tp>
  inline constexpr bool is_polymorphic_v = __is_polymorphic(_Tp);
template <typename _Tp>
  inline constexpr bool is_abstract_v = __is_abstract(_Tp);
template <typename _Tp>
  inline constexpr bool is_final_v = __is_final(_Tp);

template <typename _Tp>
  inline constexpr bool is_signed_v = is_signed<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;

template <typename _Tp, typename... _Args>
  inline constexpr bool is_constructible_v = __is_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_default_constructible_v = __is_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_copy_constructible_v
    = __is_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_move_constructible_v
    = __is_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_copy_assignable_v
    = __is_assignable(__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_move_assignable_v
    = __is_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

template <typename _Tp>
  inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;

template <typename _Tp, typename... _Args>
  inline constexpr bool is_trivially_constructible_v
    = __is_trivially_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_trivially_default_constructible_v
    = __is_trivially_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_copy_constructible_v
    = __is_trivially_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_trivially_move_constructible_v
    = __is_trivially_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_trivially_assignable_v
    = __is_trivially_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_trivially_copy_assignable_v
    = __is_trivially_assignable(__add_lval_ref_t<_Tp>,
    __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_trivially_move_assignable_v
    = __is_trivially_assignable(__add_lval_ref_t<_Tp>,
    __add_rval_ref_t<_Tp>);
# 3461 "/usr/include/c++/14/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v =
    is_trivially_destructible<_Tp>::value;


template <typename _Tp, typename... _Args>
  inline constexpr bool is_nothrow_constructible_v
    = __is_nothrow_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_nothrow_default_constructible_v
    = __is_nothrow_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_constructible_v
    = __is_nothrow_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_nothrow_move_constructible_v
    = __is_nothrow_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_nothrow_assignable_v
    = __is_nothrow_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_assignable_v
    = __is_nothrow_assignable(__add_lval_ref_t<_Tp>,
         __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_nothrow_move_assignable_v
    = __is_nothrow_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

template <typename _Tp>
  inline constexpr bool is_nothrow_destructible_v =
    is_nothrow_destructible<_Tp>::value;

template <typename _Tp>
  inline constexpr bool has_virtual_destructor_v
    = __has_virtual_destructor(_Tp);

template <typename _Tp>
  inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;

template <typename _Tp>
  inline constexpr size_t rank_v = 0;
template <typename _Tp, size_t _Size>
  inline constexpr size_t rank_v<_Tp[_Size]> = 1 + rank_v<_Tp>;
template <typename _Tp>
  inline constexpr size_t rank_v<_Tp[]> = 1 + rank_v<_Tp>;

template <typename _Tp, unsigned _Idx = 0>
  inline constexpr size_t extent_v = 0;
template <typename _Tp, size_t _Size>
  inline constexpr size_t extent_v<_Tp[_Size], 0> = _Size;
template <typename _Tp, unsigned _Idx, size_t _Size>
  inline constexpr size_t extent_v<_Tp[_Size], _Idx> = extent_v<_Tp, _Idx - 1>;
template <typename _Tp>
  inline constexpr size_t extent_v<_Tp[], 0> = 0;
template <typename _Tp, unsigned _Idx>
  inline constexpr size_t extent_v<_Tp[], _Idx> = extent_v<_Tp, _Idx - 1>;


template <typename _Tp, typename _Up>
  inline constexpr bool is_same_v = __is_same(_Tp, _Up);






template <typename _Base, typename _Derived>
  inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

template <typename _From, typename _To>
  inline constexpr bool is_convertible_v = __is_convertible(_From, _To);




template<typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
template<typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_v
    = is_nothrow_invocable<_Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_r_v
    = is_invocable_r<_Ret, _Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_r_v
    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;






  template<typename _Tp>
    struct has_unique_object_representations
    : bool_constant<__has_unique_object_representations(
      remove_cv_t<remove_all_extents_t<_Tp>>
      )>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    inline constexpr bool has_unique_object_representations_v
      = has_unique_object_representations<_Tp>::value;






  template<typename _Tp>
    struct is_aggregate
    : bool_constant<__is_aggregate(remove_cv_t<_Tp>)>
    { };






  template<typename _Tp>
    inline constexpr bool is_aggregate_v = __is_aggregate(remove_cv_t<_Tp>);
# 4017 "/usr/include/c++/14/type_traits" 3

}
# 61 "/usr/include/c++/14/bits/stl_pair.h" 2 3
# 1 "/usr/include/c++/14/bits/move.h" 1 3
# 40 "/usr/include/c++/14/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }
# 68 "/usr/include/c++/14/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }
# 81 "/usr/include/c++/14/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value,
   "std::forward must not be used to convert an rvalue to an lvalue");
      return static_cast<_Tp&&>(__t);
    }
# 134 "/usr/include/c++/14/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 155 "/usr/include/c++/14/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr
    __conditional_t<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 172 "/usr/include/c++/14/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
   
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 216 "/usr/include/c++/14/bits/move.h" 3
  template<typename _Tp>
   
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type



    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)

    {




      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
   
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type



    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 62 "/usr/include/c++/14/bits/stl_pair.h" 2 3
# 1 "/usr/include/c++/14/bits/utility.h" 1 3
# 36 "/usr/include/c++/14/bits/utility.h" 3
       
# 37 "/usr/include/c++/14/bits/utility.h" 3






namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<typename _Tp>
    inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;



  template<size_t __i, typename _Tp>
    struct tuple_element;


  template<size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      using type = const __tuple_element_t<__i, _Tp>;
    };

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      using type = volatile __tuple_element_t<__i, _Tp>;
    };

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      using type = const volatile __tuple_element_t<__i, _Tp>;
    };





  template<typename _Tp, typename... _Types>
    constexpr size_t
    __find_uniq_type_in_pack()
    {
      constexpr size_t __sz = sizeof...(_Types);
      constexpr bool __found[__sz] = { __is_same(_Tp, _Types) ... };
      size_t __n = __sz;
      for (size_t __i = 0; __i < __sz; ++__i)
 {
   if (__found[__i])
     {
       if (__n < __sz)
  return __sz;
       __n = __i;
     }
 }
      return __n;
    }
# 134 "/usr/include/c++/14/bits/utility.h" 3
  template<size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;




  template<size_t... _Indexes> struct _Index_tuple { };


  template<size_t _Num>
    struct _Build_index_tuple
    {
# 154 "/usr/include/c++/14/bits/utility.h" 3
      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };




  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {



      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence



      = integer_sequence<_Tp, __integer_pack(_Num)...>;



  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;




  struct in_place_t {
    explicit in_place_t() = default;
  };

  inline constexpr in_place_t in_place{};

  template<typename _Tp> struct in_place_type_t
  {
    explicit in_place_type_t() = default;
  };

  template<typename _Tp>
    inline constexpr in_place_type_t<_Tp> in_place_type{};

  template<size_t _Idx> struct in_place_index_t
  {
    explicit in_place_index_t() = default;
  };

  template<size_t _Idx>
    inline constexpr in_place_index_t<_Idx> in_place_index{};

  template<typename>
    inline constexpr bool __is_in_place_type_v = false;

  template<typename _Tp>
    inline constexpr bool __is_in_place_type_v<in_place_type_t<_Tp>> = true;

  template<typename _Tp>
    using __is_in_place_type = bool_constant<__is_in_place_type_v<_Tp>>;

  template<typename>
    inline constexpr bool __is_in_place_index_v = false;

  template<size_t _Nm>
    inline constexpr bool __is_in_place_index_v<in_place_index_t<_Nm>> = true;




  template<size_t _Np, typename... _Types>
    struct _Nth_type
    { using type = __type_pack_element<_Np, _Types...>; };
# 283 "/usr/include/c++/14/bits/utility.h" 3

}
# 63 "/usr/include/c++/14/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 79 "/usr/include/c++/14/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  inline constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();




  template<typename _T1, typename _T2>
    struct pair;

  template<typename...>
    class tuple;





  template<typename _Tp, size_t _Nm>
    struct array;

  template<size_t...>
    struct _Index_tuple;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(pair<_Tp1, _Tp2>& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(pair<_Tp1, _Tp2>&& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(const pair<_Tp1, _Tp2>& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(const pair<_Tp1, _Tp2>&& __in) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&&) noexcept;







  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }
    };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
    };
# 260 "/usr/include/c++/14/bits/stl_pair.h" 3
  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };
# 283 "/usr/include/c++/14/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    : public __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;


      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;

      template<typename... _Args1, typename... _Args2>

 pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);


      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
        __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }
# 331 "/usr/include/c++/14/bits/stl_pair.h" 3
    private:
      template<typename... _Args1, size_t... _Indexes1,
        typename... _Args2, size_t... _Indexes2>

 pair(tuple<_Args1...>&, tuple<_Args2...>&,
      _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    public:
# 719 "/usr/include/c++/14/bits/stl_pair.h" 3
      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>
      constexpr pair()
      : first(), second() { }

      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }



      using _PCCP = _PCC<true, _T1, _T2>;



      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }



      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
 constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second)
 { ; }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second)
 { ; }
# 803 "/usr/include/c++/14/bits/stl_pair.h" 3
    private:



      struct __zero_as_null_pointer_constant
      {
 __zero_as_null_pointer_constant(int __zero_as_null_pointer_constant::*)
 { }
 template<typename _Tp,
   typename = __enable_if_t<is_null_pointer<_Tp>::value>>
 __zero_as_null_pointer_constant(_Tp) = delete;
      };

    public:




      template<typename _U1,
        __enable_if_t<__and_<__not_<is_reference<_U1>>,
        is_pointer<_T2>,
        is_constructible<_T1, _U1>,
        __not_<is_constructible<_T1, const _U1&>>,
        is_convertible<_U1, _T1>>::value,
        bool> = true>
 __attribute__ ((__deprecated__ ("use 'nullptr' instead of '0' to " "initialize std::pair of move-only " "type and pointer")))
 constexpr
 pair(_U1&& __x, __zero_as_null_pointer_constant, ...)
 : first(std::forward<_U1>(__x)), second(nullptr)
 { ; }

      template<typename _U1,
        __enable_if_t<__and_<__not_<is_reference<_U1>>,
        is_pointer<_T2>,
        is_constructible<_T1, _U1>,
        __not_<is_constructible<_T1, const _U1&>>,
        __not_<is_convertible<_U1, _T1>>>::value,
        bool> = false>
 __attribute__ ((__deprecated__ ("use 'nullptr' instead of '0' to " "initialize std::pair of move-only " "type and pointer")))
 explicit constexpr
 pair(_U1&& __x, __zero_as_null_pointer_constant, ...)
 : first(std::forward<_U1>(__x)), second(nullptr)
 { ; }

      template<typename _U2,
        __enable_if_t<__and_<is_pointer<_T1>,
        __not_<is_reference<_U2>>,
        is_constructible<_T2, _U2>,
        __not_<is_constructible<_T2, const _U2&>>,
        is_convertible<_U2, _T2>>::value,
        bool> = true>
 __attribute__ ((__deprecated__ ("use 'nullptr' instead of '0' to " "initialize std::pair of move-only " "type and pointer")))
 constexpr
 pair(__zero_as_null_pointer_constant, _U2&& __y, ...)
 : first(nullptr), second(std::forward<_U2>(__y))
 { ; }

      template<typename _U2,
        __enable_if_t<__and_<is_pointer<_T1>,
        __not_<is_reference<_U2>>,
        is_constructible<_T2, _U2>,
        __not_<is_constructible<_T2, const _U2&>>,
        __not_<is_convertible<_U2, _T2>>>::value,
        bool> = false>
 __attribute__ ((__deprecated__ ("use 'nullptr' instead of '0' to " "initialize std::pair of move-only " "type and pointer")))
 explicit constexpr
 pair(__zero_as_null_pointer_constant, _U2&& __y, ...)
 : first(nullptr), second(std::forward<_U2>(__y))
 { ; }



      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))
 { ; }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))
 { ; }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second))
 { ; }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second))
 { ; }



      pair&
      operator=(__conditional_t<__and_<is_copy_assignable<_T1>,
           is_copy_assignable<_T2>>::value,
    const pair&, const __nonesuch&> __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(__conditional_t<__and_<is_move_assignable<_T1>,
           is_move_assignable<_T2>>::value,
    pair&&, __nonesuch&&> __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
 typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
      is_assignable<_T2&, const _U2&>>::value,
      pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
 typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
      is_assignable<_T2&, _U2&&>>::value,
      pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }
# 995 "/usr/include/c++/14/bits/stl_pair.h" 3
    };




  template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;
# 1031 "/usr/include/c++/14/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
# 1043 "/usr/include/c++/14/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 1080 "/usr/include/c++/14/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 1103 "/usr/include/c++/14/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 1129 "/usr/include/c++/14/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 1152 "/usr/include/c++/14/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type
    { };



  template<class _Tp1, class _Tp2>
    struct tuple_size<pair<_Tp1, _Tp2>>
    : public integral_constant<size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };



  template<size_t __i, typename... _Types>
    struct tuple_element<__i, tuple<_Types...>>;


  template<typename _Tp1, typename _Tp2>
    inline constexpr size_t tuple_size_v<pair<_Tp1, _Tp2>> = 2;

  template<typename _Tp1, typename _Tp2>
    inline constexpr size_t tuple_size_v<const pair<_Tp1, _Tp2>> = 2;

  template<typename _Tp>
    inline constexpr bool __is_pair = false;

  template<typename _Tp, typename _Up>
    inline constexpr bool __is_pair<pair<_Tp, _Up>> = true;



  template<size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp1&
 __get(pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp1&&
 __move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp1&
 __const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp1&&
 __const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp2&
 __get(pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp2&&
 __move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp2&
 __const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp2&&
 __const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<const _Tp2>(__pair.second); }
    };






  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(const pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(const pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }



  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }
# 1332 "/usr/include/c++/14/bits/stl_pair.h" 3

}
# 65 "/usr/include/c++/14/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/14/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/include/c++/14/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/include/c++/14/bits/stl_iterator_base_types.h" 3
# 74 "/usr/include/c++/14/bits/stl_iterator_base_types.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 93 "/usr/include/c++/14/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 125 "/usr/include/c++/14/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct [[__deprecated__]] iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 149 "/usr/include/c++/14/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits;




  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };



  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };


  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 209 "/usr/include/c++/14/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };






  template<typename _Iter>
    __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }




  template<typename _Iter>
    using __iter_category_t
      = typename iterator_traits<_Iter>::iterator_category;

  template<typename _InIter>
    using _RequireInputIter =
      __enable_if_t<is_convertible<__iter_category_t<_InIter>,
       input_iterator_tag>::value>;

  template<typename _It,
    typename _Cat = __iter_category_t<_It>>
    struct __is_random_access_iter
      : is_base_of<random_access_iterator_tag, _Cat>
    {
      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
      enum { __value = _Base::value };
    };








}
# 66 "/usr/include/c++/14/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/14/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/include/c++/14/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/include/c++/14/bits/stl_iterator_base_funcs.h" 3

# 1 "/usr/include/c++/14/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/14/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/14/bits/concept_check.h" 3
# 65 "/usr/include/c++/14/bits/stl_iterator_base_funcs.h" 2 3
# 1 "/usr/include/c++/14/debug/assertions.h" 1 3
# 66 "/usr/include/c++/14/bits/stl_iterator_base_funcs.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);




  template<typename _OutputIterator>
    void
    __distance(_OutputIterator, _OutputIterator, output_iterator_tag) = delete;
# 144 "/usr/include/c++/14/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    [[__nodiscard__]] __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      do { if (std::__is_constant_evaluated() && !bool(__n >= 0)) std::__glibcxx_assert_fail(); } while (false);
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }



  template<typename _OutputIterator, typename _Distance>
    void
    __advance(_OutputIterator&, _Distance, output_iterator_tag) = delete;
# 217 "/usr/include/c++/14/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    __attribute__((__always_inline__))
    inline constexpr void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    [[__nodiscard__]] [[__gnu__::__always_inline__]]
    inline constexpr _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {

     
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    [[__nodiscard__]] [[__gnu__::__always_inline__]]
    inline constexpr _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/usr/include/c++/14/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/14/bits/stl_iterator.h" 1 3
# 67 "/usr/include/c++/14/bits/stl_iterator.h" 3
# 1 "/usr/include/c++/14/bits/ptr_traits.h" 1 3
# 42 "/usr/include/c++/14/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  class __undefined;



  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _SomeTemplate, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_SomeTemplate<_Tp, _Types...>>
    { using type = _Tp; };



  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _SomeTemplate, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_SomeTemplate<_Tp, _Types...>, _Up>
    { using type = _SomeTemplate<_Up, _Types...>; };


  template<typename _Ptr, typename = void>
    struct __ptr_traits_elem : __get_first_arg<_Ptr>
    { };







  template<typename _Ptr>
    struct __ptr_traits_elem<_Ptr, __void_t<typename _Ptr::element_type>>
    { using type = typename _Ptr::element_type; };


  template<typename _Ptr>
    using __ptr_traits_elem_t = typename __ptr_traits_elem<_Ptr>::type;




  template<typename _Ptr, typename _Elt, bool = is_void<_Elt>::value>
    struct __ptr_traits_ptr_to
    {
      using pointer = _Ptr;
      using element_type = _Elt;







      static pointer
      pointer_to(element_type& __r)





      { return pointer::pointer_to(__r); }
    };


  template<typename _Ptr, typename _Elt>
    struct __ptr_traits_ptr_to<_Ptr, _Elt, true>
    { };


  template<typename _Tp>
    struct __ptr_traits_ptr_to<_Tp*, _Tp, false>
    {
      using pointer = _Tp*;
      using element_type = _Tp;






      static pointer
      pointer_to(element_type& __r) noexcept
      { return std::addressof(__r); }
    };

  template<typename _Ptr, typename _Elt>
    struct __ptr_traits_impl : __ptr_traits_ptr_to<_Ptr, _Elt>
    {
    private:
      template<typename _Tp>
 using __diff_t = typename _Tp::difference_type;

      template<typename _Tp, typename _Up>
 using __rebind = __type_identity<typename _Tp::template rebind<_Up>>;

    public:

      using pointer = _Ptr;


      using element_type = _Elt;


      using difference_type = __detected_or_t<ptrdiff_t, __diff_t, _Ptr>;


      template<typename _Up>
 using rebind = typename __detected_or_t<__replace_first_arg<_Ptr, _Up>,
      __rebind, _Ptr, _Up>::type;
    };



  template<typename _Ptr>
    struct __ptr_traits_impl<_Ptr, __undefined>
    { };







  template<typename _Ptr>
    struct pointer_traits : __ptr_traits_impl<_Ptr, __ptr_traits_elem_t<_Ptr>>
    { };







  template<typename _Tp>
    struct pointer_traits<_Tp*> : __ptr_traits_ptr_to<_Tp*, _Tp>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up> using rebind = _Up*;
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }


  template<typename _Ptr>
    constexpr typename std::pointer_traits<_Ptr>::element_type*
    __to_address(const _Ptr& __ptr)
    { return std::__to_address(__ptr.operator->()); }
# 257 "/usr/include/c++/14/bits/ptr_traits.h" 3

}
# 68 "/usr/include/c++/14/bits/stl_iterator.h" 2 3
# 85 "/usr/include/c++/14/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 106 "/usr/include/c++/14/bits/stl_iterator.h" 3
 
# 106 "/usr/include/c++/14/bits/stl_iterator.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 128 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
      template<typename _Iter>
 friend class reverse_iterator;
# 147 "/usr/include/c++/14/bits/stl_iterator.h" 3
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::pointer pointer;

      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
# 178 "/usr/include/c++/14/bits/stl_iterator.h" 3
      constexpr
      reverse_iterator()
      noexcept(noexcept(_Iterator()))
      : current()
      { }




      explicit constexpr
      reverse_iterator(iterator_type __x)
      noexcept(noexcept(_Iterator(__x)))
      : current(__x)
      { }




      constexpr
      reverse_iterator(const reverse_iterator& __x)
      noexcept(noexcept(_Iterator(__x.current)))
      : current(__x.current)
      { }


      reverse_iterator& operator=(const reverse_iterator&) = default;






      template<typename _Iter>



 constexpr
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 noexcept(noexcept(_Iterator(__x.current)))
 : current(__x.current)
 { }


      template<typename _Iter>




 constexpr
 reverse_iterator&
 operator=(const reverse_iterator<_Iter>& __x)
 noexcept(noexcept(current = __x.current))
 {
   current = __x.current;
   return *this;
 }





      [[__nodiscard__]]
      constexpr iterator_type
      base() const
      noexcept(noexcept(_Iterator(current)))
      { return current; }
# 255 "/usr/include/c++/14/bits/stl_iterator.h" 3
      [[__nodiscard__]]
      constexpr reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      [[__nodiscard__]]
      constexpr pointer
      operator->() const




      {


 _Iterator __tmp = current;
 --__tmp;
 return _S_to_pointer(__tmp);
      }






      constexpr reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      constexpr reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      constexpr reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      constexpr reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      [[__nodiscard__]]
      constexpr reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      constexpr reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      [[__nodiscard__]]
      constexpr reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      constexpr reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      [[__nodiscard__]]
      constexpr reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
# 415 "/usr/include/c++/14/bits/stl_iterator.h" 3
    private:
      template<typename _Tp>
 static constexpr _Tp*
 _S_to_pointer(_Tp* __p)
        { return __p; }

      template<typename _Tp>
 static constexpr pointer
 _S_to_pointer(_Tp __t)
        { return __t.operator->(); }
    };
# 438 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }




  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __x.base() > __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() != __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() >= __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() <= __y.base(); }
# 615 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }





  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }
# 657 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _Iterator>
   
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
   
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 688 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;





      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 726 "/usr/include/c++/14/bits/stl_iterator.h" 3
     
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

     
      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      [[__nodiscard__]]
      back_insert_iterator&
      operator*()
      { return *this; }


     
      back_insert_iterator&
      operator++()
      { return *this; }


     
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 773 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _Container>
    [[__nodiscard__]]
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 789 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;





      explicit
      front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 827 "/usr/include/c++/14/bits/stl_iterator.h" 3
     
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

     
      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      [[__nodiscard__]]
      front_insert_iterator&
      operator*()
      { return *this; }


     
      front_insert_iterator&
      operator++()
      { return *this; }


     
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 874 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _Container>
    [[__nodiscard__]]
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 894 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {



      typedef typename _Container::iterator _Iter;

    protected:
      _Container* container;
      _Iter iter;

    public:

      typedef _Container container_type;
# 919 "/usr/include/c++/14/bits/stl_iterator.h" 3
     
      insert_iterator(_Container& __x, _Iter __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 955 "/usr/include/c++/14/bits/stl_iterator.h" 3
     
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

     
      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      [[__nodiscard__]]
      insert_iterator&
      operator*()
      { return *this; }


     
      insert_iterator&
      operator++()
      { return *this; }


     
      insert_iterator&
      operator++(int)
      { return *this; }
    };

#pragma GCC diagnostic pop
# 1014 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _Container>
    [[__nodiscard__]]
    inline insert_iterator<_Container>
    inserter(_Container& __x, typename _Container::iterator __i)
    { return insert_iterator<_Container>(__x, __i); }





}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 1037 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef std::iterator_traits<_Iterator> __traits_type;


      template<typename _Iter>
 using __convertible_from
   = std::__enable_if_t<std::is_convertible<_Iter, _Iterator>::value>;


    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;





      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }



      template<typename _Iter, typename = __convertible_from<_Iter>>

 __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 noexcept
# 1085 "/usr/include/c++/14/bits/stl_iterator.h" 3
        : _M_current(__i.base()) { }


     
      reference
      operator*() const noexcept
      { return *_M_current; }

     
      pointer
      operator->() const noexcept
      { return _M_current; }

     
      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

     
      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


     
      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

     
      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


     
      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

     
      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

     
      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

     
      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

     
      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

     
      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 1205 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }






  template<typename _IteratorL, typename _IteratorR, typename _Container>


    [[__nodiscard__]]
    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]]
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
   
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it.base(); }






  template<typename _Iterator, typename _Container>
    constexpr auto
    __to_address(const __gnu_cxx::__normal_iterator<_Iterator,
          _Container>& __it) noexcept
    -> decltype(std::__to_address(__it.base()))
    { return std::__to_address(__it.base()); }
# 1412 "/usr/include/c++/14/bits/stl_iterator.h" 3
  namespace __detail
  {
# 1428 "/usr/include/c++/14/bits/stl_iterator.h" 3
  }
# 1439 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator



    {
      _Iterator _M_current;

      using __traits_type = iterator_traits<_Iterator>;

      using __base_ref = typename __traits_type::reference;


      template<typename _Iter2>
 friend class move_iterator;
# 1478 "/usr/include/c++/14/bits/stl_iterator.h" 3
    public:
      using iterator_type = _Iterator;
# 1490 "/usr/include/c++/14/bits/stl_iterator.h" 3
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      using reference
 = __conditional_t<is_reference<__base_ref>::value,
     typename remove_reference<__base_ref>::type&&,
     __base_ref>;


      constexpr
      move_iterator()
      : _M_current() { }

      explicit constexpr
      move_iterator(iterator_type __i)
      : _M_current(std::move(__i)) { }

      template<typename _Iter>



 constexpr
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i._M_current) { }

      template<typename _Iter>




 constexpr
 move_iterator& operator=(const move_iterator<_Iter>& __i)
 {
   _M_current = __i._M_current;
   return *this;
 }


      [[__nodiscard__]]
      constexpr iterator_type
      base() const
      { return _M_current; }
# 1548 "/usr/include/c++/14/bits/stl_iterator.h" 3
      [[__nodiscard__]]
      constexpr reference
      operator*() const



      { return static_cast<reference>(*_M_current); }


      [[__nodiscard__]]
      constexpr pointer
      operator->() const
      { return _M_current; }

      constexpr move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      constexpr move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }







      constexpr move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      constexpr move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      [[__nodiscard__]]
      constexpr move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      constexpr move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      [[__nodiscard__]]
      constexpr move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      constexpr move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      [[__nodiscard__]]
      constexpr reference
      operator[](difference_type __n) const



      { return std::move(_M_current[__n]); }
# 1662 "/usr/include/c++/14/bits/stl_iterator.h" 3
    };

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return __x.base() == __y.base(); }
# 1683 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }


  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)



    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)



    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return !(__x < __y); }




  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)

    { return __x.base() == __y.base(); }
# 1750 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)



    { return __x + __n; }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(std::move(__i)); }

  template<typename _Iterator, typename _ReturnType
    = __conditional_t<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
  _Iterator, move_iterator<_Iterator>>>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = __conditional_t<__move_if_noexcept_cond<_Tp>::value,
        const _Tp*, move_iterator<_Tp*>>>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }
# 2964 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _Iterator>
   
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
   
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 2996 "/usr/include/c++/14/bits/stl_iterator.h" 3
  template<typename _InputIterator>
    using __iter_key_t = remove_const_t<



      typename iterator_traits<_InputIterator>::value_type::first_type>;


  template<typename _InputIterator>
    using __iter_val_t



      = typename iterator_traits<_InputIterator>::value_type::second_type;


  template<typename _T1, typename _T2>
    struct pair;

  template<typename _InputIterator>
    using __iter_to_alloc_t
      = pair<const __iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>>;



}
# 68 "/usr/include/c++/14/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/14/debug/debug.h" 1 3
# 48 "/usr/include/c++/14/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;

  template<typename _Ite, typename _Seq, typename _Cat>
    struct _Safe_iterator;
}
# 70 "/usr/include/c++/14/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/14/bits/predefined_ops.h" 1 3
# 35 "/usr/include/c++/14/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




   
    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
     
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

 
  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

 
  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




   
    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
     
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

 
  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

 
  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
     
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

 
  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
     
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

 
  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

 
  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

     
      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

     
      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


     
      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>

 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
   
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

     
      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

     
      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


     
      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>

 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
   
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
   
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

     
      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
   
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

     
      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>

 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
   
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

     
      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
   
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

     
      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
   
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

     
      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>

 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
   
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

     
      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
   
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "/usr/include/c++/14/bits/stl_algobase.h" 2 3




# 1 "/usr/include/c++/14/bit" 1 3
# 32 "/usr/include/c++/14/bit" 3
       
# 33 "/usr/include/c++/14/bit" 3



# 1 "/usr/include/c++/14/concepts" 1 3
# 33 "/usr/include/c++/14/concepts" 3
       
# 34 "/usr/include/c++/14/concepts" 3


# 1 "/usr/include/c++/14/bits/version.h" 1 3
# 47 "/usr/include/c++/14/bits/version.h" 3
       
# 48 "/usr/include/c++/14/bits/version.h" 3
# 37 "/usr/include/c++/14/concepts" 2 3
# 37 "/usr/include/c++/14/bit" 2 3
# 61 "/usr/include/c++/14/bit" 3
# 1 "/usr/include/c++/14/bits/version.h" 1 3
# 47 "/usr/include/c++/14/bits/version.h" 3
       
# 48 "/usr/include/c++/14/bits/version.h" 3
# 62 "/usr/include/c++/14/bit" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 155 "/usr/include/c++/14/bit" 3
  template<typename _Tp>
    constexpr _Tp
    __rotl(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if constexpr ((_Nd & (_Nd - 1)) == 0)
 {


   constexpr unsigned __uNd = _Nd;
   const unsigned __r = __s;
   return (__x << (__r % __uNd)) | (__x >> ((-__r) % __uNd));
 }
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x << __r) | (__x >> ((_Nd - __r) % _Nd));
      else
 return (__x >> -__r) | (__x << ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr _Tp
    __rotr(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if constexpr ((_Nd & (_Nd - 1)) == 0)
 {


   constexpr unsigned __uNd = _Nd;
   const unsigned __r = __s;
   return (__x >> (__r % __uNd)) | (__x << ((-__r) % __uNd));
 }
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x >> __r) | (__x << ((_Nd - __r) % _Nd));
      else
 return (__x << -__r) | (__x >> ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr int
    __countl_zero(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 {
   constexpr int __diff = _Nd_u - _Nd;
   return __builtin_clz(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ul)
 {
   constexpr int __diff = _Nd_ul - _Nd;
   return __builtin_clzl(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ull)
 {
   constexpr int __diff = _Nd_ull - _Nd;
   return __builtin_clzll(__x) - __diff;
 }
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   unsigned long long __high = __x >> _Nd_ull;
   if (__high != 0)
     {
       constexpr int __diff = (2 * _Nd_ull) - _Nd;
       return __builtin_clzll(__high) - __diff;
     }
   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   return (_Nd - _Nd_ull) + __builtin_clzll(__low);
 }
    }

  template<typename _Tp>
    constexpr int
    __countl_one(_Tp __x) noexcept
    {
      return std::__countl_zero<_Tp>((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __countr_zero(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_ctz(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_ctzl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_ctzll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   if (__low != 0)
     return __builtin_ctzll(__low);
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_ctzll(__high) + _Nd_ull;
 }
    }

  template<typename _Tp>
    constexpr int
    __countr_one(_Tp __x) noexcept
    {
      return std::__countr_zero((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __popcount(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_popcount(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_popcountl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_popcountll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_popcountll(__low) + __builtin_popcountll(__high);
 }
    }

  template<typename _Tp>
    constexpr bool
    __has_single_bit(_Tp __x) noexcept
    { return std::__popcount(__x) == 1; }

  template<typename _Tp>
    constexpr _Tp
    __bit_ceil(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;
      if (__x == 0 || __x == 1)
        return 1;
      auto __shift_exponent = _Nd - std::__countl_zero((_Tp)(__x - 1u));




      if (!std::__is_constant_evaluated())
 {
   do { if (std::__is_constant_evaluated() && !bool(__shift_exponent != __int_traits<_Tp>::__digits)) std::__glibcxx_assert_fail(); } while (false);
 }

      using __promoted_type = decltype(__x << 1);
      if constexpr (!is_same<__promoted_type, _Tp>::value)
 {





   const int __extra_exp = sizeof(__promoted_type) / sizeof(_Tp) / 2;
   __shift_exponent |= (__shift_exponent & _Nd) << __extra_exp;
 }
      return (_Tp)1u << __shift_exponent;
    }

  template<typename _Tp>
    constexpr _Tp
    __bit_floor(_Tp __x) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if (__x == 0)
        return 0;
      return (_Tp)1u << (_Nd - std::__countl_zero((_Tp)(__x >> 1)));
    }

  template<typename _Tp>
    constexpr int
    __bit_width(_Tp __x) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      return _Nd - std::__countl_zero(__x);
    }
# 482 "/usr/include/c++/14/bit" 3

}
# 77 "/usr/include/c++/14/bits/stl_algobase.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{






  template<typename _Tp, typename _Up>
    constexpr
    inline int
    __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
    {

      static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
# 108 "/usr/include/c++/14/bits/stl_algobase.h" 3
 return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
# 152 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 185 "/usr/include/c++/14/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 201 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 230 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _Tp>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 254 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _Tp>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 278 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 300 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
   
    inline _Iterator
    __niter_base(_Iterator __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it; }
# 332 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _Ite, typename _Seq>
   
    decltype(std::__niter_base(std::declval<_Ite>()))
    __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,
   std::random_access_iterator_tag>&)
    noexcept(std::is_nothrow_copy_constructible<_Ite>::value);





  template<typename _From, typename _To>
   
    inline _From
    __niter_wrap(_From __from, _To __res)
    { return __from + (std::__niter_base(__res) - std::__niter_base(__from)); }


  template<typename _Iterator>
   
    inline _Iterator
    __niter_wrap(const _Iterator&, _Iterator __res)
    { return __res; }







  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }

      template<typename _Tp, typename _Up>
 static void
 __assign_one(_Tp* __to, _Up* __from)
 { *__to = *__from; }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }

      template<typename _Tp, typename _Up>
 static void
 __assign_one(_Tp* __to, _Up* __from)
 { *__to = std::move(*__from); }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp, typename _Up>

 static _Up*
 __copy_m(_Tp* __first, _Tp* __last, _Up* __result)
 {
   const ptrdiff_t _Num = __last - __first;
   if (__builtin_expect(_Num > 1, true))
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   else if (_Num == 1)
     std::__copy_move<_IsMove, false, random_access_iterator_tag>::
       __assign_one(__result, __first);
   return __result + _Num;
 }
    };



  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator;

  struct _Bit_iterator;






  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_move_a2(
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 std::_Deque_iterator<_CharT, _CharT&, _CharT*>);


  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::iterator_category _Category;





      return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
         _Category>::__copy_m(__first, __last, __result);
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a1(_II __first, _II __last, _OI __result)
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
   
    _OI
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
   
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_a(_II, _II,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
   
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
   
    _OutputIterator
    __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result,
        bool)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }


  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value, _CharT*>::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >,
        _Size, _CharT*, bool);

  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >, _Size,
        std::_Deque_iterator<_CharT, _CharT&, _CharT*>,
        bool);
# 639 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
   
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<__is_move_iterator<_II>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 672 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
   
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<true>(std::__miter_base(__first),
          std::__miter_base(__last), __result);
    }






  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp, typename _Up>

 static _Up*
 __copy_move_b(_Tp* __first, _Tp* __last, _Up* __result)
 {
   const ptrdiff_t _Num = __last - __first;
   if (__builtin_expect(_Num > 1, true))
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   else if (_Num == 1)
     std::__copy_move<_IsMove, false, random_access_iterator_tag>::
       __assign_one(__result - 1, __first);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
   
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::iterator_category _Category;





      return std::__copy_move_backward<_IsMove,
           __memcpyable<_BI2, _BI1>::__value,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
   
    inline _BI2
    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_backward_a1(
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_backward_a1(_II, _II,
       std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_backward_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_backward_a1<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
   
    _OI
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
   
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_backward_a(_II, _II,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
   
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 875 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
   
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     

      ;

      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 910 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
   
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     

      ;

      return std::__copy_move_backward_a<true>(std::__miter_base(__first),
            std::__miter_base(__last),
            __result);
    }






  template<typename _ForwardIterator, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
# 971 "/usr/include/c++/14/bits/stl_algobase.h" 3
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }

  template<typename _Ite, typename _Cont, typename _Tp>
   
    inline void
    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
       ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
       const _Tp& __value)
    { std::__fill_a1(__first.base(), __last.base(), __value); }

  template<typename _Tp, typename _VTp>
    void
    __fill_a1(const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const _VTp&);

 
  void
  __fill_a1(std::_Bit_iterator, std::_Bit_iterator,
     const bool&);

  template<typename _FIte, typename _Tp>
   
    inline void
    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    { std::__fill_a1(__first, __last, __value); }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
   
    void
    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const _Tp&);
# 1019 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(__first, __last, __value);
    }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wlong-long"

  inline constexpr int
  __size_to_integer(int __n) { return __n; }
  inline constexpr unsigned
  __size_to_integer(unsigned __n) { return __n; }
  inline constexpr long
  __size_to_integer(long __n) { return __n; }
  inline constexpr unsigned long
  __size_to_integer(unsigned long __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long long __n) { return __n; }
  inline constexpr unsigned long long
  __size_to_integer(unsigned long long __n) { return __n; }


  __extension__ inline constexpr __int128
  __size_to_integer(__int128 __n) { return __n; }
  __extension__ inline constexpr unsigned __int128
  __size_to_integer(unsigned __int128 __n) { return __n; }
# 1073 "/usr/include/c++/14/bits/stl_algobase.h" 3
  inline constexpr long long
  __size_to_integer(float __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(double __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(long double __n) { return (long long)__n; }

  __extension__ inline constexpr long long
  __size_to_integer(__float128 __n) { return (long long)__n; }

#pragma GCC diagnostic pop

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
    typename _Tp>
   
    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
        _Size __n, const _Tp& __value,
        std::input_iterator_tag);

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::output_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::input_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::random_access_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      if (__n <= 0)
 return __first;

      ;

      std::__fill_a(__first, __first + __n, __value);
      return __first + __n;
    }
# 1175 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
   
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
          std::__iterator_category(__first));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>

 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>

 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !std::__memcmp(__first1, __first2, __len);
   return true;
 }
    };

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   _II);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(_II, _II,
  std::_Deque_iterator<_Tp, _Ref, _Ptr>);

  template<typename _II1, typename _II2>
   
    inline bool
    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __memcmpable<_II1, _II2>::__value);
      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename _II1, typename _II2>
   
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      return std::__equal_aux1(std::__niter_base(__first1),
          std::__niter_base(__last1),
          std::__niter_base(__first2));
    }

  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>
   
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  _II2);

  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>
   
    bool
    __equal_aux(_II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename _II1, typename _Seq1, typename _Cat1,
    typename _II2, typename _Seq2, typename _Cat2>
   
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>

 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>

 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>

 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
   
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>

 static bool
 __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   using __gnu_cxx::__ops::__iter_less_iter;
   return std::__lexicographical_compare_impl(__first1, __last1,
           __first2, __last2,
           __iter_less_iter());
 }

      template<typename _II1, typename _II2>

 static int
 __3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   while (__first1 != __last1)
     {
       if (__first2 == __last2)
  return +1;
       if (*__first1 < *__first2)
  return -1;
       if (*__first2 < *__first1)
  return +1;
       ++__first1;
       ++__first2;
     }
   return int(__first2 == __last2) - 1;
 }
    };

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>

 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 { return __3way(__first1, __last1, __first2, __last2) < 0; }

      template<typename _Tp, typename _Up>

 static ptrdiff_t
 __3way(const _Tp* __first1, const _Tp* __last1,
        const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = std::__memcmp(__first1, __first2, __len))
       return __result;
   return ptrdiff_t(__len1 - __len2);
 }
    };

  template<typename _II1, typename _II2>
   
    inline bool
    __lexicographical_compare_aux1(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value







  );

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 _Tp2*, _Tp2*);

  template<typename _Tp1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(_Tp1*, _Tp1*,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II1, typename _II2>
   
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      return std::__lexicographical_compare_aux1(std::__niter_base(__first1),
       std::__niter_base(__last1),
       std::__niter_base(__first2),
       std::__niter_base(__last2));
    }

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _II2>
   
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  _II2, _II2);

  template<typename _II1,
    typename _Iter2, typename _Seq2, typename _Cat2>
   
    bool
    __lexicographical_compare_aux(
  _II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _Iter2, typename _Seq2, typename _Cat2>
   
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
   
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 1527 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    [[__nodiscard__]]
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  template<typename _Tp>
    inline constexpr _Tp
    __lg(_Tp __n)
    {

      return std::__bit_width(make_unsigned_t<_Tp>(__n)) - 1;
# 1563 "/usr/include/c++/14/bits/stl_algobase.h" 3
    }


# 1579 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]]
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(__first1, __last1, __first2);
    }
# 1610 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    [[__nodiscard__]]
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wc++17-extensions"


  template<typename _II1, typename _II2>
   
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if constexpr (_RAIters::value)
 {
   if ((__last1 - __first1) != (__last2 - __first2))
     return false;
   return std::equal(__first1, __last1, __first2);
 }
      else
 {
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, (void)++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return __first1 == __last1 && __first2 == __last2;
 }
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
   
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if constexpr (_RAIters::value)
 {
   if ((__last1 - __first1) != (__last2 - __first2))
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }
      else
 {
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, (void)++__first2)
     if (!bool(__binary_pred(*__first1, *__first2)))
       return false;
   return __first1 == __last1 && __first2 == __last2;
 }
    }
#pragma GCC diagnostic pop
# 1701 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]]
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2);
    }
# 1734 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    [[__nodiscard__]]
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2,
          __binary_pred);
    }
# 1766 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]]
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(__first1, __last1,
      __first2, __last2);
    }
# 1801 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    [[__nodiscard__]]
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 1916 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1944 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    [[__nodiscard__]]
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1978 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    [[__nodiscard__]]
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 2026 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    [[__nodiscard__]]
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 2062 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    [[__nodiscard__]]
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }





  template<typename _InputIterator, typename _Predicate>
   
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
   
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;

 case 2:
   if (__pred(__first))
     return __first;
   ++__first;

 case 1:
   if (__pred(__first))
     return __first;
   ++__first;

 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
   
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Predicate>
   
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }

  template<typename _ForwardIterator, typename _Predicate>
   
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   _ForwardIterator2 __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 2286 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }



# 2328 "/usr/include/c++/14/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }



}
# 44 "/usr/include/c++/14/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14/limits" 1 3
# 40 "/usr/include/c++/14/limits" 3
       
# 41 "/usr/include/c++/14/limits" 3
# 158 "/usr/include/c++/14/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/usr/include/c++/14/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/usr/include/c++/14/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "/usr/include/c++/14/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 383 "/usr/include/c++/14/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 796 "/usr/include/c++/14/limits" 3
  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffffffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffffffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1637 "/usr/include/c++/14/limits" 3
  __extension__ template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; __extension__ template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1669 "/usr/include/c++/14/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502126385303097021e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502126385303097021e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };
# 1989 "/usr/include/c++/14/limits" 3
__extension__ template<> struct numeric_limits<_Float32> { static constexpr bool is_specialized = true; static constexpr _Float32 min() noexcept { return 1.17549435082228750796873653722224568e-38F32; } static constexpr _Float32 max() noexcept { return 3.40282346638528859811704183484516925e+38F32; } static constexpr _Float32 lowest() noexcept { return -3.40282346638528859811704183484516925e+38F32; } static constexpr int digits = 24; static constexpr int digits10 = 6; static constexpr int max_digits10 = (2 + (24) * 643L / 2136); static constexpr bool is_signed = true; static constexpr bool is_integer = false; static constexpr bool is_exact = false; static constexpr int radix = 2; static constexpr _Float32 epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F32; } static constexpr _Float32 round_error() noexcept { return 0.5F32; } static constexpr int min_exponent = (-125); static constexpr int min_exponent10 = (-37); static constexpr int max_exponent = 128; static constexpr int max_exponent10 = 38; static constexpr bool has_infinity = 1; static constexpr bool has_quiet_NaN = 1; static constexpr bool has_signaling_NaN = has_quiet_NaN; static constexpr float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr _Float32 infinity() noexcept { return __builtin_huge_valf32(); } static constexpr _Float32 quiet_NaN() noexcept { return __builtin_nanf32(""); } static constexpr _Float32 signaling_NaN() noexcept { return __builtin_nansf32(""); } static constexpr _Float32 denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F32; } static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = false; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_to_nearest; };


__extension__ template<> struct numeric_limits<_Float64> { static constexpr bool is_specialized = true; static constexpr _Float64 min() noexcept { return 2.22507385850720138309023271733240406e-308F64; } static constexpr _Float64 max() noexcept { return 1.79769313486231570814527423731704357e+308F64; } static constexpr _Float64 lowest() noexcept { return -1.79769313486231570814527423731704357e+308F64; } static constexpr int digits = 53; static constexpr int digits10 = 15; static constexpr int max_digits10 = (2 + (53) * 643L / 2136); static constexpr bool is_signed = true; static constexpr bool is_integer = false; static constexpr bool is_exact = false; static constexpr int radix = 2; static constexpr _Float64 epsilon() noexcept { return 2.22044604925031308084726333618164062e-16F64; } static constexpr _Float64 round_error() noexcept { return 0.5F64; } static constexpr int min_exponent = (-1021); static constexpr int min_exponent10 = (-307); static constexpr int max_exponent = 1024; static constexpr int max_exponent10 = 308; static constexpr bool has_infinity = 1; static constexpr bool has_quiet_NaN = 1; static constexpr bool has_signaling_NaN = has_quiet_NaN; static constexpr float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr _Float64 infinity() noexcept { return __builtin_huge_valf64(); } static constexpr _Float64 quiet_NaN() noexcept { return __builtin_nanf64(""); } static constexpr _Float64 signaling_NaN() noexcept { return __builtin_nansf64(""); } static constexpr _Float64 denorm_min() noexcept { return 4.94065645841246544176568792868221372e-324F64; } static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = false; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_to_nearest; };


__extension__ template<> struct numeric_limits<_Float128> { static constexpr bool is_specialized = true; static constexpr _Float128 min() noexcept { return 3.36210314311209350626267781732175260e-4932F128; } static constexpr _Float128 max() noexcept { return 1.18973149535723176508575932662800702e+4932F128; } static constexpr _Float128 lowest() noexcept { return -1.18973149535723176508575932662800702e+4932F128; } static constexpr int digits = 113; static constexpr int digits10 = 33; static constexpr int max_digits10 = (2 + (113) * 643L / 2136); static constexpr bool is_signed = true; static constexpr bool is_integer = false; static constexpr bool is_exact = false; static constexpr int radix = 2; static constexpr _Float128 epsilon() noexcept { return 1.92592994438723585305597794258492732e-34F128; } static constexpr _Float128 round_error() noexcept { return 0.5F128; } static constexpr int min_exponent = (-16381); static constexpr int min_exponent10 = (-4931); static constexpr int max_exponent = 16384; static constexpr int max_exponent10 = 4932; static constexpr bool has_infinity = 1; static constexpr bool has_quiet_NaN = 1; static constexpr bool has_signaling_NaN = has_quiet_NaN; static constexpr float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr _Float128 infinity() noexcept { return __builtin_huge_valf128(); } static constexpr _Float128 quiet_NaN() noexcept { return __builtin_nanf128(""); } static constexpr _Float128 signaling_NaN() noexcept { return __builtin_nansf128(""); } static constexpr _Float128 denorm_min() noexcept { return 6.47517511943802511092443895822764655e-4966F128; } static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = false; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_to_nearest; };
# 2087 "/usr/include/c++/14/limits" 3
  __extension__
  template<>
    struct numeric_limits<__float128>
    {
      static constexpr bool is_specialized = true;

      static constexpr __float128
      min() noexcept
      {




 return __extension__ 0x1.0p-16382Q;

      }

      static constexpr __float128
      max() noexcept
      {







 return __extension__ 0x1.ffffffffffffffffffffffffffffp+16383Q;

      }

      static constexpr __float128
      lowest() noexcept
      { return -max(); }

      static constexpr int digits = 113;
      static constexpr int digits10 = 33;

      static constexpr int max_digits10 = 35;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr __float128
      epsilon() noexcept
      { return double(1.9259299443872359e-34); }

      static constexpr __float128
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = -16381;
      static constexpr int min_exponent10 = -4931;
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;


      static constexpr bool has_signaling_NaN = true;



      static constexpr float_denorm_style has_denorm
 = denorm_present;
      static constexpr bool has_denorm_loss = false;

      static constexpr __float128
      infinity() noexcept
      { return __builtin_huge_val(); }

      static constexpr __float128
      quiet_NaN() noexcept
      { return __builtin_nan(""); }

      static constexpr __float128
      signaling_NaN() noexcept
      {

 return __builtin_nansq("");





      }

      static constexpr __float128
      denorm_min() noexcept
      {




 return __extension__ 0x1.0p-16494Q;

      }

      static constexpr bool is_iec559 = has_signaling_NaN;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
 = round_to_nearest;
# 2218 "/usr/include/c++/14/limits" 3
    };




}
# 45 "/usr/include/c++/14/bits/specfun.h" 2 3


# 1 "/usr/include/c++/14/tr1/gamma.tcc" 1 3
# 49 "/usr/include/c++/14/tr1/gamma.tcc" 3
# 1 "/usr/include/c++/14/tr1/special_function_util.h" 1 3
# 39 "/usr/include/c++/14/tr1/special_function_util.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 50 "/usr/include/c++/14/tr1/special_function_util.h" 3
  namespace __detail
  {



    template<typename _Tp>
    struct __floating_point_constant
    {
      static const _Tp __value;
    };



    template<typename _Tp>
      struct __numeric_constants
      {

        static _Tp __pi() throw()
        { return static_cast<_Tp>(3.1415926535897932384626433832795029L); }

        static _Tp __pi_2() throw()
        { return static_cast<_Tp>(1.5707963267948966192313216916397514L); }

        static _Tp __pi_3() throw()
        { return static_cast<_Tp>(1.0471975511965977461542144610931676L); }

        static _Tp __pi_4() throw()
        { return static_cast<_Tp>(0.7853981633974483096156608458198757L); }

        static _Tp __1_pi() throw()
        { return static_cast<_Tp>(0.3183098861837906715377675267450287L); }

        static _Tp __2_sqrtpi() throw()
        { return static_cast<_Tp>(1.1283791670955125738961589031215452L); }

        static _Tp __sqrt2() throw()
        { return static_cast<_Tp>(1.4142135623730950488016887242096981L); }

        static _Tp __sqrt3() throw()
        { return static_cast<_Tp>(1.7320508075688772935274463415058723L); }

        static _Tp __sqrtpio2() throw()
        { return static_cast<_Tp>(1.2533141373155002512078826424055226L); }

        static _Tp __sqrt1_2() throw()
        { return static_cast<_Tp>(0.7071067811865475244008443621048490L); }

        static _Tp __lnpi() throw()
        { return static_cast<_Tp>(1.1447298858494001741434273513530587L); }

        static _Tp __gamma_e() throw()
        { return static_cast<_Tp>(0.5772156649015328606065120900824024L); }

        static _Tp __euler() throw()
        { return static_cast<_Tp>(2.7182818284590452353602874713526625L); }
      };
# 114 "/usr/include/c++/14/tr1/special_function_util.h" 3
    template<typename _Tp>
    inline bool __isnan(_Tp __x)
    { return std::isnan(__x); }
# 133 "/usr/include/c++/14/tr1/special_function_util.h" 3
  }





}
# 50 "/usr/include/c++/14/tr1/gamma.tcc" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/14/tr1/gamma.tcc" 3
  namespace __detail
  {
# 76 "/usr/include/c++/14/tr1/gamma.tcc" 3
    template <typename _Tp>
    _Tp
    __bernoulli_series(unsigned int __n)
    {

      static const _Tp __num[28] = {
        _Tp(1UL), -_Tp(1UL) / _Tp(2UL),
        _Tp(1UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(1UL) / _Tp(42UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(5UL) / _Tp(66UL), _Tp(0UL),
        -_Tp(691UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(7UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(3617UL) / _Tp(510UL), _Tp(0UL),
        _Tp(43867UL) / _Tp(798UL), _Tp(0UL),
        -_Tp(174611) / _Tp(330UL), _Tp(0UL),
        _Tp(854513UL) / _Tp(138UL), _Tp(0UL),
        -_Tp(236364091UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(8553103UL) / _Tp(6UL), _Tp(0UL)
      };

      if (__n == 0)
        return _Tp(1);

      if (__n == 1)
        return -_Tp(1) / _Tp(2);


      if (__n % 2 == 1)
        return _Tp(0);


      if (__n < 28)
        return __num[__n];


      _Tp __fact = _Tp(1);
      if ((__n / 2) % 2 == 0)
        __fact *= _Tp(-1);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __fact *= __k / (_Tp(2) * __numeric_constants<_Tp>::__pi());
      __fact *= _Tp(2);

      _Tp __sum = _Tp(0);
      for (unsigned int __i = 1; __i < 1000; ++__i)
        {
          _Tp __term = std::pow(_Tp(__i), -_Tp(__n));
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __fact * __sum;
    }
# 139 "/usr/include/c++/14/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __bernoulli(int __n)
    { return __bernoulli_series<_Tp>(__n); }
# 153 "/usr/include/c++/14/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_bernoulli(_Tp __x)
    {
      _Tp __lg = (__x - _Tp(0.5L)) * std::log(__x) - __x
               + _Tp(0.5L) * std::log(_Tp(2)
               * __numeric_constants<_Tp>::__pi());

      const _Tp __xx = __x * __x;
      _Tp __help = _Tp(1) / __x;
      for ( unsigned int __i = 1; __i < 20; ++__i )
        {
          const _Tp __2i = _Tp(2 * __i);
          __help /= __2i * (__2i - _Tp(1)) * __xx;
          __lg += __bernoulli<_Tp>(2 * __i) * __help;
        }

      return __lg;
    }
# 181 "/usr/include/c++/14/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_lanczos(_Tp __x)
    {
      const _Tp __xm1 = __x - _Tp(1);

      static const _Tp __lanczos_cheb_7[9] = {
       _Tp( 0.99999999999980993227684700473478L),
       _Tp( 676.520368121885098567009190444019L),
       _Tp(-1259.13921672240287047156078755283L),
       _Tp( 771.3234287776530788486528258894L),
       _Tp(-176.61502916214059906584551354L),
       _Tp( 12.507343278686904814458936853L),
       _Tp(-0.13857109526572011689554707L),
       _Tp( 9.984369578019570859563e-6L),
       _Tp( 1.50563273514931155834e-7L)
      };

      static const _Tp __LOGROOT2PI
          = _Tp(0.9189385332046727417803297364056176L);

      _Tp __sum = __lanczos_cheb_7[0];
      for(unsigned int __k = 1; __k < 9; ++__k)
        __sum += __lanczos_cheb_7[__k] / (__xm1 + __k);

      const _Tp __term1 = (__xm1 + _Tp(0.5L))
                        * std::log((__xm1 + _Tp(7.5L))
                       / __numeric_constants<_Tp>::__euler());
      const _Tp __term2 = __LOGROOT2PI + std::log(__sum);
      const _Tp __result = __term1 + (__term2 - _Tp(7));

      return __result;
    }
# 225 "/usr/include/c++/14/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma(_Tp __x)
    {
      if (__x > _Tp(0.5L))
        return __log_gamma_lanczos(__x);
      else
        {
          const _Tp __sin_fact
                 = std::abs(std::sin(__numeric_constants<_Tp>::__pi() * __x));
          if (__sin_fact == _Tp(0))
            std::__throw_domain_error(("Argument is nonpositive integer " "in __log_gamma")
                                                           );
          return __numeric_constants<_Tp>::__lnpi()
                     - std::log(__sin_fact)
                     - __log_gamma_lanczos(_Tp(1) - __x);
        }
    }
# 252 "/usr/include/c++/14/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_sign(_Tp __x)
    {
      if (__x > _Tp(0))
        return _Tp(1);
      else
        {
          const _Tp __sin_fact
                  = std::sin(__numeric_constants<_Tp>::__pi() * __x);
          if (__sin_fact > _Tp(0))
            return (1);
          else if (__sin_fact < _Tp(0))
            return -_Tp(1);
          else
            return _Tp(0);
        }
    }
# 283 "/usr/include/c++/14/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      _Tp __coeff = ::std::lgamma(_Tp(1 + __n))
                  - ::std::lgamma(_Tp(1 + __k))
                  - ::std::lgamma(_Tp(1 + __n - __k));





    }
# 314 "/usr/include/c++/14/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);
      if (__log_coeff > __max_bincoeff)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return std::exp(__log_coeff);
    }
# 337 "/usr/include/c++/14/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __gamma(_Tp __x)
    { return std::exp(__log_gamma(__x)); }
# 356 "/usr/include/c++/14/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_series(_Tp __x)
    {
      _Tp __sum = -__numeric_constants<_Tp>::__gamma_e() - _Tp(1) / __x;
      const unsigned int __max_iter = 100000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __x / (__k * (__k + __x));
          __sum += __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
        }
      return __sum;
    }
# 386 "/usr/include/c++/14/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_asymp(_Tp __x)
    {
      _Tp __sum = std::log(__x) - _Tp(0.5L) / __x;
      const _Tp __xx = __x * __x;
      _Tp __xp = __xx;
      const unsigned int __max_iter = 100;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __bernoulli<_Tp>(2 * __k) / (2 * __k * __xp);
          __sum -= __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
          __xp *= __xx;
        }
      return __sum;
    }
# 417 "/usr/include/c++/14/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(_Tp __x)
    {
      const int __n = static_cast<int>(__x + 0.5L);
      const _Tp __eps = _Tp(4) * std::numeric_limits<_Tp>::epsilon();
      if (__n <= 0 && std::abs(__x - _Tp(__n)) < __eps)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x < _Tp(0))
        {
          const _Tp __pi = __numeric_constants<_Tp>::__pi();
          return __psi(_Tp(1) - __x)
               - __pi * std::cos(__pi * __x) / std::sin(__pi * __x);
        }
      else if (__x > _Tp(100))
        return __psi_asymp(__x);
      else
        return __psi_series(__x);
    }
# 446 "/usr/include/c++/14/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(unsigned int __n, _Tp __x)
    {
      if (__x <= _Tp(0))
        std::__throw_domain_error(("Argument out of range " "in __psi")
                                                 );
      else if (__n == 0)
        return __psi(__x);
      else
        {
          const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);

          const _Tp __ln_nfact = ::std::lgamma(_Tp(__n + 1));



          _Tp __result = std::exp(__ln_nfact) * __hzeta;
          if (__n % 2 == 1)
            __result = -__result;
          return __result;
        }
    }
  }






}
# 48 "/usr/include/c++/14/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14/tr1/bessel_function.tcc" 1 3
# 55 "/usr/include/c++/14/tr1/bessel_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/14/tr1/bessel_function.tcc" 3
  namespace __detail
  {
# 98 "/usr/include/c++/14/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __gamma_temme(_Tp __mu,
                  _Tp & __gam1, _Tp & __gam2, _Tp & __gampl, _Tp & __gammi)
    {

      __gampl = _Tp(1) / ::std::tgamma(_Tp(1) + __mu);
      __gammi = _Tp(1) / ::std::tgamma(_Tp(1) - __mu);





      if (std::abs(__mu) < std::numeric_limits<_Tp>::epsilon())
        __gam1 = -_Tp(__numeric_constants<_Tp>::__gamma_e());
      else
        __gam1 = (__gammi - __gampl) / (_Tp(2) * __mu);

      __gam2 = (__gammi + __gampl) / (_Tp(2));

      return;
    }
# 136 "/usr/include/c++/14/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __bessel_jn(_Tp __nu, _Tp __x,
                _Tp & __Jnu, _Tp & __Nnu, _Tp & __Jpnu, _Tp & __Npnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Jnu = _Tp(1);
              __Jpnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0.5L);
            }
          else
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0);
            }
          __Nnu = -std::numeric_limits<_Tp>::infinity();
          __Npnu = std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();




      const _Tp __fp_min = std::sqrt(std::numeric_limits<_Tp>::min());
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = (__x < __x_min
                    ? static_cast<int>(__nu + _Tp(0.5L))
                    : std::max(0, static_cast<int>(__nu - __x + _Tp(1.5L))));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();
      int __isign = 1;
      _Tp __h = __nu * __xi;
      if (__h < __fp_min)
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for (__i = 1; __i <= __max_iter; ++__i)
        {
          __b += __xi2;
          __d = __b - __d;
          if (std::abs(__d) < __fp_min)
            __d = __fp_min;
          __c = __b - _Tp(1) / __c;
          if (std::abs(__c) < __fp_min)
            __c = __fp_min;
          __d = _Tp(1) / __d;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (__d < _Tp(0))
            __isign = -__isign;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large in __bessel_jn; " "try asymptotic expansion.")
                                                                   );
      _Tp __Jnul = __isign * __fp_min;
      _Tp __Jpnul = __h * __Jnul;
      _Tp __Jnul1 = __Jnul;
      _Tp __Jpnu1 = __Jpnul;
      _Tp __fact = __nu * __xi;
      for ( int __l = __nl; __l >= 1; --__l )
        {
          const _Tp __Jnutemp = __fact * __Jnul + __Jpnul;
          __fact -= __xi;
          __Jpnul = __fact * __Jnutemp - __Jnul;
          __Jnul = __Jnutemp;
        }
      if (__Jnul == _Tp(0))
        __Jnul = __eps;
      _Tp __f= __Jpnul / __Jnul;
      _Tp __Nmu, __Nnu1, __Npmu, __Jmu;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          _Tp __fact = (std::abs(__pimu) < __eps
                      ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          _Tp __fact2 = (std::abs(__e) < __eps
                       ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = (_Tp(2) / __numeric_constants<_Tp>::__pi())
                   * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          __e = std::exp(__e);
          _Tp __p = __e / (__numeric_constants<_Tp>::__pi() * __gampl);
          _Tp __q = _Tp(1) / (__e * __numeric_constants<_Tp>::__pi() * __gammi);
          const _Tp __pimu2 = __pimu / _Tp(2);
          _Tp __fact3 = (std::abs(__pimu2) < __eps
                       ? _Tp(1) : std::sin(__pimu2) / __pimu2 );
          _Tp __r = __numeric_constants<_Tp>::__pi() * __pimu2 * __fact3 * __fact3;
          _Tp __c = _Tp(1);
          __d = -__x2 * __x2;
          _Tp __sum = __ff + __r * __q;
          _Tp __sum1 = __p;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / _Tp(__i);
              __p /= _Tp(__i) - __mu;
              __q /= _Tp(__i) + __mu;
              const _Tp __del = __c * (__ff + __r * __q);
              __sum += __del;
              const _Tp __del1 = __c * __p - __i * __del;
              __sum1 += __del1;
              if ( std::abs(__del) < __eps * (_Tp(1) + std::abs(__sum)) )
                break;
            }
          if ( __i > __max_iter )
            std::__throw_runtime_error(("Bessel y series failed to converge " "in __bessel_jn.")
                                                             );
          __Nmu = -__sum;
          __Nnu1 = -__sum1 * __xi2;
          __Npmu = __mu * __xi * __Nmu - __Nnu1;
          __Jmu = __w / (__Npmu - __f * __Nmu);
        }
      else
        {
          _Tp __a = _Tp(0.25L) - __mu2;
          _Tp __q = _Tp(1);
          _Tp __p = -__xi / _Tp(2);
          _Tp __br = _Tp(2) * __x;
          _Tp __bi = _Tp(2);
          _Tp __fact = __a * __xi / (__p * __p + __q * __q);
          _Tp __cr = __br + __q * __fact;
          _Tp __ci = __bi + __p * __fact;
          _Tp __den = __br * __br + __bi * __bi;
          _Tp __dr = __br / __den;
          _Tp __di = -__bi / __den;
          _Tp __dlr = __cr * __dr - __ci * __di;
          _Tp __dli = __cr * __di + __ci * __dr;
          _Tp __temp = __p * __dlr - __q * __dli;
          __q = __p * __dli + __q * __dlr;
          __p = __temp;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a += _Tp(2 * (__i - 1));
              __bi += _Tp(2);
              __dr = __a * __dr + __br;
              __di = __a * __di + __bi;
              if (std::abs(__dr) + std::abs(__di) < __fp_min)
                __dr = __fp_min;
              __fact = __a / (__cr * __cr + __ci * __ci);
              __cr = __br + __cr * __fact;
              __ci = __bi - __ci * __fact;
              if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                __cr = __fp_min;
              __den = __dr * __dr + __di * __di;
              __dr /= __den;
              __di /= -__den;
              __dlr = __cr * __dr - __ci * __di;
              __dli = __cr * __di + __ci * __dr;
              __temp = __p * __dlr - __q * __dli;
              __q = __p * __dli + __q * __dlr;
              __p = __temp;
              if (std::abs(__dlr - _Tp(1)) + std::abs(__dli) < __eps)
                break;
          }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Lentz's method failed " "in __bessel_jn.")
                                                             );
          const _Tp __gam = (__p - __f) / __q;
          __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));

          __Jmu = ::std::copysign(__Jmu, __Jnul);




          __Nmu = __gam * __Jmu;
          __Npmu = (__p + __q / __gam) * __Nmu;
          __Nnu1 = __mu * __xi * __Nmu - __Npmu;
      }
      __fact = __Jmu / __Jnul;
      __Jnu = __fact * __Jnul1;
      __Jpnu = __fact * __Jpnu1;
      for (__i = 1; __i <= __nl; ++__i)
        {
          const _Tp __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
          __Nmu = __Nnu1;
          __Nnu1 = __Nnutemp;
        }
      __Nnu = __Nmu;
      __Npnu = __nu * __xi * __Nmu - __Nnu1;

      return;
    }
# 361 "/usr/include/c++/14/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __cyl_bessel_jn_asymp(_Tp __nu, _Tp __x, _Tp & __Jnu, _Tp & __Nnu)
    {
      const _Tp __mu = _Tp(4) * __nu * __nu;
      const _Tp __8x = _Tp(8) * __x;

      _Tp __P = _Tp(0);
      _Tp __Q = _Tp(0);

      _Tp __k = _Tp(0);
      _Tp __term = _Tp(1);

      int __epsP = 0;
      int __epsQ = 0;

      _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      do
        {
          __term *= (__k == 0
                     ? _Tp(1)
                     : -(__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));

          __epsP = std::abs(__term) < __eps * std::abs(__P);
          __P += __term;

          __k++;

          __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
          __epsQ = std::abs(__term) < __eps * std::abs(__Q);
          __Q += __term;

          if (__epsP && __epsQ && __k > (__nu / 2.))
            break;

          __k++;
        }
      while (__k < 1000);

      const _Tp __chi = __x - (__nu + _Tp(0.5L))
                             * __numeric_constants<_Tp>::__pi_2();

      const _Tp __c = std::cos(__chi);
      const _Tp __s = std::sin(__chi);

      const _Tp __coef = std::sqrt(_Tp(2)
                             / (__numeric_constants<_Tp>::__pi() * __x));

      __Jnu = __coef * (__c * __P - __s * __Q);
      __Nnu = __coef * (__s * __P + __c * __Q);

      return;
    }
# 444 "/usr/include/c++/14/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __cyl_bessel_ij_series(_Tp __nu, _Tp __x, _Tp __sgn,
                           unsigned int __max_iter)
    {
      if (__x == _Tp(0))
 return __nu == _Tp(0) ? _Tp(1) : _Tp(0);

      const _Tp __x2 = __x / _Tp(2);
      _Tp __fact = __nu * std::log(__x2);

      __fact -= ::std::lgamma(__nu + _Tp(1));



      __fact = std::exp(__fact);
      const _Tp __xx4 = __sgn * __x2 * __x2;
      _Tp __Jn = _Tp(1);
      _Tp __term = _Tp(1);

      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __xx4 / (_Tp(__i) * (__nu + _Tp(__i)));
          __Jn += __term;
          if (std::abs(__term / __Jn) < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      return __fact * __Jn;
    }
# 490 "/usr/include/c++/14/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_j(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_j.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, -_Tp(1), 200);
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __J_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __J_nu;
        }
    }
# 532 "/usr/include/c++/14/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_neumann_n(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_neumann_n.")
                                                            );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __N_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __N_nu;
        }
    }
# 569 "/usr/include/c++/14/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_jn(unsigned int __n, _Tp __x,
                    _Tp & __j_n, _Tp & __n_n, _Tp & __jp_n, _Tp & __np_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
      __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __j_n = __factor * __J_nu;
      __n_n = __factor * __N_nu;
      __jp_n = __factor * __Jp_nu - __j_n / (_Tp(2) * __x);
      __np_n = __factor * __Np_nu - __n_n / (_Tp(2) * __x);

      return;
    }
# 604 "/usr/include/c++/14/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_bessel(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_bessel.")
                                                         );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        {
          if (__n == 0)
            return _Tp(1);
          else
            return _Tp(0);
        }
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __j_n;
        }
    }
# 642 "/usr/include/c++/14/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_neumann(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_neumann.")
                                                          );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        return -std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __n_n;
        }
    }
  }






}
# 49 "/usr/include/c++/14/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14/tr1/beta_function.tcc" 1 3
# 49 "/usr/include/c++/14/tr1/beta_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/14/tr1/beta_function.tcc" 3
  namespace __detail
  {
# 79 "/usr/include/c++/14/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_gamma(_Tp __x, _Tp __y)
    {

      _Tp __bet;

      if (__x > __y)
        {
          __bet = ::std::tgamma(__x)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__y);
        }
      else
        {
          __bet = ::std::tgamma(__y)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__x);
        }
# 111 "/usr/include/c++/14/tr1/beta_function.tcc" 3
      return __bet;
    }
# 127 "/usr/include/c++/14/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_lgamma(_Tp __x, _Tp __y)
    {

      _Tp __bet = ::std::lgamma(__x)
                + ::std::lgamma(__y)
                - ::std::lgamma(__x + __y);





      __bet = std::exp(__bet);
      return __bet;
    }
# 158 "/usr/include/c++/14/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_product(_Tp __x, _Tp __y)
    {

      _Tp __bet = (__x + __y) / (__x * __y);

      unsigned int __max_iter = 1000000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          _Tp __term = (_Tp(1) + (__x + __y) / __k)
                     / ((_Tp(1) + __x / __k) * (_Tp(1) + __y / __k));
          __bet *= __term;
        }

      return __bet;
    }
# 189 "/usr/include/c++/14/tr1/beta_function.tcc" 3
    template<typename _Tp>
    inline _Tp
    __beta(_Tp __x, _Tp __y)
    {
      if (__isnan(__x) || __isnan(__y))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __beta_lgamma(__x, __y);
    }
  }






}
# 50 "/usr/include/c++/14/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14/tr1/ell_integral.tcc" 1 3
# 45 "/usr/include/c++/14/tr1/ell_integral.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 59 "/usr/include/c++/14/tr1/ell_integral.tcc" 3
  namespace __detail
  {
# 76 "/usr/include/c++/14/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rf(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = _Tp(5) * __min;

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rf.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim)
        std::__throw_domain_error(("Argument too small in __ellint_rf"));
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(24);
          const _Tp __c2 = _Tp(1) / _Tp(10);
          const _Tp __c3 = _Tp(3) / _Tp(44);
          const _Tp __c4 = _Tp(1) / _Tp(14);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps, _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn) / _Tp(3);
              __xndev = 2 - (__mu + __xn) / __mu;
              __yndev = 2 - (__mu + __yn) / __mu;
              __zndev = 2 - (__mu + __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          const _Tp __e2 = __xndev * __yndev - __zndev * __zndev;
          const _Tp __e3 = __xndev * __yndev * __zndev;
          const _Tp __s = _Tp(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2
                   + __c4 * __e3;

          return __s / std::sqrt(__mu);
        }
    }
# 153 "/usr/include/c++/14/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk / _Tp(4);
      _Tp __sum = _Tp(1) + __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          __term *= (2 * __i - 1) * __kk / (2 * __i);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __numeric_constants<_Tp>::__pi_2() * __sum;
    }
# 191 "/usr/include/c++/14/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) >= _Tp(1))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __ellint_rf(_Tp(0), _Tp(1) - __k * __k, _Tp(1));
    }
# 219 "/usr/include/c++/14/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_1(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_1."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __s = std::sin(__phi_red);
          const _Tp __c = std::cos(__phi_red);

          const _Tp __F = __s
                        * __ellint_rf(__c * __c,
                                _Tp(1) - __k * __k * __s * __s, _Tp(1));

          if (__n == 0)
            return __F;
          else
            return __F + _Tp(2) * __n * __comp_ellint_1(__k);
        }
    }
# 266 "/usr/include/c++/14/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk;
      _Tp __sum = __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          const _Tp __i2m = 2 * __i - 1;
          const _Tp __i2 = 2 * __i;
          __term *= __i2m * __i2m * __kk / (__i2 * __i2);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term / __i2m;
        }

      return __numeric_constants<_Tp>::__pi_2() * (_Tp(1) - __sum);
    }
# 314 "/usr/include/c++/14/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rd(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = _Tp(2) / std::pow(__max, _Tp(2) / _Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rd.")
                                                        );
      else if (__x + __y < __lolim || __z < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rd.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(6);
          const _Tp __c3 = _Tp(9) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + _Tp(3) * __zn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              _Tp __xnroot = std::sqrt(__xn);
              _Tp __ynroot = std::sqrt(__yn);
              _Tp __znroot = std::sqrt(__zn);
              _Tp __lambda = __xnroot * (__ynroot + __znroot)
                           + __ynroot * __znroot;
              __sigma += __power4 / (__znroot * (__zn + __lambda));
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          _Tp __ea = __xndev * __yndev;
          _Tp __eb = __zndev * __zndev;
          _Tp __ec = __ea - __eb;
          _Tp __ed = __ea - _Tp(6) * __eb;
          _Tp __ef = __ed + __ec + __ec;
          _Tp __s1 = __ed * (-__c1 + __c3 * __ed
                                   / _Tp(3) - _Tp(3) * __c4 * __zndev * __ef
                                   / _Tp(2));
          _Tp __s2 = __zndev
                   * (__c2 * __ef
                    + __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));

          return _Tp(3) * __sigma + __power4 * (_Tp(1) + __s1 + __s2)
                                        / (__mu * std::sqrt(__mu));
        }
    }
# 399 "/usr/include/c++/14/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) == 1)
        return _Tp(1);
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               - __kk * __ellint_rd(_Tp(0), _Tp(1) - __kk, _Tp(1)) / _Tp(3);
        }
    }
# 433 "/usr/include/c++/14/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_2(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_2."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __E = __s
                        * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        - __kk * __sss
                        * __ellint_rd(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        / _Tp(3);

          if (__n == 0)
            return __E;
          else
            return __E + _Tp(2) * __n * __comp_ellint_2(__k);
        }
    }
# 492 "/usr/include/c++/14/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rc(_Tp __x, _Tp __y)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = _Tp(5) * __min;

      if (__x < _Tp(0) || __y < _Tp(0) || __x + __y < __lolim)
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rc.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(7);
          const _Tp __c2 = _Tp(9) / _Tp(22);
          const _Tp __c3 = _Tp(3) / _Tp(10);
          const _Tp __c4 = _Tp(3) / _Tp(8);

          _Tp __xn = __x;
          _Tp __yn = __y;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(30), _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __sn;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + _Tp(2) * __yn) / _Tp(3);
              __sn = (__yn + __mu) / __mu - _Tp(2);
              if (std::abs(__sn) < __errtol)
                break;
              const _Tp __lambda = _Tp(2) * std::sqrt(__xn) * std::sqrt(__yn)
                             + __yn;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
            }

          _Tp __s = __sn * __sn
                  * (__c3 + __sn*(__c1 + __sn * (__c4 + __sn * __c2)));

          return (_Tp(1) + __s) / std::sqrt(__mu);
        }
    }
# 561 "/usr/include/c++/14/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rj(_Tp __x, _Tp __y, _Tp __z, _Tp __p)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = std::pow(_Tp(5) * __min, _Tp(1)/_Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rj.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim || __p < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rj")
                                                       );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(3);
          const _Tp __c3 = _Tp(3) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __pn = __p;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev, __pndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn + _Tp(2) * __pn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              __pndev = (__mu - __pn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              __epsilon = std::max(__epsilon, std::abs(__pndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              const _Tp __alpha1 = __pn * (__xnroot + __ynroot + __znroot)
                                + __xnroot * __ynroot * __znroot;
              const _Tp __alpha2 = __alpha1 * __alpha1;
              const _Tp __beta = __pn * (__pn + __lambda)
                                      * (__pn + __lambda);
              __sigma += __power4 * __ellint_rc(__alpha2, __beta);
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
              __pn = __c0 * (__pn + __lambda);
            }

          _Tp __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
          _Tp __eb = __xndev * __yndev * __zndev;
          _Tp __ec = __pndev * __pndev;
          _Tp __e2 = __ea - _Tp(3) * __ec;
          _Tp __e3 = __eb + _Tp(2) * __pndev * (__ea - __ec);
          _Tp __s1 = _Tp(1) + __e2 * (-__c1 + _Tp(3) * __c3 * __e2 / _Tp(4)
                            - _Tp(3) * __c4 * __e3 / _Tp(2));
          _Tp __s2 = __eb * (__c2 / _Tp(2)
                   + __pndev * (-__c3 - __c3 + __pndev * __c4));
          _Tp __s3 = __pndev * __ea * (__c2 - __pndev * __c3)
                   - __c2 * __pndev * __ec;

          return _Tp(3) * __sigma + __power4 * (__s1 + __s2 + __s3)
                                             / (__mu * std::sqrt(__mu));
        }
    }
# 661 "/usr/include/c++/14/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_3(_Tp __k, _Tp __nu)
    {

      if (__isnan(__k) || __isnan(__nu))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__nu == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               + __nu
               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu)
               / _Tp(3);
        }
    }
# 701 "/usr/include/c++/14/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_3(_Tp __k, _Tp __nu, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_3."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __Pi = __s
                         * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                         + __nu * __sss
                         * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),
                                       _Tp(1) - __nu * __ss) / _Tp(3);

          if (__n == 0)
            return __Pi;
          else
            return __Pi + _Tp(2) * __n * __comp_ellint_3(__k, __nu);
        }
    }
  }





}
# 51 "/usr/include/c++/14/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14/tr1/exp_integral.tcc" 1 3
# 50 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 64 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
  namespace __detail
  {
    template<typename _Tp> _Tp __expint_E1(_Tp);
# 81 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_series(_Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(0);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= - __x / __i;
          if (std::abs(__term) < __eps)
            break;
          if (__term >= _Tp(0))
            __esum += __term / __i;
          else
            __osum += __term / __i;
        }

      return - __esum - __osum
             - __numeric_constants<_Tp>::__gamma_e() - std::log(__x);
    }
# 118 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(1);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= - __i / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          if (__term >= _Tp(0))
            __esum += __term;
          else
            __osum += __term;
        }

      return std::exp(- __x) * (__esum + __osum) / __x;
    }
# 155 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_series(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const int __nm1 = __n - 1;
      _Tp __ans = (__nm1 != 0
                ? _Tp(1) / __nm1 : -std::log(__x)
                                   - __numeric_constants<_Tp>::__gamma_e());
      _Tp __fact = _Tp(1);
      for (int __i = 1; __i <= __max_iter; ++__i)
        {
          __fact *= -__x / _Tp(__i);
          _Tp __del;
          if ( __i != __nm1 )
            __del = -__fact / _Tp(__i - __nm1);
          else
            {
              _Tp __psi = -__numeric_constants<_Tp>::gamma_e();
              for (int __ii = 1; __ii <= __nm1; ++__ii)
                __psi += _Tp(1) / _Tp(__ii);
              __del = __fact * (__psi - std::log(__x));
            }
          __ans += __del;
          if (std::abs(__del) < __eps * std::abs(__ans))
            return __ans;
        }
      std::__throw_runtime_error(("Series summation failed " "in __expint_En_series.")
                                                              );
    }
# 201 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_cont_frac(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = std::numeric_limits<_Tp>::min();
      const int __nm1 = __n - 1;
      _Tp __b = __x + _Tp(__n);
      _Tp __c = _Tp(1) / __fp_min;
      _Tp __d = _Tp(1) / __b;
      _Tp __h = __d;
      for ( unsigned int __i = 1; __i <= __max_iter; ++__i )
        {
          _Tp __a = -_Tp(__i * (__nm1 + __i));
          __b += _Tp(2);
          __d = _Tp(1) / (__a * __d + __b);
          __c = __b + __a / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            {
              const _Tp __ans = __h * std::exp(-__x);
              return __ans;
            }
        }
      std::__throw_runtime_error(("Continued fraction failed " "in __expint_En_cont_frac.")
                                                                 );
    }
# 246 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_recursion(unsigned int __n, _Tp __x)
    {
      _Tp __En;
      _Tp __E1 = __expint_E1(__x);
      if (__x < _Tp(__n))
        {

          __En = __E1;
          for (unsigned int __j = 2; __j < __n; ++__j)
            __En = (std::exp(-__x) - __x * __En) / _Tp(__j - 1);
        }
      else
        {

          __En = _Tp(1);
          const int __N = __n + 20;
          _Tp __save = _Tp(0);
          for (int __j = __N; __j > 0; --__j)
            {
              __En = (std::exp(-__x) - __j * __En) / __x;
              if (__j == __n)
                __save = __En;
            }
            _Tp __norm = __En / __E1;
            __En /= __norm;
        }

      return __En;
    }
# 290 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_series(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __x / __i;
          __sum += __term / __i;
          if (__term < std::numeric_limits<_Tp>::epsilon() * __sum)
            break;
        }

      return __numeric_constants<_Tp>::__gamma_e() + __sum + std::log(__x);
    }
# 321 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= __i / __x;
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          if (__term >= __prev)
            break;
          __sum += __term;
        }

      return std::exp(__x) * __sum / __x;
    }
# 354 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_E1(-__x);
      else if (__x < -std::log(std::numeric_limits<_Tp>::epsilon()))
        return __expint_Ei_series(__x);
      else
        return __expint_Ei_asymp(__x);
    }
# 378 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_Ei(-__x);
      else if (__x < _Tp(1))
        return __expint_E1_series(__x);
      else if (__x < _Tp(100))
        return __expint_En_cont_frac(1, __x);
      else
        return __expint_E1_asymp(__x);
    }
# 408 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_asymp(unsigned int __n, _Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= -(__n - __i + 1) / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __x;
    }
# 442 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_large_n(unsigned int __n, _Tp __x)
    {
      const _Tp __xpn = __x + __n;
      const _Tp __xpn2 = __xpn * __xpn;
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= (__n - 2 * (__i - 1) * __x) / __xpn2;
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __xpn;
    }
# 476 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint(unsigned int __n, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n <= 1 && __x == _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __E0 = std::exp(__x) / __x;
          if (__n == 0)
            return __E0;

          _Tp __E1 = __expint_E1(__x);
          if (__n == 1)
            return __E1;

          if (__x == _Tp(0))
            return _Tp(1) / static_cast<_Tp>(__n - 1);

          _Tp __En = __expint_En_recursion(__n, __x);

          return __En;
        }
    }
# 516 "/usr/include/c++/14/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    inline _Tp
    __expint(_Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __expint_Ei(__x);
    }
  }





}
# 52 "/usr/include/c++/14/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14/tr1/hypergeometric.tcc" 1 3
# 44 "/usr/include/c++/14/tr1/hypergeometric.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/include/c++/14/tr1/hypergeometric.tcc" 3
  namespace __detail
  {
# 83 "/usr/include/c++/14/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_series(_Tp __a, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fac = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fac += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __conf_hyperg_series.")
                                                                  );

      return __Fac;
    }
# 120 "/usr/include/c++/14/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_luke(_Tp __a, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a / __c;
      const _Tp __t1 = (__a + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
      _Tp __F = _Tp(1);
      _Tp __prec;

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while(1)
        {
          _Tp __npam1 = _Tp(__n - 1) + __a;
          _Tp __npcm1 = _Tp(__n - 1) + __c;
          _Tp __npam2 = _Tp(__n - 2) + __a;
          _Tp __npcm2 = _Tp(__n - 2) + __c;
          _Tp __tnm1 = _Tp(2 * __n - 1);
          _Tp __tnm3 = _Tp(2 * __n - 3);
          _Tp __tnm5 = _Tp(2 * __n - 5);
          _Tp __F1 = (_Tp(__n - 2) - __a) / (_Tp(2) * __tnm3 * __npcm1);
          _Tp __F2 = (_Tp(__n) + __a) * __npam1
                   / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          _Tp __F3 = -__npam2 * __npam1 * (_Tp(__n - 2) - __a)
                   / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                   * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          _Tp __E = -__npam1 * (_Tp(__n - 1) - __c)
                   / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          _Tp __r = __An / __Bn;

          __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __conf_hyperg_luke.")
                                                                );

      return __F;
    }
# 227 "/usr/include/c++/14/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg(_Tp __a, _Tp __c, _Tp __x)
    {

      const _Tp __c_nint = ::std::nearbyint(__c);



      if (__isnan(__a) || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= 0)
        return std::numeric_limits<_Tp>::infinity();
      else if (__a == _Tp(0))
        return _Tp(1);
      else if (__c == __a)
        return std::exp(__x);
      else if (__x < _Tp(0))
        return __conf_hyperg_luke(__a, __c, __x);
      else
        return __conf_hyperg_series(__a, __c, __x);
    }
# 271 "/usr/include/c++/14/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_series(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fabc = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * (__b + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fabc += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __hyperg_series.")
                                                             );

      return __Fabc;
    }







    template<typename _Tp>
    _Tp
    __hyperg_luke(_Tp __a, _Tp __b, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a * __b / __c;
      const _Tp __t1 = (__a + _Tp(1)) * (__b + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) * (__b + _Tp(2))
                     / (_Tp(2) * (__c + _Tp(1)));

      _Tp __F = _Tp(1);

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while (1)
        {
          const _Tp __npam1 = _Tp(__n - 1) + __a;
          const _Tp __npbm1 = _Tp(__n - 1) + __b;
          const _Tp __npcm1 = _Tp(__n - 1) + __c;
          const _Tp __npam2 = _Tp(__n - 2) + __a;
          const _Tp __npbm2 = _Tp(__n - 2) + __b;
          const _Tp __npcm2 = _Tp(__n - 2) + __c;
          const _Tp __tnm1 = _Tp(2 * __n - 1);
          const _Tp __tnm3 = _Tp(2 * __n - 3);
          const _Tp __tnm5 = _Tp(2 * __n - 5);
          const _Tp __n2 = __n * __n;
          const _Tp __F1 = (_Tp(3) * __n2 + (__a + __b - _Tp(6)) * __n
                         + _Tp(2) - __a * __b - _Tp(2) * (__a + __b))
                         / (_Tp(2) * __tnm3 * __npcm1);
          const _Tp __F2 = -(_Tp(3) * __n2 - (__a + __b + _Tp(6)) * __n
                         + _Tp(2) - __a * __b) * __npam1 * __npbm1
                         / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          const _Tp __F3 = (__npam2 * __npam1 * __npbm2 * __npbm1
                         * (_Tp(__n - 2) - __a) * (_Tp(__n - 2) - __b))
                         / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                         * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          const _Tp __E = -__npam1 * __npbm1 * (_Tp(__n - 1) - __c)
                         / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          const _Tp __r = __An / __Bn;

          const _Tp __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __hyperg_luke.")
                                                           );

      return __F;
    }
# 438 "/usr/include/c++/14/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_reflect(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __d = __c - __a - __b;
      const int __intd = std::floor(__d + _Tp(0.5L));
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __toler = _Tp(1000) * __eps;
      const _Tp __log_max = std::log(std::numeric_limits<_Tp>::max());
      const bool __d_integer = (std::abs(__d - __intd) < __toler);

      if (__d_integer)
        {
          const _Tp __ln_omx = std::log(_Tp(1) - __x);
          const _Tp __ad = std::abs(__d);
          _Tp __F1, __F2;

          _Tp __d1, __d2;
          if (__d >= _Tp(0))
            {
              __d1 = __d;
              __d2 = _Tp(0);
            }
          else
            {
              __d1 = _Tp(0);
              __d2 = __d;
            }

          const _Tp __lng_c = __log_gamma(__c);


          if (__ad < __eps)
            {

              __F1 = _Tp(0);
            }
          else
            {

              bool __ok_d1 = true;
              _Tp __lng_ad, __lng_ad1, __lng_bd1;
              try
                {
                  __lng_ad = __log_gamma(__ad);
                  __lng_ad1 = __log_gamma(__a + __d1);
                  __lng_bd1 = __log_gamma(__b + __d1);
                }
              catch(...)
                {
                  __ok_d1 = false;
                }

              if (__ok_d1)
                {



                  _Tp __sum1 = _Tp(1);
                  _Tp __term = _Tp(1);
                  _Tp __ln_pre1 = __lng_ad + __lng_c + __d2 * __ln_omx
                                - __lng_ad1 - __lng_bd1;



                  for (int __i = 1; __i < __ad; ++__i)
                    {
                      const int __j = __i - 1;
                      __term *= (__a + __d2 + __j) * (__b + __d2 + __j)
                              / (_Tp(1) + __d2 + __j) / __i * (_Tp(1) - __x);
                      __sum1 += __term;
                    }

                  if (__ln_pre1 > __log_max)
                    std::__throw_runtime_error(("Overflow of gamma functions" " in __hyperg_luke.")
                                                                        );
                  else
                    __F1 = std::exp(__ln_pre1) * __sum1;
                }
              else
                {


                  __F1 = _Tp(0);
                }
            }


          bool __ok_d2 = true;
          _Tp __lng_ad2, __lng_bd2;
          try
            {
              __lng_ad2 = __log_gamma(__a + __d2);
              __lng_bd2 = __log_gamma(__b + __d2);
            }
          catch(...)
            {
              __ok_d2 = false;
            }

          if (__ok_d2)
            {


              const int __maxiter = 2000;
              const _Tp __psi_1 = -__numeric_constants<_Tp>::__gamma_e();
              const _Tp __psi_1pd = __psi(_Tp(1) + __ad);
              const _Tp __psi_apd1 = __psi(__a + __d1);
              const _Tp __psi_bpd1 = __psi(__b + __d1);

              _Tp __psi_term = __psi_1 + __psi_1pd - __psi_apd1
                             - __psi_bpd1 - __ln_omx;
              _Tp __fact = _Tp(1);
              _Tp __sum2 = __psi_term;
              _Tp __ln_pre2 = __lng_c + __d1 * __ln_omx
                            - __lng_ad2 - __lng_bd2;


              int __j;
              for (__j = 1; __j < __maxiter; ++__j)
                {


                  const _Tp __term1 = _Tp(1) / _Tp(__j)
                                    + _Tp(1) / (__ad + __j);
                  const _Tp __term2 = _Tp(1) / (__a + __d1 + _Tp(__j - 1))
                                    + _Tp(1) / (__b + __d1 + _Tp(__j - 1));
                  __psi_term += __term1 - __term2;
                  __fact *= (__a + __d1 + _Tp(__j - 1))
                          * (__b + __d1 + _Tp(__j - 1))
                          / ((__ad + __j) * __j) * (_Tp(1) - __x);
                  const _Tp __delta = __fact * __psi_term;
                  __sum2 += __delta;
                  if (std::abs(__delta) < __eps * std::abs(__sum2))
                    break;
                }
              if (__j == __maxiter)
                std::__throw_runtime_error(("Sum F2 failed to converge " "in __hyperg_reflect")
                                                                     );

              if (__sum2 == _Tp(0))
                __F2 = _Tp(0);
              else
                __F2 = std::exp(__ln_pre2) * __sum2;
            }
          else
            {


              __F2 = _Tp(0);
            }

          const _Tp __sgn_2 = (__intd % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __F = __F1 + __sgn_2 * __F2;

          return __F;
        }
      else
        {




          bool __ok1 = true;
          _Tp __sgn_g1ca = _Tp(0), __ln_g1ca = _Tp(0);
          _Tp __sgn_g1cb = _Tp(0), __ln_g1cb = _Tp(0);
          try
            {
              __sgn_g1ca = __log_gamma_sign(__c - __a);
              __ln_g1ca = __log_gamma(__c - __a);
              __sgn_g1cb = __log_gamma_sign(__c - __b);
              __ln_g1cb = __log_gamma(__c - __b);
            }
          catch(...)
            {
              __ok1 = false;
            }

          bool __ok2 = true;
          _Tp __sgn_g2a = _Tp(0), __ln_g2a = _Tp(0);
          _Tp __sgn_g2b = _Tp(0), __ln_g2b = _Tp(0);
          try
            {
              __sgn_g2a = __log_gamma_sign(__a);
              __ln_g2a = __log_gamma(__a);
              __sgn_g2b = __log_gamma_sign(__b);
              __ln_g2b = __log_gamma(__b);
            }
          catch(...)
            {
              __ok2 = false;
            }

          const _Tp __sgn_gc = __log_gamma_sign(__c);
          const _Tp __ln_gc = __log_gamma(__c);
          const _Tp __sgn_gd = __log_gamma_sign(__d);
          const _Tp __ln_gd = __log_gamma(__d);
          const _Tp __sgn_gmd = __log_gamma_sign(-__d);
          const _Tp __ln_gmd = __log_gamma(-__d);

          const _Tp __sgn1 = __sgn_gc * __sgn_gd * __sgn_g1ca * __sgn_g1cb;
          const _Tp __sgn2 = __sgn_gc * __sgn_gmd * __sgn_g2a * __sgn_g2b;

          _Tp __pre1, __pre2;
          if (__ok1 && __ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre1 < __log_max && __ln_pre2 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre2 = std::exp(__ln_pre2);
                  __pre1 *= __sgn1;
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (__ok1 && !__ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              if (__ln_pre1 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre1 *= __sgn1;
                  __pre2 = _Tp(0);
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (!__ok1 && __ok2)
            {
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre2 < __log_max)
                {
                  __pre1 = _Tp(0);
                  __pre2 = std::exp(__ln_pre2);
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else
            {
              __pre1 = _Tp(0);
              __pre2 = _Tp(0);
              std::__throw_runtime_error(("Underflow of gamma functions " "in __hyperg_reflect")
                                                                   );
            }

          const _Tp __F1 = __hyperg_series(__a, __b, _Tp(1) - __d,
                                           _Tp(1) - __x);
          const _Tp __F2 = __hyperg_series(__c - __a, __c - __b, _Tp(1) + __d,
                                           _Tp(1) - __x);

          const _Tp __F = __pre1 * __F1 + __pre2 * __F2;

          return __F;
        }
    }
# 728 "/usr/include/c++/14/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {

      const _Tp __a_nint = ::std::nearbyint(__a);
      const _Tp __b_nint = ::std::nearbyint(__b);
      const _Tp __c_nint = ::std::nearbyint(__c);





      const _Tp __toler = _Tp(1000) * std::numeric_limits<_Tp>::epsilon();
      if (std::abs(__x) >= _Tp(1))
        std::__throw_domain_error(("Argument outside unit circle " "in __hyperg.")
                                                     );
      else if (__isnan(__a) || __isnan(__b)
            || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__c - __b) < __toler || std::abs(__c - __a) < __toler)
        return std::pow(_Tp(1) - __x, __c - __a - __b);
      else if (__a >= _Tp(0) && __b >= _Tp(0) && __c >= _Tp(0)
            && __x >= _Tp(0) && __x < _Tp(0.995L))
        return __hyperg_series(__a, __b, __c, __x);
      else if (std::abs(__a) < _Tp(10) && std::abs(__b) < _Tp(10))
        {


          if (__a < _Tp(0) && std::abs(__a - __a_nint) < __toler)
            return __hyperg_series(__a_nint, __b, __c, __x);
          else if (__b < _Tp(0) && std::abs(__b - __b_nint) < __toler)
            return __hyperg_series(__a, __b_nint, __c, __x);
          else if (__x < -_Tp(0.25L))
            return __hyperg_luke(__a, __b, __c, __x);
          else if (__x < _Tp(0.5L))
            return __hyperg_series(__a, __b, __c, __x);
          else
            if (std::abs(__c) > _Tp(10))
              return __hyperg_series(__a, __b, __c, __x);
            else
              return __hyperg_reflect(__a, __b, __c, __x);
        }
      else
        return __hyperg_luke(__a, __b, __c, __x);
    }
  }






}
# 53 "/usr/include/c++/14/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14/tr1/legendre_function.tcc" 1 3
# 49 "/usr/include/c++/14/tr1/legendre_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/14/tr1/legendre_function.tcc" 3
  namespace __detail
  {
# 80 "/usr/include/c++/14/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_legendre_p(unsigned int __l, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == +_Tp(1))
        return +_Tp(1);
      else if (__x == -_Tp(1))
        return (__l % 2 == 1 ? -_Tp(1) : +_Tp(1));
      else
        {
          _Tp __p_lm2 = _Tp(1);
          if (__l == 0)
            return __p_lm2;

          _Tp __p_lm1 = __x;
          if (__l == 1)
            return __p_lm1;

          _Tp __p_l = 0;
          for (unsigned int __ll = 2; __ll <= __l; ++__ll)
            {


              __p_l = _Tp(2) * __x * __p_lm1 - __p_lm2
                    - (__x * __p_lm1 - __p_lm2) / _Tp(__ll);
              __p_lm2 = __p_lm1;
              __p_lm1 = __p_l;
            }

          return __p_l;
        }
    }
# 136 "/usr/include/c++/14/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __assoc_legendre_p(unsigned int __l, unsigned int __m, _Tp __x,
         _Tp __phase = _Tp(+1))
    {

      if (__m > __l)
        return _Tp(0);
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__m == 0)
        return __poly_legendre_p(__l, __x);
      else
        {
          _Tp __p_mm = _Tp(1);
          if (__m > 0)
            {


              _Tp __root = std::sqrt(_Tp(1) - __x) * std::sqrt(_Tp(1) + __x);
              _Tp __fact = _Tp(1);
              for (unsigned int __i = 1; __i <= __m; ++__i)
                {
                  __p_mm *= __phase * __fact * __root;
                  __fact += _Tp(2);
                }
            }
          if (__l == __m)
            return __p_mm;

          _Tp __p_mp1m = _Tp(2 * __m + 1) * __x * __p_mm;
          if (__l == __m + 1)
            return __p_mp1m;

          _Tp __p_lm2m = __p_mm;
          _Tp __P_lm1m = __p_mp1m;
          _Tp __p_lm = _Tp(0);
          for (unsigned int __j = __m + 2; __j <= __l; ++__j)
            {
              __p_lm = (_Tp(2 * __j - 1) * __x * __P_lm1m
                      - _Tp(__j + __m - 1) * __p_lm2m) / _Tp(__j - __m);
              __p_lm2m = __P_lm1m;
              __P_lm1m = __p_lm;
            }

          return __p_lm;
        }
    }
# 214 "/usr/include/c++/14/tr1/legendre_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      if (__isnan(__theta))
        return std::numeric_limits<_Tp>::quiet_NaN();

      const _Tp __x = std::cos(__theta);

      if (__m > __l)
        return _Tp(0);
      else if (__m == 0)
        {
          _Tp __P = __poly_legendre_p(__l, __x);
          _Tp __fact = std::sqrt(_Tp(2 * __l + 1)
                     / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          __P *= __fact;
          return __P;
        }
      else if (__x == _Tp(1) || __x == -_Tp(1))
        {

          return _Tp(0);
        }
      else
        {





          const _Tp __sgn = ( __m % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));

          const _Tp __lncirc = ::std::log1p(-__x * __x);





          const _Tp __lnpoch = ::std::lgamma(_Tp(__m + _Tp(0.5L)))
                             - ::std::lgamma(_Tp(__m));




          const _Tp __lnpre_val =
                    -_Tp(0.25L) * __numeric_constants<_Tp>::__lnpi()
                    + _Tp(0.5L) * (__lnpoch + __m * __lncirc);
          const _Tp __sr = std::sqrt((_Tp(2) + _Tp(1) / __m)
                         / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          _Tp __y_mm = __sgn * __sr * std::exp(__lnpre_val);
          _Tp __y_mp1m = __y_mp1m_factor * __y_mm;

          if (__l == __m)
            return __y_mm;
          else if (__l == __m + 1)
            return __y_mp1m;
          else
            {
              _Tp __y_lm = _Tp(0);


              for (unsigned int __ll = __m + 2; __ll <= __l; ++__ll)
                {
                  const _Tp __rat1 = _Tp(__ll - __m) / _Tp(__ll + __m);
                  const _Tp __rat2 = _Tp(__ll - __m - 1) / _Tp(__ll + __m - 1);
                  const _Tp __fact1 = std::sqrt(__rat1 * _Tp(2 * __ll + 1)
                                                       * _Tp(2 * __ll - 1));
                  const _Tp __fact2 = std::sqrt(__rat1 * __rat2 * _Tp(2 * __ll + 1)
                                                                / _Tp(2 * __ll - 3));
                  __y_lm = (__x * __y_mp1m * __fact1
                         - (__ll + __m - 1) * __y_mm * __fact2) / _Tp(__ll - __m);
                  __y_mm = __y_mp1m;
                  __y_mp1m = __y_lm;
                }

              return __y_lm;
            }
        }
    }
  }






}
# 54 "/usr/include/c++/14/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14/tr1/modified_bessel_func.tcc" 1 3
# 51 "/usr/include/c++/14/tr1/modified_bessel_func.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/14/tr1/modified_bessel_func.tcc" 3
  namespace __detail
  {
# 83 "/usr/include/c++/14/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __bessel_ik(_Tp __nu, _Tp __x,
                _Tp & __Inu, _Tp & __Knu, _Tp & __Ipnu, _Tp & __Kpnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Inu = _Tp(1);
              __Ipnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0.5L);
            }
          else
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0);
            }
          __Knu = std::numeric_limits<_Tp>::infinity();
          __Kpnu = -std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = _Tp(10) * std::numeric_limits<_Tp>::epsilon();
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = static_cast<int>(__nu + _Tp(0.5L));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __h = __nu * __xi;
      if ( __h < __fp_min )
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for ( __i = 1; __i <= __max_iter; ++__i )
        {
          __b += __xi2;
          __d = _Tp(1) / (__b + __d);
          __c = __b + _Tp(1) / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large " "in __bessel_ik; " "try asymptotic expansion.")

                                                                   );
      _Tp __Inul = __fp_min;
      _Tp __Ipnul = __h * __Inul;
      _Tp __Inul1 = __Inul;
      _Tp __Ipnu1 = __Ipnul;
      _Tp __fact = __nu * __xi;
      for (int __l = __nl; __l >= 1; --__l)
        {
          const _Tp __Inutemp = __fact * __Inul + __Ipnul;
          __fact -= __xi;
          __Ipnul = __fact * __Inutemp + __Inul;
          __Inul = __Inutemp;
        }
      _Tp __f = __Ipnul / __Inul;
      _Tp __Kmu, __Knu1;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          const _Tp __fact = (std::abs(__pimu) < __eps
                            ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          const _Tp __fact2 = (std::abs(__e) < __eps
                            ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = __fact
                   * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          _Tp __sum = __ff;
          __e = std::exp(__e);
          _Tp __p = __e / (_Tp(2) * __gampl);
          _Tp __q = _Tp(1) / (_Tp(2) * __e * __gammi);
          _Tp __c = _Tp(1);
          __d = __x2 * __x2;
          _Tp __sum1 = __p;
          int __i;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / __i;
              __p /= __i - __mu;
              __q /= __i + __mu;
              const _Tp __del = __c * __ff;
              __sum += __del;
              const _Tp __del1 = __c * (__p - __i * __ff);
              __sum1 += __del1;
              if (std::abs(__del) < __eps * std::abs(__sum))
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Bessel k series failed to converge " "in __bessel_ik.")
                                                             );
          __Kmu = __sum;
          __Knu1 = __sum1 * __xi2;
        }
      else
        {
          _Tp __b = _Tp(2) * (_Tp(1) + __x);
          _Tp __d = _Tp(1) / __b;
          _Tp __delh = __d;
          _Tp __h = __delh;
          _Tp __q1 = _Tp(0);
          _Tp __q2 = _Tp(1);
          _Tp __a1 = _Tp(0.25L) - __mu2;
          _Tp __q = __c = __a1;
          _Tp __a = -__a1;
          _Tp __s = _Tp(1) + __q * __delh;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a -= 2 * (__i - 1);
              __c = -__a * __c / __i;
              const _Tp __qnew = (__q1 - __b * __q2) / __a;
              __q1 = __q2;
              __q2 = __qnew;
              __q += __c * __qnew;
              __b += _Tp(2);
              __d = _Tp(1) / (__b + __a * __d);
              __delh = (__b * __d - _Tp(1)) * __delh;
              __h += __delh;
              const _Tp __dels = __q * __delh;
              __s += __dels;
              if ( std::abs(__dels / __s) < __eps )
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Steed's method failed " "in __bessel_ik.")
                                                             );
          __h = __a1 * __h;
          __Kmu = std::sqrt(__numeric_constants<_Tp>::__pi() / (_Tp(2) * __x))
                * std::exp(-__x) / __s;
          __Knu1 = __Kmu * (__mu + __x + _Tp(0.5L) - __h) * __xi;
        }

      _Tp __Kpmu = __mu * __xi * __Kmu - __Knu1;
      _Tp __Inumu = __xi / (__f * __Kmu - __Kpmu);
      __Inu = __Inumu * __Inul1 / __Inul;
      __Ipnu = __Inumu * __Ipnu1 / __Inul;
      for ( __i = 1; __i <= __nl; ++__i )
        {
          const _Tp __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
          __Kmu = __Knu1;
          __Knu1 = __Knutemp;
        }
      __Knu = __Kmu;
      __Kpnu = __nu * __xi * __Kmu - __Knu1;

      return;
    }
# 267 "/usr/include/c++/14/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_i(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_i.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, +_Tp(1), 200);
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __I_nu;
        }
    }
# 303 "/usr/include/c++/14/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_k(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_k.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __K_nu;
        }
    }
# 337 "/usr/include/c++/14/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_ik(unsigned int __n, _Tp __x,
                    _Tp & __i_n, _Tp & __k_n, _Tp & __ip_n, _Tp & __kp_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
      __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __i_n = __factor * __I_nu;
      __k_n = __factor * __K_nu;
      __ip_n = __factor * __Ip_nu - __i_n / (_Tp(2) * __x);
      __kp_n = __factor * __Kp_nu - __k_n / (_Tp(2) * __x);

      return;
    }
# 373 "/usr/include/c++/14/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __airy(_Tp __x, _Tp & __Ai, _Tp & __Bi, _Tp & __Aip, _Tp & __Bip)
    {
      const _Tp __absx = std::abs(__x);
      const _Tp __rootx = std::sqrt(__absx);
      const _Tp __z = _Tp(2) * __absx * __rootx / _Tp(3);
      const _Tp _S_inf = std::numeric_limits<_Tp>::infinity();

      if (__isnan(__x))
        __Bip = __Aip = __Bi = __Ai = std::numeric_limits<_Tp>::quiet_NaN();
      else if (__z == _S_inf)
        {
   __Aip = __Ai = _Tp(0);
   __Bip = __Bi = _S_inf;
 }
      else if (__z == -_S_inf)
 __Bip = __Aip = __Bi = __Ai = _Tp(0);
      else if (__x > _Tp(0))
        {
          _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;

          __bessel_ik(_Tp(1) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Ai = __rootx * __K_nu
               / (__numeric_constants<_Tp>::__sqrt3()
                * __numeric_constants<_Tp>::__pi());
          __Bi = __rootx * (__K_nu / __numeric_constants<_Tp>::__pi()
                 + _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());

          __bessel_ik(_Tp(2) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Aip = -__x * __K_nu
                / (__numeric_constants<_Tp>::__sqrt3()
                 * __numeric_constants<_Tp>::__pi());
          __Bip = __x * (__K_nu / __numeric_constants<_Tp>::__pi()
                      + _Tp(2) * __I_nu
                      / __numeric_constants<_Tp>::__sqrt3());
        }
      else if (__x < _Tp(0))
        {
          _Tp __J_nu, __Jp_nu, __N_nu, __Np_nu;

          __bessel_jn(_Tp(1) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Ai = __rootx * (__J_nu
                    - __N_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);
          __Bi = -__rootx * (__N_nu
                    + __J_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);

          __bessel_jn(_Tp(2) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Aip = __absx * (__N_nu / __numeric_constants<_Tp>::__sqrt3()
                          + __J_nu) / _Tp(2);
          __Bip = __absx * (__J_nu / __numeric_constants<_Tp>::__sqrt3()
                          - __N_nu) / _Tp(2);
        }
      else
        {



          __Ai = _Tp(0.35502805388781723926L);
          __Bi = __Ai * __numeric_constants<_Tp>::__sqrt3();




          __Aip = -_Tp(0.25881940379280679840L);
          __Bip = -__Aip * __numeric_constants<_Tp>::__sqrt3();
        }

      return;
    }
  }





}
# 55 "/usr/include/c++/14/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14/tr1/poly_hermite.tcc" 1 3
# 42 "/usr/include/c++/14/tr1/poly_hermite.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/14/tr1/poly_hermite.tcc" 3
  namespace __detail
  {
# 72 "/usr/include/c++/14/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_hermite_recursion(unsigned int __n, _Tp __x)
    {

      _Tp __H_0 = 1;
      if (__n == 0)
        return __H_0;


      _Tp __H_1 = 2 * __x;
      if (__n == 1)
        return __H_1;


      _Tp __H_n, __H_nm1, __H_nm2;
      unsigned int __i;
      for (__H_nm2 = __H_0, __H_nm1 = __H_1, __i = 2; __i <= __n; ++__i)
        {
          __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
          __H_nm2 = __H_nm1;
          __H_nm1 = __H_n;
        }

      return __H_n;
    }
# 114 "/usr/include/c++/14/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    inline _Tp
    __poly_hermite(unsigned int __n, _Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __poly_hermite_recursion(__n, __x);
    }
  }





}
# 56 "/usr/include/c++/14/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14/tr1/poly_laguerre.tcc" 1 3
# 44 "/usr/include/c++/14/tr1/poly_laguerre.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/include/c++/14/tr1/poly_laguerre.tcc" 3
  namespace __detail
  {
# 75 "/usr/include/c++/14/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_large_n(unsigned __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __a = -_Tp(__n);
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __eta = _Tp(2) * __b - _Tp(4) * __a;
      const _Tp __cos2th = __x / __eta;
      const _Tp __sin2th = _Tp(1) - __cos2th;
      const _Tp __th = std::acos(std::sqrt(__cos2th));
      const _Tp __pre_h = __numeric_constants<_Tp>::__pi_2()
                        * __numeric_constants<_Tp>::__pi_2()
                        * __eta * __eta * __cos2th * __sin2th;


      const _Tp __lg_b = ::std::lgamma(_Tp(__n) + __b);
      const _Tp __lnfact = ::std::lgamma(_Tp(__n + 1));





      _Tp __pre_term1 = _Tp(0.5L) * (_Tp(1) - __b)
                      * std::log(_Tp(0.25L) * __x * __eta);
      _Tp __pre_term2 = _Tp(0.25L) * std::log(__pre_h);
      _Tp __lnpre = __lg_b - __lnfact + _Tp(0.5L) * __x
                      + __pre_term1 - __pre_term2;
      _Tp __ser_term1 = std::sin(__a * __numeric_constants<_Tp>::__pi());
      _Tp __ser_term2 = std::sin(_Tp(0.25L) * __eta
                              * (_Tp(2) * __th
                               - std::sin(_Tp(2) * __th))
                               + __numeric_constants<_Tp>::__pi_4());
      _Tp __ser = __ser_term1 + __ser_term2;

      return std::exp(__lnpre) * __ser;
    }
# 129 "/usr/include/c++/14/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_hyperg(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __mx = -__x;
      const _Tp __tc_sgn = (__x < _Tp(0) ? _Tp(1)
                         : ((__n % 2 == 1) ? -_Tp(1) : _Tp(1)));

      _Tp __tc = _Tp(1);
      const _Tp __ax = std::abs(__x);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __tc *= (__ax / __k);

      _Tp __term = __tc * __tc_sgn;
      _Tp __sum = __term;
      for (int __k = int(__n) - 1; __k >= 0; --__k)
        {
          __term *= ((__b + _Tp(__k)) / _Tp(int(__n) - __k))
                  * _Tp(__k + 1) / __mx;
          __sum += __term;
        }

      return __sum;
    }
# 185 "/usr/include/c++/14/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_recursion(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {

      _Tp __l_0 = _Tp(1);
      if (__n == 0)
        return __l_0;


      _Tp __l_1 = -__x + _Tp(1) + _Tp(__alpha1);
      if (__n == 1)
        return __l_1;


      _Tp __l_n2 = __l_0;
      _Tp __l_n1 = __l_1;
      _Tp __l_n = _Tp(0);
      for (unsigned int __nn = 2; __nn <= __n; ++__nn)
        {
            __l_n = (_Tp(2 * __nn - 1) + _Tp(__alpha1) - __x)
                  * __l_n1 / _Tp(__nn)
                  - (_Tp(__nn - 1) + _Tp(__alpha1)) * __l_n2 / _Tp(__nn);
            __l_n2 = __l_n1;
            __l_n1 = __l_n;
        }

      return __l_n;
    }
# 244 "/usr/include/c++/14/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Negative argument " "in __poly_laguerre.")
                                                            );

      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n == 0)
        return _Tp(1);
      else if (__n == 1)
        return _Tp(1) + _Tp(__alpha1) - __x;
      else if (__x == _Tp(0))
        {
          _Tp __prod = _Tp(__alpha1) + _Tp(1);
          for (unsigned int __k = 2; __k <= __n; ++__k)
            __prod *= (_Tp(__alpha1) + _Tp(__k)) / _Tp(__k);
          return __prod;
        }
      else if (__n > 10000000 && _Tp(__alpha1) > -_Tp(1)
            && __x < _Tp(2) * (_Tp(__alpha1) + _Tp(1)) + _Tp(4 * __n))
        return __poly_laguerre_large_n(__n, __alpha1, __x);
      else if (_Tp(__alpha1) >= _Tp(0)
           || (__x > _Tp(0) && _Tp(__alpha1) < -_Tp(__n + 1)))
        return __poly_laguerre_recursion(__n, __alpha1, __x);
      else
        return __poly_laguerre_hyperg(__n, __alpha1, __x);
    }
# 296 "/usr/include/c++/14/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, __m, __x); }
# 316 "/usr/include/c++/14/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __laguerre(unsigned int __n, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, 0, __x); }
  }






}
# 57 "/usr/include/c++/14/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14/tr1/riemann_zeta.tcc" 1 3
# 47 "/usr/include/c++/14/tr1/riemann_zeta.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/14/tr1/riemann_zeta.tcc" 3
  namespace __detail
  {
# 78 "/usr/include/c++/14/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_sum(_Tp __s)
    {

      if (__s < _Tp(1))
        std::__throw_domain_error(("Bad argument in zeta sum."));

      const unsigned int max_iter = 10000;
      _Tp __zeta = _Tp(0);
      for (unsigned int __k = 1; __k < max_iter; ++__k)
        {
          _Tp __term = std::pow(static_cast<_Tp>(__k), -__s);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            {
              break;
            }
          __zeta += __term;
        }

      return __zeta;
    }
# 115 "/usr/include/c++/14/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_alt(_Tp __s)
    {
      _Tp __sgn = _Tp(1);
      _Tp __zeta = _Tp(0);
      for (unsigned int __i = 1; __i < 10000000; ++__i)
        {
          _Tp __term = __sgn / std::pow(__i, __s);
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __zeta += __term;
          __sgn *= _Tp(-1);
        }
      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 157 "/usr/include/c++/14/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_glob(_Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);



      if (__s < _Tp(0))
        {

          if (::std::fmod(__s,_Tp(2)) == _Tp(0))
            return _Tp(0);
          else

            {
              _Tp __zeta = __riemann_zeta_glob(_Tp(1) - __s);
              __zeta *= std::pow(_Tp(2)
                     * __numeric_constants<_Tp>::__pi(), __s)
                     * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                     * std::exp(::std::lgamma(_Tp(1) - __s))



                     / __numeric_constants<_Tp>::__pi();
              return __zeta;
            }
        }

      _Tp __num = _Tp(0.5L);
      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(1 + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term *= __num;
          __zeta += __term;
          if (std::abs(__term/__zeta) < __eps)
            break;
          __num *= _Tp(0.5L);
        }

      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 252 "/usr/include/c++/14/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_product(_Tp __s)
    {
      static const _Tp __prime[] = {
        _Tp(2), _Tp(3), _Tp(5), _Tp(7), _Tp(11), _Tp(13), _Tp(17), _Tp(19),
        _Tp(23), _Tp(29), _Tp(31), _Tp(37), _Tp(41), _Tp(43), _Tp(47),
        _Tp(53), _Tp(59), _Tp(61), _Tp(67), _Tp(71), _Tp(73), _Tp(79),
        _Tp(83), _Tp(89), _Tp(97), _Tp(101), _Tp(103), _Tp(107), _Tp(109)
      };
      static const unsigned int __num_primes = sizeof(__prime) / sizeof(_Tp);

      _Tp __zeta = _Tp(1);
      for (unsigned int __i = 0; __i < __num_primes; ++__i)
        {
          const _Tp __fact = _Tp(1) - std::pow(__prime[__i], -__s);
          __zeta *= __fact;
          if (_Tp(1) - __fact < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      __zeta = _Tp(1) / __zeta;

      return __zeta;
    }
# 293 "/usr/include/c++/14/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta(_Tp __s)
    {
      if (__isnan(__s))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__s == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (__s < -_Tp(19))
        {
          _Tp __zeta = __riemann_zeta_product(_Tp(1) - __s);
          __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s)
                 * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                 * std::exp(::std::lgamma(_Tp(1) - __s))



                 / __numeric_constants<_Tp>::__pi();
          return __zeta;
        }
      else if (__s < _Tp(20))
        {

          bool __glob = true;
          if (__glob)
            return __riemann_zeta_glob(__s);
          else
            {
              if (__s > _Tp(1))
                return __riemann_zeta_sum(__s);
              else
                {
                  _Tp __zeta = std::pow(_Tp(2)
                                * __numeric_constants<_Tp>::__pi(), __s)
                         * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                             * ::std::tgamma(_Tp(1) - __s)



                             * __riemann_zeta_sum(_Tp(1) - __s);
                  return __zeta;
                }
            }
        }
      else
        return __riemann_zeta_product(__s);
    }
# 365 "/usr/include/c++/14/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __hurwitz_zeta_glob(_Tp __a, _Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);

      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(__a + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term /= _Tp(__i + 1);
          if (std::abs(__term / __zeta) < __eps)
            break;
          __zeta += __term;
        }

      __zeta /= __s - _Tp(1);

      return __zeta;
    }
# 430 "/usr/include/c++/14/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    inline _Tp
    __hurwitz_zeta(_Tp __a, _Tp __s)
    { return __hurwitz_zeta_glob(__a, __s); }
  }






}
# 58 "/usr/include/c++/14/bits/specfun.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 203 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  assoc_laguerref(unsigned int __n, unsigned int __m, float __x)
  { return __detail::__assoc_laguerre<float>(__n, __m, __x); }







  inline long double
  assoc_laguerrel(unsigned int __n, unsigned int __m, long double __x)
  { return __detail::__assoc_laguerre<long double>(__n, __m, __x); }
# 248 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_laguerre<__type>(__n, __m, __x);
    }
# 264 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  assoc_legendref(unsigned int __l, unsigned int __m, float __x)
  { return __detail::__assoc_legendre_p<float>(__l, __m, __x); }






  inline long double
  assoc_legendrel(unsigned int __l, unsigned int __m, long double __x)
  { return __detail::__assoc_legendre_p<long double>(__l, __m, __x); }
# 294 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_legendre_p<__type>(__l, __m, __x);
    }
# 309 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  betaf(float __a, float __b)
  { return __detail::__beta<float>(__a, __b); }







  inline long double
  betal(long double __a, long double __b)
  { return __detail::__beta<long double>(__a, __b); }
# 339 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb>
    inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type
    beta(_Tpa __a, _Tpb __b)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type __type;
      return __detail::__beta<__type>(__a, __b);
    }
# 355 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  comp_ellint_1f(float __k)
  { return __detail::__comp_ellint_1<float>(__k); }







  inline long double
  comp_ellint_1l(long double __k)
  { return __detail::__comp_ellint_1<long double>(__k); }
# 387 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_1(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_1<__type>(__k);
    }
# 403 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  comp_ellint_2f(float __k)
  { return __detail::__comp_ellint_2<float>(__k); }







  inline long double
  comp_ellint_2l(long double __k)
  { return __detail::__comp_ellint_2<long double>(__k); }
# 434 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_2(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_2<__type>(__k);
    }
# 450 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  comp_ellint_3f(float __k, float __nu)
  { return __detail::__comp_ellint_3<float>(__k, __nu); }







  inline long double
  comp_ellint_3l(long double __k, long double __nu)
  { return __detail::__comp_ellint_3<long double>(__k, __nu); }
# 485 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type
    comp_ellint_3(_Tp __k, _Tpn __nu)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;
      return __detail::__comp_ellint_3<__type>(__k, __nu);
    }
# 501 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  cyl_bessel_if(float __nu, float __x)
  { return __detail::__cyl_bessel_i<float>(__nu, __x); }







  inline long double
  cyl_bessel_il(long double __nu, long double __x)
  { return __detail::__cyl_bessel_i<long double>(__nu, __x); }
# 531 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_i(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_i<__type>(__nu, __x);
    }
# 547 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  cyl_bessel_jf(float __nu, float __x)
  { return __detail::__cyl_bessel_j<float>(__nu, __x); }







  inline long double
  cyl_bessel_jl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_j<long double>(__nu, __x); }
# 577 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_j(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_j<__type>(__nu, __x);
    }
# 593 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  cyl_bessel_kf(float __nu, float __x)
  { return __detail::__cyl_bessel_k<float>(__nu, __x); }







  inline long double
  cyl_bessel_kl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_k<long double>(__nu, __x); }
# 629 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_k(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_k<__type>(__nu, __x);
    }
# 645 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  cyl_neumannf(float __nu, float __x)
  { return __detail::__cyl_neumann_n<float>(__nu, __x); }







  inline long double
  cyl_neumannl(long double __nu, long double __x)
  { return __detail::__cyl_neumann_n<long double>(__nu, __x); }
# 677 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_neumann(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_neumann_n<__type>(__nu, __x);
    }
# 693 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  ellint_1f(float __k, float __phi)
  { return __detail::__ellint_1<float>(__k, __phi); }







  inline long double
  ellint_1l(long double __k, long double __phi)
  { return __detail::__ellint_1<long double>(__k, __phi); }
# 725 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_1(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_1<__type>(__k, __phi);
    }
# 741 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  ellint_2f(float __k, float __phi)
  { return __detail::__ellint_2<float>(__k, __phi); }







  inline long double
  ellint_2l(long double __k, long double __phi)
  { return __detail::__ellint_2<long double>(__k, __phi); }
# 773 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_2(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_2<__type>(__k, __phi);
    }
# 789 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  ellint_3f(float __k, float __nu, float __phi)
  { return __detail::__ellint_3<float>(__k, __nu, __phi); }







  inline long double
  ellint_3l(long double __k, long double __nu, long double __phi)
  { return __detail::__ellint_3<long double>(__k, __nu, __phi); }
# 826 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn, typename _Tpp>
    inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type
    ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;
      return __detail::__ellint_3<__type>(__k, __nu, __phi);
    }
# 841 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  expintf(float __x)
  { return __detail::__expint<float>(__x); }







  inline long double
  expintl(long double __x)
  { return __detail::__expint<long double>(__x); }
# 866 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    expint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__expint<__type>(__x);
    }
# 882 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  hermitef(unsigned int __n, float __x)
  { return __detail::__poly_hermite<float>(__n, __x); }







  inline long double
  hermitel(unsigned int __n, long double __x)
  { return __detail::__poly_hermite<long double>(__n, __x); }
# 914 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    hermite(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_hermite<__type>(__n, __x);
    }
# 930 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  laguerref(unsigned int __n, float __x)
  { return __detail::__laguerre<float>(__n, __x); }







  inline long double
  laguerrel(unsigned int __n, long double __x)
  { return __detail::__laguerre<long double>(__n, __x); }
# 958 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    laguerre(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__laguerre<__type>(__n, __x);
    }
# 974 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  legendref(unsigned int __l, float __x)
  { return __detail::__poly_legendre_p<float>(__l, __x); }







  inline long double
  legendrel(unsigned int __l, long double __x)
  { return __detail::__poly_legendre_p<long double>(__l, __x); }
# 1003 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    legendre(unsigned int __l, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_legendre_p<__type>(__l, __x);
    }
# 1019 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  riemann_zetaf(float __s)
  { return __detail::__riemann_zeta<float>(__s); }







  inline long double
  riemann_zetal(long double __s)
  { return __detail::__riemann_zeta<long double>(__s); }
# 1054 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    riemann_zeta(_Tp __s)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__riemann_zeta<__type>(__s);
    }
# 1070 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  sph_besself(unsigned int __n, float __x)
  { return __detail::__sph_bessel<float>(__n, __x); }







  inline long double
  sph_bessell(unsigned int __n, long double __x)
  { return __detail::__sph_bessel<long double>(__n, __x); }
# 1098 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_bessel(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_bessel<__type>(__n, __x);
    }
# 1114 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  sph_legendref(unsigned int __l, unsigned int __m, float __theta)
  { return __detail::__sph_legendre<float>(__l, __m, __theta); }
# 1125 "/usr/include/c++/14/bits/specfun.h" 3
  inline long double
  sph_legendrel(unsigned int __l, unsigned int __m, long double __theta)
  { return __detail::__sph_legendre<long double>(__l, __m, __theta); }
# 1145 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_legendre<__type>(__l, __m, __theta);
    }
# 1161 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  sph_neumannf(unsigned int __n, float __x)
  { return __detail::__sph_neumann<float>(__n, __x); }







  inline long double
  sph_neumannl(unsigned int __n, long double __x)
  { return __detail::__sph_neumann<long double>(__n, __x); }
# 1189 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_neumann(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_neumann<__type>(__n, __x);
    }




}


namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 1216 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  airy_aif(float __x)
  {
    float __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Ai;
  }




  inline long double
  airy_ail(long double __x)
  {
    long double __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Ai;
  }




  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    airy_ai(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      __type __Ai, __Bi, __Aip, __Bip;
      std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
      return __Ai;
    }




  inline float
  airy_bif(float __x)
  {
    float __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Bi;
  }




  inline long double
  airy_bil(long double __x)
  {
    long double __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Bi;
  }




  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    airy_bi(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      __type __Ai, __Bi, __Aip, __Bip;
      std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
      return __Bi;
    }
# 1292 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  conf_hypergf(float __a, float __c, float __x)
  { return std::__detail::__conf_hyperg<float>(__a, __c, __x); }
# 1303 "/usr/include/c++/14/bits/specfun.h" 3
  inline long double
  conf_hypergl(long double __a, long double __c, long double __x)
  { return std::__detail::__conf_hyperg<long double>(__a, __c, __x); }
# 1323 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type
    conf_hyperg(_Tpa __a, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type __type;
      return std::__detail::__conf_hyperg<__type>(__a, __c, __x);
    }
# 1340 "/usr/include/c++/14/bits/specfun.h" 3
  inline float
  hypergf(float __a, float __b, float __c, float __x)
  { return std::__detail::__hyperg<float>(__a, __b, __c, __x); }
# 1351 "/usr/include/c++/14/bits/specfun.h" 3
  inline long double
  hypergl(long double __a, long double __b, long double __c, long double __x)
  { return std::__detail::__hyperg<long double>(__a, __b, __c, __x); }
# 1372 "/usr/include/c++/14/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type
    hyperg(_Tpa __a, _Tpb __b, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>
  ::__type __type;
      return std::__detail::__hyperg<__type>(__a, __b, __c, __x);
    }



}
# 3907 "/usr/include/c++/14/cmath" 2 3


}
# 37 "/usr/include/c++/14/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 5 "../../src/fl/math.h" 2
# 14 "../../src/fl/math.h"
# 1 "/usr/include/c++/14/cmath" 1 3
# 39 "/usr/include/c++/14/cmath" 3
       
# 40 "/usr/include/c++/14/cmath" 3
# 15 "../../src/fl/math.h" 2
# 26 "../../src/fl/math.h"
# 1 "../../src/fl/clamp.h" 1

       






# 8 "../../src/fl/clamp.h"
namespace fl {

template <typename T> __attribute__((always_inline)) inline T clamp(T value, T min, T max) {
    if (value < min) {
        return min;
    }
    if (value > max) {
        return max;
    }
    return value;
}

}
# 27 "../../src/fl/math.h" 2
# 1 "../../src/fl/map_range.h" 1

       





# 1 "../../src/fl/math_macros.h" 1
       

# 1 "../../src/fl/compiler_control.h" 1
       
# 4 "../../src/fl/math_macros.h" 2


namespace fl {




template <typename T> inline T fl_abs(T value) {
    return value < 0 ? -value : value;
}



template <typename T, typename U> inline common_type_t<T, U> fl_min(T a, U b) {
    
# 18 "../../src/fl/math_macros.h"
#pragma GCC diagnostic push
    
# 19 "../../src/fl/math_macros.h"
#pragma GCC diagnostic ignored "-W" "sign-compare"
    return (a < b) ? a : b;
    
# 21 "../../src/fl/math_macros.h"
#pragma GCC diagnostic pop
}

template <typename T, typename U> inline common_type_t<T, U> fl_max(T a, U b) {
    
# 25 "../../src/fl/math_macros.h"
#pragma GCC diagnostic push
    
# 26 "../../src/fl/math_macros.h"
#pragma GCC diagnostic ignored "-W" "sign-compare"
    return (a > b) ? a : b;
    
# 28 "../../src/fl/math_macros.h"
#pragma GCC diagnostic pop
}
}
# 9 "../../src/fl/map_range.h" 2



# 11 "../../src/fl/map_range.h"
#pragma GCC diagnostic push

# 12 "../../src/fl/map_range.h"
#pragma GCC diagnostic ignored "-W" "float-equal"

namespace fl {

template <typename T> struct vec2;

namespace map_range_detail {


template <typename T, typename U> struct map_range_math;
template <typename T> bool equals(T a, T b) { return a == b; }

}

template <typename T, typename U>
__attribute__((always_inline)) inline U map_range(T value, T in_min, T in_max, U out_min,
                                 U out_max) {


    using namespace map_range_detail;
    if (equals(value, in_min)) {
        return out_min;
    }
    if (equals(value, in_max)) {
        return out_max;
    }
    return map_range_math<T, U>::map(value, in_min, in_max, out_min, out_max);
}

template <typename T, typename U>
__attribute__((always_inline)) inline U map_range_clamped(T value, T in_min, T in_max, U out_min,
                                         U out_max) {


    using namespace map_range_detail;
    value = clamp(value, in_min, in_max);
    return map_range<T, U>(value, in_min, in_max, out_min, out_max);
}




namespace map_range_detail {


template <typename T, typename U> struct map_range_math {
    static U map(T value, T in_min, T in_max, U out_min, U out_max) {
        if (in_min == in_max)
            return out_min;
        return out_min +
               (value - in_min) * (out_max - out_min) / (in_max - in_min);
    }
};

template <> struct map_range_math<uint8_t, uint8_t> {
    static uint8_t map(uint8_t value, uint8_t in_min, uint8_t in_max,
                       uint8_t out_min, uint8_t out_max) {
        if (value == in_min) {
            return out_min;
        }
        if (value == in_max) {
            return out_max;
        }

        int16_t v16 = value;
        int16_t in_min16 = in_min;
        int16_t in_max16 = in_max;
        int16_t out_min16 = out_min;
        int16_t out_max16 = out_max;
        int16_t out16 = map_range<uint16_t, uint16_t>(v16, in_min16, in_max16,
                                                      out_min16, out_max16);
        if (out16 < 0) {
            out16 = 0;
        } else if (out16 > 255) {
            out16 = 255;
        }
        return static_cast<uint8_t>(out16);
    }
};


template <typename T, typename V> struct map_range_math<T, vec2<V>> {
    static vec2<V> map(T value, T in_min, T in_max, vec2<V> out_min,
                       vec2<V> out_max) {
        if (in_min == in_max) {
            return out_min;
        }

        T scale = (value - in_min) / T(in_max - in_min);

        V dx = out_max.x - out_min.x;
        V dy = out_max.y - out_min.y;

        V x = out_min.x + V(dx * scale);
        V y = out_min.y + V(dy * scale);
        return {x, y};
    }
};

inline bool equals(float a, float b) { return (fl::fl_abs((a) - (b)) < 1.19209290e-07F); }
inline bool equals(double d, double d2) { return (fl::fl_abs((d) - (d2)) < (1.19209290e-07F)); }

}

}


# 118 "../../src/fl/map_range.h"
#pragma GCC diagnostic pop
# 28 "../../src/fl/math.h" 2


namespace fl {

template <typename T> inline T floor(T value) {
    if (value >= 0) {
        return static_cast<T>(static_cast<int>(value));
    }
    return static_cast<T>(::floor(static_cast<float>(value)));
}

template <typename T> inline T ceil(T value) {
    if (value <= 0) {
        return static_cast<T>(static_cast<int>(value));
    }
    return static_cast<T>(::ceil(static_cast<float>(value)));
}


template <typename T> inline T exp(T value) {

    return static_cast<T>(::exp(static_cast<double>(value)));
# 68 "../../src/fl/math.h"
}



constexpr int ceil_constexpr(float value) {
    return static_cast<int>((value > static_cast<int>(value))
                                ? static_cast<int>(value) + 1
                                : static_cast<int>(value));
}
# 95 "../../src/fl/math.h"
}
# 4 "../../src/fl/geometry.h" 2



namespace fl {

template <typename T> struct vec3 {

    using value_type = T;
    T x = 0;
    T y = 0;
    T z = 0;
    constexpr vec3() = default;
    constexpr vec3(T x, T y, T z) : x(x), y(y), z(z) {}

    template <typename U>
    explicit constexpr vec3(U xyz) : x(xyz), y(xyz), z(xyz) {}

    constexpr vec3(const vec3 &p) = default;
    constexpr vec3(vec3 &&p) noexcept = default;
    vec3 &operator=(vec3 &&p) noexcept = default;

    vec3 &operator*=(const float &f) {
        x *= f;
        y *= f;
        z *= f;
        return *this;
    }
    vec3 &operator/=(const float &f) {
        x /= f;
        y /= f;
        z /= f;
        return *this;
    }
    vec3 &operator*=(const double &f) {
        x *= f;
        y *= f;
        z *= f;
        return *this;
    }
    vec3 &operator/=(const double &f) {
        x /= f;
        y /= f;
        z /= f;
        return *this;
    }

    vec3 &operator/=(const uint16_t &d) {
        x /= d;
        y /= d;
        z /= d;
        return *this;
    }

    vec3 &operator/=(const int &d) {
        x /= d;
        y /= d;
        z /= d;
        return *this;
    }

    vec3 &operator/=(const vec3 &p) {
        x /= p.x;
        y /= p.y;
        z /= p.z;
        return *this;
    }

    vec3 &operator+=(const vec3 &p) {
        x += p.x;
        y += p.y;
        z += p.z;
        return *this;
    }

    vec3 &operator-=(const vec3 &p) {
        x -= p.x;
        y -= p.y;
        z -= p.z;
        return *this;
    }

    vec3 &operator=(const vec3 &p) {
        x = p.x;
        y = p.y;
        z = p.z;
        return *this;
    }

    vec3 operator-(const vec3 &p) const {
        return vec3(x - p.x, y - p.y, z - p.z);
    }

    vec3 operator+(const vec3 &p) const {
        return vec3(x + p.x, y + p.y, z + p.z);
    }

    vec3 operator*(const vec3 &p) const {
        return vec3(x * p.x, y * p.y, z * p.z);
    }

    vec3 operator/(const vec3 &p) const {
        return vec3(x / p.x, y / p.y, z / p.z);
    }

    template <typename NumberT> vec3 operator+(const NumberT &p) const {
        return vec3(x + p, y + p, z + p);
    }

    template <typename U> vec3 operator+(const vec3<U> &p) const {
        return vec3(x + p.x, y + p.y, z + p.z);
    }

    template <typename NumberT> vec3 operator-(const NumberT &p) const {
        return vec3(x - p, y - p, z - p);
    }

    template <typename NumberT> vec3 operator*(const NumberT &p) const {
        return vec3(x * p, y * p, z * p);
    }

    template <typename NumberT> vec3 operator/(const NumberT &p) const {
        T a = x / p;
        T b = y / p;
        T c = z / p;
        return vec3<T>(a, b, c);
    }

    bool operator==(const vec3 &p) const {
        return (x == p.x && y == p.y && z == p.z);
    }

    bool operator!=(const vec3 &p) const {
        return (x != p.x || y != p.y || z != p.z);
    }

    template <typename U> bool operator==(const vec3<U> &p) const {
        return (x == p.x && y == p.y && z == p.z);
    }

    template <typename U> bool operator!=(const vec3<U> &p) const {
        return (x != p.x || y != p.y || z != p.z);
    }

    vec3 getMax(const vec3 &p) const {
        return vec3(fl::fl_max(x, p.x), fl::fl_max(y, p.y), fl::fl_max(z, p.z));
    }

    vec3 getMin(const vec3 &p) const {
        return vec3(fl::fl_min(x, p.x), fl::fl_min(y, p.y), fl::fl_min(z, p.z));
    }

    template <typename U> vec3<U> cast() const {
        return vec3<U>(static_cast<U>(x), static_cast<U>(y), static_cast<U>(z));
    }

    template <typename U> vec3 getMax(const vec3<U> &p) const {
        return vec3<U>(fl::fl_max(x, p.x), fl::fl_max(y, p.y), fl::fl_max(z, p.z));
    }

    template <typename U> vec3 getMin(const vec3<U> &p) const {
        return vec3<U>(fl::fl_min(x, p.x), fl::fl_min(y, p.y), fl::fl_min(z, p.z));
    }

    T distance(const vec3 &p) const {
        T dx = x - p.x;
        T dy = y - p.y;
        T dz = z - p.z;
        return sqrt(dx * dx + dy * dy + dz * dz);
    }

    bool is_zero() const { return (x == 0 && y == 0 && z == 0); }
};

using vec3f = vec3<float>;

template <typename T> struct vec2 {

    using value_type = T;
    T x = 0;
    T y = 0;
    constexpr vec2() = default;
    constexpr vec2(T x, T y) : x(x), y(y) {}

    template <typename U> explicit constexpr vec2(U xy) : x(xy), y(xy) {}

    constexpr vec2(const vec2 &p) = default;
    constexpr vec2(vec2 &&p) noexcept = default;
    vec2 &operator=(vec2 &&p) noexcept = default;

    vec2 &operator*=(const float &f) {
        x *= f;
        y *= f;
        return *this;
    }
    vec2 &operator/=(const float &f) {

        x /= f;
        y /= f;
        return *this;
    }
    vec2 &operator*=(const double &f) {

        x *= f;
        y *= f;
        return *this;
    }
    vec2 &operator/=(const double &f) {

        x /= f;
        y /= f;
        return *this;
    }

    vec2 &operator/=(const uint16_t &d) {

        x /= d;
        y /= d;
        return *this;
    }

    vec2 &operator/=(const int &d) {

        x /= d;
        y /= d;
        return *this;
    }

    vec2 &operator/=(const vec2 &p) {

        x /= p.x;
        y /= p.y;
        return *this;
    }

    vec2 &operator+=(const vec2 &p) {

        x += p.x;
        y += p.y;
        return *this;
    }

    vec2 &operator-=(const vec2 &p) {

        x -= p.x;
        y -= p.y;
        return *this;
    }

    vec2 &operator=(const vec2 &p) {
        x = p.x;
        y = p.y;
        return *this;
    }

    vec2 operator-(const vec2 &p) const { return vec2(x - p.x, y - p.y); }

    vec2 operator+(const vec2 &p) const { return vec2(x + p.x, y + p.y); }

    vec2 operator*(const vec2 &p) const { return vec2(x * p.x, y * p.y); }

    vec2 operator/(const vec2 &p) const { return vec2(x / p.x, y / p.y); }

    template <typename NumberT> vec2 operator+(const NumberT &p) const {
        return vec2(x + p, y + p);
    }

    template <typename U> vec2 operator+(const vec2<U> &p) const {
        return vec2(x + p.x, y + p.x);
    }

    template <typename NumberT> vec2 operator-(const NumberT &p) const {
        return vec2(x - p, y - p);
    }

    template <typename NumberT> vec2 operator*(const NumberT &p) const {
        return vec2(x * p, y * p);
    }

    template <typename NumberT> vec2 operator/(const NumberT &p) const {
        T a = x / p;
        T b = y / p;
        return vec2<T>(a, b);
    }

    bool operator==(const vec2 &p) const { return (x == p.x && y == p.y); }

    bool operator!=(const vec2 &p) const { return (x != p.x || y != p.y); }

    template <typename U> bool operator==(const vec2<U> &p) const {
        return (x == p.x && y == p.y);
    }

    template <typename U> bool operator!=(const vec2<U> &p) const {
        return (x != p.x || y != p.y);
    }

    vec2 getMax(const vec2 &p) const { return vec2(fl::fl_max(x, p.x), fl::fl_max(y, p.y)); }

    vec2 getMin(const vec2 &p) const { return vec2(fl::fl_min(x, p.x), fl::fl_min(y, p.y)); }

    template <typename U> vec2<U> cast() const {
        return vec2<U>(static_cast<U>(x), static_cast<U>(y));
    }

    template <typename U> vec2 getMax(const vec2<U> &p) const {
        return vec2<U>(fl::fl_max(x, p.x), fl::fl_max(y, p.y));
    }

    template <typename U> vec2 getMin(const vec2<U> &p) const {
        return vec2<U>(fl::fl_min(x, p.x), fl::fl_min(y, p.y));
    }

    T distance(const vec2 &p) const {
        T dx = x - p.x;
        T dy = y - p.y;
        return sqrt(dx * dx + dy * dy);
    }

    bool is_zero() const { return (x == 0 && y == 0); }
};

using vec2f = vec2<float>;
using vec2u8 = vec2<uint8_t>;
using vec2i16 = vec2<int16_t>;


using pair_xyz_float = vec3<float>;



using pair_xy_float = vec2<float>;


template <typename T> struct pair_xy : public vec2<T> {
    using value_type = T;
    using vec2<T>::vec2;
    pair_xy() = default;
    pair_xy(const vec2<T> &p) : vec2<T>(p) {}
};

template <typename T> struct line_xy {
    vec2<T> start;
    vec2<T> end;

    line_xy() = default;
    line_xy(const vec2<T> &start, const vec2<T> &end)
        : start(start), end(end) {}

    line_xy(T start_x, T start_y, T end_x, T end_y)
        : start(start_x, start_y), end(end_x, end_y) {}

    line_xy(const line_xy &other) = default;
    line_xy &operator=(const line_xy &other) = default;
    line_xy(line_xy &&other) noexcept = default;
    line_xy &operator=(line_xy &&other) noexcept = default;

    bool empty() const { return (start == end); }

    float distance_to(const vec2<T> &p,
                      vec2<T> *out_projected = nullptr) const {
        return distance_to_line_with_point(p, start, end, out_projected);
    }

  private:


    static float distance_to_line_with_point(vec2<T> p, vec2<T> a, vec2<T> b,
                                             vec2<T> *out_projected) {
        vec2<T> maybe;
        vec2<T> &out_proj = out_projected ? *out_projected : maybe;
        float dx = b.x - a.x;
        float dy = b.y - a.y;
        float len_sq = dx * dx + dy * dy;

        
# 378 "../../src/fl/geometry.h"
#pragma GCC diagnostic push
        
# 379 "../../src/fl/geometry.h"
#pragma GCC diagnostic ignored "-W" "float-equal"
        const bool is_zero = (len_sq == 0.0f);
        
# 381 "../../src/fl/geometry.h"
#pragma GCC diagnostic pop

        if (is_zero) {

            out_proj = a;
            dx = p.x - a.x;
            dy = p.y - a.y;
            return sqrt(dx * dx + dy * dy);
        }


        float t = ((p.x - a.x) * dx + (p.y - a.y) * dy) / len_sq;


        if (t < 0.0f)
            t = 0.0f;
        else if (t > 1.0f)
            t = 1.0f;


        out_proj.x = a.x + t * dx;
        out_proj.y = a.y + t * dy;

        dx = p.x - out_proj.x;
        dy = p.y - out_proj.y;
        return sqrt(dx * dx + dy * dy);
    }
};

template <typename T> struct rect {
    vec2<T> mMin;
    vec2<T> mMax;

    rect() = default;
    rect(const vec2<T> &min, const vec2<T> &max) : mMin(min), mMax(max) {}

    rect(T min_x, T min_y, T max_x, T max_y)
        : mMin(min_x, min_y), mMax(max_x, max_y) {}

    rect(const rect &other) = default;
    rect &operator=(const rect &other) = default;
    rect(rect &&other) noexcept = default;
    rect &operator=(rect &&other) noexcept = default;

    uint16_t width() const { return mMax.x - mMin.x; }

    uint16_t height() const { return mMax.y - mMin.y; }

    bool empty() const { return (mMin.x == mMax.x && mMin.y == mMax.y); }

    void expand(const vec2<T> &p) { expand(p.x, p.y); }

    void expand(const rect &r) {
        expand(r.mMin);
        expand(r.mMax);
    }

    void expand(T x, T y) {
        mMin.x = fl::fl_min(mMin.x, x);
        mMin.y = fl::fl_min(mMin.y, y);
        mMax.x = fl::fl_max(mMax.x, x);
        mMax.y = fl::fl_max(mMax.y, y);
    }

    bool contains(const vec2<T> &p) const {
        return (p.x >= mMin.x && p.x < mMax.x && p.y >= mMin.y && p.y < mMax.y);
    }

    bool contains(const T &x, const T &y) const {
        return contains(vec2<T>(x, y));
    }

    bool operator==(const rect &r) const {
        return (mMin == r.mMin && mMax == r.mMax);
    }

    bool operator!=(const rect &r) const { return !(*this == r); }

    template <typename U> bool operator==(const rect<U> &r) const {
        return (mMin == r.mMin && mMax == r.mMax);
    }

    template <typename U> bool operator!=(const rect<U> &r) const {
        return !(*this == r);
    }
};

}
# 15 "../../src/fl/str.h" 2


# 1 "../../src/fl/ptr.h" 1

       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 5 "../../src/fl/ptr.h" 2
# 25 "../../src/fl/ptr.h"
# 1 "../../src/fl/scoped_ptr.h" 1

       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 5 "../../src/fl/scoped_ptr.h" 2


# 1 "../../src/fl/allocator.h" 1
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 4 "../../src/fl/allocator.h" 2
# 1 "/usr/include/c++/14/stdlib.h" 1 3
# 36 "/usr/include/c++/14/stdlib.h" 3
# 1 "/usr/include/c++/14/cstdlib" 1 3
# 39 "/usr/include/c++/14/cstdlib" 3
       
# 40 "/usr/include/c++/14/cstdlib" 3
# 125 "/usr/include/c++/14/cstdlib" 3

# 125 "/usr/include/c++/14/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;

  using ::aligned_alloc;

  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) noexcept { return ldiv(__i, __j); }




}
# 199 "/usr/include/c++/14/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wlong-long"
  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
#pragma GCC diagnostic pop
# 234 "/usr/include/c++/14/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
# 278 "/usr/include/c++/14/cstdlib" 3
}
# 37 "/usr/include/c++/14/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;


  using std::_Exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 5 "../../src/fl/allocator.h" 2

# 1 "../../src/fl/inplacenew.h" 1
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 4 "../../src/fl/inplacenew.h" 2
# 16 "../../src/fl/inplacenew.h"
# 1 "/usr/include/c++/14/new" 1 3
# 38 "/usr/include/c++/14/new" 3
       
# 39 "/usr/include/c++/14/new" 3


# 1 "/usr/include/c++/14/bits/exception.h" 1 3
# 34 "/usr/include/c++/14/bits/exception.h" 3
       
# 35 "/usr/include/c++/14/bits/exception.h" 3



extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{
# 59 "/usr/include/c++/14/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };



}

}
# 42 "/usr/include/c++/14/new" 2 3




# 1 "/usr/include/c++/14/bits/version.h" 1 3
# 47 "/usr/include/c++/14/bits/version.h" 3
       
# 48 "/usr/include/c++/14/bits/version.h" 3
# 47 "/usr/include/c++/14/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };



  enum class align_val_t: size_t {};


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 131 "/usr/include/c++/14/new" 3
[[__nodiscard__]] void* operator new(std::size_t)
  __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete(void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete[](void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));

void operator delete(void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));




[[__nodiscard__]] inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
[[__nodiscard__]] inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}


namespace std
{


  template<typename _Tp>
    [[nodiscard]] constexpr _Tp*
    launder(_Tp* __p) noexcept
    { return __builtin_launder(__p); }




  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args...) noexcept (_NE)) = delete;
  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args......) noexcept (_NE)) = delete;

  void launder(void*) = delete;
  void launder(const void*) = delete;
  void launder(volatile void*) = delete;
  void launder(const volatile void*) = delete;



  inline constexpr size_t hardware_destructive_interference_size = 64;
  inline constexpr size_t hardware_constructive_interference_size = 64;

}
# 236 "/usr/include/c++/14/new" 3
#pragma GCC visibility pop
# 17 "../../src/fl/inplacenew.h" 2
# 7 "../../src/fl/allocator.h" 2

# 1 "../../src/fl/unused.h" 1
       
# 9 "../../src/fl/allocator.h" 2


# 10 "../../src/fl/allocator.h"
namespace fl {

void SetPSRamAllocator(void *(*alloc)(size_t), void (*free)(void *));
void *PSRamAllocate(size_t size, bool zero = true);
void PSRamDeallocate(void *ptr);
void Malloc(size_t size);
void Free(void *ptr);

template <typename T> class PSRamAllocator {
  public:
    static T *Alloc(size_t n) {
        void *ptr = PSRamAllocate(sizeof(T) * n, true);
        return reinterpret_cast<T *>(ptr);
    }

    static void Free(T *p) {
        if (p == nullptr) {
            return;
        }
        PSRamDeallocate(p);
    }
};


template <typename T> class allocator {
  public:

    using value_type = T;
    using pointer = T*;
    using const_pointer = const T*;
    using reference = T&;
    using const_reference = const T&;
    using size_type = size_t;
    using difference_type = ptrdiff_t;


    template <typename U>
    struct rebind {
        using other = allocator<U>;
    };


    allocator() noexcept {}


    template <typename U>
    allocator(const allocator<U>&) noexcept {}


    ~allocator() noexcept {}




    T* allocate(size_t n) {
        if (n == 0) {
            return nullptr;
        }
        void *ptr = malloc(sizeof(T) * n);
        if (ptr == nullptr) {
            return nullptr;
        }
        memset(ptr, 0, sizeof(T) * n);
        return static_cast<T*>(ptr);
    }

    void deallocate(T* p, size_t n) {
        (void)(n);
        if (p == nullptr) {
            return;
        }
        free(p);
    }


    template <typename U, typename... Args>
    void construct(U* p, Args&&... args) {
        if (p == nullptr) return;
        new(static_cast<void*>(p)) U(fl::forward<Args>(args)...);
    }


    template <typename U>
    void destroy(U* p) {
        if (p == nullptr) return;
        p->~U();
    }
};

template <typename T> class allocator_psram {
    public:

        using value_type = T;
        using pointer = T*;
        using const_pointer = const T*;
        using reference = T&;
        using const_reference = const T&;
        using size_type = size_t;
        using difference_type = ptrdiff_t;


        template <typename U>
        struct rebind {
            using other = allocator_psram<U>;
        };


        allocator_psram() noexcept {}


        template <typename U>
        allocator_psram(const allocator_psram<U>&) noexcept {}


        ~allocator_psram() noexcept {}


        T* allocate(size_t n) {
            return PSRamAllocator<T>::Alloc(n);
        }


        void deallocate(T* p, size_t n) {
            PSRamAllocator<T>::Free(p);
            (void)(n);
        }


        template <typename U, typename... Args>
        void construct(U* p, Args&&... args) {
            if (p == nullptr) return;
            new(static_cast<void*>(p)) U(fl::forward<Args>(args)...);
        }


        template <typename U>
        void destroy(U* p) {
            if (p == nullptr) return;
            p->~U();
        }
};
# 202 "../../src/fl/allocator.h"
}
# 8 "../../src/fl/scoped_ptr.h" 2





namespace fl {

template <typename T> struct ArrayDeleter {
    ArrayDeleter() = default;
    void operator()(T *ptr) { delete[] ptr; }
};

template <typename T> struct PointerDeleter {
    void operator()(T *ptr) { delete ptr; }
};

template <typename T, typename Deleter = PointerDeleter<T>> class scoped_ptr {
  public:

    explicit scoped_ptr(T *ptr = nullptr, Deleter deleter = Deleter())
        : ptr_(ptr), deleter_(deleter) {}


    ~scoped_ptr() { deleter_(ptr_); }


    scoped_ptr(const scoped_ptr &) = delete;
    scoped_ptr(scoped_ptr &&) = default;
    scoped_ptr &operator=(const scoped_ptr &&other) {
        if (this != &other) {
            deleter_(ptr_);
            ptr_ = other.ptr_;
            deleter_ = other.deleter_;
            other.ptr_ = nullptr;
            other.deleter_ = {};
        }
    }
# 58 "../../src/fl/scoped_ptr.h"
    T *operator->() const { return ptr_; }


    T &operator*() const { return *ptr_; }


    T *get() const { return ptr_; }


    explicit operator bool() const noexcept { return ptr_ != nullptr; }


    bool operator!() const noexcept { return ptr_ == nullptr; }


    void reset(T *ptr = nullptr) {
        if (ptr_ != ptr) {
            deleter_(ptr_);
            ptr_ = ptr;
        }
    }

    T *release() {
        T *tmp = ptr_;
        ptr_ = nullptr;
        return tmp;
    }

    void swap(scoped_ptr &other) noexcept {
        T *tmp = ptr_;
        ptr_ = other.ptr_;
        other.ptr_ = tmp;
    }

  private:
    T *ptr_;
    Deleter deleter_;
};






template <typename T, typename Deleter = ArrayDeleter<T>> class scoped_array {
  public:
    __attribute__((deprecated("Use fl::vector<T, fl::allocator_psram<T>> instead")));

    explicit scoped_array(T *arr = nullptr) : arr_(arr) {}
    scoped_array(T *arr, Deleter deleter) : arr_(arr), deleter_(deleter) {}


    ~scoped_array() { deleter_(arr_); }


    scoped_array(const scoped_array &) = delete;
    scoped_array &operator=(const scoped_array &) = delete;


    scoped_array(scoped_array &&other) noexcept
        : arr_(other.arr_), deleter_(other.deleter_) {
        other.arr_ = nullptr;
        other.deleter_ = {};
    }


    scoped_array &operator=(scoped_array &&other) noexcept {
        if (this != &other) {
            reset(other.arr_);
            other.arr_ = nullptr;
        }
        return *this;
    }


    T &operator[](size_t i) const { return arr_[i]; }


    T *get() const { return arr_; }


    explicit operator bool() const noexcept { return arr_ != nullptr; }


    bool operator!() const noexcept { return arr_ == nullptr; }


    void reset(T *arr = nullptr) {
        if (arr_ == arr) {
            return;
        }
        deleter_(arr_);
        arr_ = arr;
    }

    void clear() { reset(); }

    T *release() {
        T *tmp = arr_;
        arr_ = nullptr;
        return tmp;
    }

    void swap(scoped_array &other) noexcept {
        T *tmp = arr_;
        arr_ = other.arr_;
        other.arr_ = tmp;
    }

  private:
    T *arr_;
    Deleter deleter_ = {};
};




template <typename T, typename Alloc = fl::allocator<T>> class scoped_array2 {
  public:
    __attribute__((deprecated("Use fl::vector<T, fl::allocator_psram<T>> instead")));
    Alloc mAlloc;

    explicit scoped_array2(size_t size = 0)
        : arr_(nullptr), size_(size) {
        if (size > 0) {
            arr_ = mAlloc.allocate(size);

            for (size_t i = 0; i < size; ++i) {
                mAlloc.construct(&arr_[i]);
            }
        }
    }


    ~scoped_array2() {
        if (arr_) {

            for (size_t i = 0; i < size_; ++i) {
                mAlloc.destroy(&arr_[i]);
            }
            mAlloc.deallocate(arr_, size_);
        }
    }


    scoped_array2(const scoped_array2 &) = delete;
    scoped_array2 &operator=(const scoped_array2 &) = delete;


    scoped_array2(scoped_array2 &&other) noexcept
        : arr_(other.arr_), size_(other.size_) {
        other.arr_ = nullptr;
        other.size_ = 0;
    }


    scoped_array2 &operator=(scoped_array2 &&other) noexcept {
        if (this != &other) {
            reset();
            arr_ = other.arr_;
            size_ = other.size_;
            other.arr_ = nullptr;
            other.size_ = 0;
        }
        return *this;
    }


    T &operator[](size_t i) const { return arr_[i]; }


    T *get() const { return arr_; }


    size_t size() const { return size_; }


    explicit operator bool() const noexcept { return arr_ != nullptr; }


    bool operator!() const noexcept { return arr_ == nullptr; }


    void reset(size_t new_size = 0) {
        if (arr_) {

            for (size_t i = 0; i < size_; ++i) {

                mAlloc.destroy(&arr_[i]);
            }

            mAlloc.deallocate(arr_, size_);
            arr_ = nullptr;
        }

        size_ = new_size;
        if (new_size > 0) {

            arr_ = mAlloc.allocate(new_size);

            for (size_t i = 0; i < new_size; ++i) {

                mAlloc.construct(&arr_[i]);
            }
        }
    }


    T *release() {
        T *tmp = arr_;
        arr_ = nullptr;
        size_ = 0;
        return tmp;
    }

    void swap(scoped_array2 &other) noexcept {
        T *tmp_arr = arr_;
        size_t tmp_size = size_;

        arr_ = other.arr_;
        size_ = other.size_;

        other.arr_ = tmp_arr;
        other.size_ = tmp_size;
    }

  private:
    T *arr_ = nullptr;
    size_t size_ = 0;
};



}
# 26 "../../src/fl/ptr.h" 2
# 52 "../../src/fl/ptr.h"
namespace fl {

class Referent;

template <typename T> class Ptr;
template <typename T> class WeakPtr;

template <typename T, typename... Args> Ptr<T> NewPtr(Args... args);

template <typename T, typename... Args> Ptr<T> NewPtrNoTracking(Args... args);

template <typename T> class PtrTraits {
  public:
    using element_type = T;
    using ptr_type = Ptr<T>;

    template <typename... Args> static Ptr<T> New(Args... args) {
        T *ptr = new T(args...);
        return Ptr<T>::TakeOwnership(ptr);
    }

    static Ptr<T> New() {
        T *ptr = new T();
        return Ptr<T>::TakeOwnership(ptr);
    }
};
# 118 "../../src/fl/ptr.h"
template <typename T> class Ptr : public PtrTraits<T> {
  public:
    friend class PtrTraits<T>;

    template <typename... Args> static Ptr<T> New(Args... args) {
        return PtrTraits<T>::New(args...);
    }


    static Ptr TakeOwnership(T *ptr) { return Ptr(ptr, true); }




    static Ptr NoTracking(T &referent) { return Ptr(&referent, false); }

    static Ptr Null() { return Ptr<T>(); }


    template <typename U, typename = fl::is_derived<T, U>>
    Ptr(const Ptr<U> &refptr) : referent_(refptr.get()) {
        if (referent_ && isOwned()) {
            referent_->ref();
        }
    }

    Ptr() : referent_(nullptr) {}



    Ptr(T *referent) = delete;
    Ptr &operator=(T *referent) = delete;

    Ptr(const Ptr &other) : referent_(other.referent_) {
        if (referent_ && isOwned()) {
            referent_->ref();
        }
    }

    Ptr(Ptr &&other) noexcept : referent_(other.referent_) {
        other.referent_ = nullptr;
    }

    ~Ptr() {
        if (referent_ && isOwned()) {
            referent_->unref();
        }
    }

    Ptr &operator=(const Ptr &other) {
        if (this != &other) {
            if (referent_ && isOwned()) {
                referent_->unref();
            }
            referent_ = other.referent_;
            if (referent_ && isOwned()) {
                referent_->ref();
            }
        }
        return *this;
    }


    WeakPtr<T> weakRefNoCreate() const;
    WeakPtr<T> weakPtr() const { return WeakPtr<T>(*this); }

    bool operator==(const T *other) const { return referent_ == other; }

    bool operator!=(const T *other) const { return referent_ != other; }

    bool operator==(const Ptr &other) const {
        return referent_ == other.referent_;
    }
    bool operator!=(const Ptr &other) const {
        return referent_ != other.referent_;
    }

    bool operator<(const Ptr &other) const {
        return referent_ < other.referent_;
    }

    Ptr &operator=(Ptr &&other) noexcept {
        if (this != &other) {
            if (referent_ && isOwned()) {
                referent_->unref();
            }
            referent_ = other.referent_;
            other.referent_ = nullptr;
        }
        return *this;
    }

    T *get() const { return referent_; }

    T *operator->() const { return referent_; }

    T &operator*() const { return *referent_; }

    explicit operator bool() const noexcept { return referent_ != nullptr; }

    void reset() {
        if (referent_ && isOwned()) {
            referent_->unref();
        }
        referent_ = nullptr;
    }

    void reset(Ptr<T> &refptr) {
        if (refptr.referent_ != referent_) {
            if (refptr.referent_ && refptr.isOwned()) {
                refptr.referent_->ref();
            }
            if (referent_ && isOwned()) {
                referent_->unref();
            }
            referent_ = refptr.referent_;
        }
    }


    T *release() {
        T *temp = referent_;
        referent_ = nullptr;
        return temp;
    }

    void swap(Ptr &other) noexcept {
        T *temp = referent_;
        referent_ = other.referent_;
        other.referent_ = temp;
    }

    bool isOwned() const { return referent_ && referent_->ref_count() > 0; }

  private:
    Ptr(T *referent, bool from_heap) : referent_(referent) {
        if (referent_ && from_heap) {
            referent_->ref();
        }
    }
    T *referent_;
};


class WeakReferent {
  public:
    WeakReferent() : mRefCount(0), mReferent(nullptr) {}
    ~WeakReferent() {}

    void ref() { mRefCount++; }
    int ref_count() const { return mRefCount; }
    void unref() {
        if (--mRefCount == 0) {
            destroy();
        }
    }
    void destroy() { delete this; }
    void setReferent(Referent *referent) { mReferent = referent; }
    Referent *getReferent() const { return mReferent; }

  protected:
    WeakReferent(const WeakReferent &) = default;
    WeakReferent &operator=(const WeakReferent &) = default;
    WeakReferent(WeakReferent &&) = default;
    WeakReferent &operator=(WeakReferent &&) = default;

  private:
    mutable int mRefCount;
    Referent *mReferent;
};

template <typename T> class WeakPtr {
  public:
    WeakPtr() : mWeakPtr() {}

    WeakPtr(const Ptr<T> &ptr) {
        if (ptr) {
            WeakPtr weakRefNoCreate = ptr.weakRefNoCreate();
            bool expired = weakRefNoCreate.expired();
            if (expired) {
                Ptr<WeakReferent> weakRefNoCreate = Ptr<WeakReferent>::New();
                ptr->setWeakPtr(weakRefNoCreate);
                weakRefNoCreate->setReferent(ptr.get());
            }
            mWeakPtr = ptr->mWeakPtr;
        }
    }

    template <typename U> WeakPtr(const Ptr<U> &ptr) : mWeakPtr(ptr->mWeakPtr) {
        if (ptr) {
            WeakPtr weakRefNoCreate = ptr.weakRefNoCreate();
            bool expired = weakRefNoCreate.expired();
            if (expired) {
                Ptr<WeakReferent> weakRefNoCreate = Ptr<WeakReferent>::New();
                ptr->setWeakPtr(weakRefNoCreate);
                weakRefNoCreate->setReferent(ptr.get());
            }
            mWeakPtr = ptr->mWeakPtr;
        }
    }

    WeakPtr(const WeakPtr &other) : mWeakPtr(other.mWeakPtr) {}

    template <typename U>
    WeakPtr(const WeakPtr<U> &other) : mWeakPtr(other.mWeakPtr) {}

    WeakPtr(WeakPtr &&other) noexcept : mWeakPtr(other.mWeakPtr) {}

    ~WeakPtr() { reset(); }

    operator bool() const { return mWeakPtr && mWeakPtr->getReferent(); }

    bool operator!() const {
        bool ok = *this;
        return !ok;
    }

    bool operator==(const WeakPtr &other) const {
        return mWeakPtr == other.mWeakPtr;
    }

    bool operator!=(const WeakPtr &other) const {
        return !(mWeakPtr != other.mWeakPtr);
    }

    bool operator==(const T *other) const { return lock().get() == other; }

    bool operator==(T *other) const {
        if (!mWeakPtr) {
            return other == nullptr;
        }
        return mWeakPtr->getReferent() == other;
    }

    bool operator==(const Ptr<T> &other) const {
        if (!mWeakPtr) {
            return !other;
        }
        return mWeakPtr->getReferent() == other.get();
    }

    bool operator!=(const T *other) const {
        bool equal = *this == other;
        return !equal;
    }

    WeakPtr &operator=(const WeakPtr &other) {
        this->mWeakPtr = other.mWeakPtr;
        return *this;
    }

    Ptr<T> lock() const {
        if (!mWeakPtr) {
            return Ptr<T>();
        }
        T *out = static_cast<T *>(mWeakPtr->getReferent());
        if (out->ref_count() == 0) {

            return Ptr<T>::NoTracking(*out);
        }

        return Ptr<T>::TakeOwnership(static_cast<T *>(out));
    }

    bool expired() const {
        if (!mWeakPtr) {
            return true;
        }
        if (!mWeakPtr->getReferent()) {
            return true;
        }
        return false;
    }

    void reset() {
        if (mWeakPtr) {
            mWeakPtr.reset();
        }
    }
    Ptr<WeakReferent> mWeakPtr;
};



class Referent {
  public:
    virtual int ref_count() const;

  protected:
    Referent();
    virtual ~Referent();
    Referent(const Referent &);
    Referent &operator=(const Referent &);
    Referent(Referent &&);
    Referent &operator=(Referent &&);


    virtual void ref() const;
    virtual void unref() const;
    virtual void destroy() const;

  private:
    friend class WeakReferent;
    template <typename T> friend class Ptr;
    template <typename T> friend class WeakPtr;
    void setWeakPtr(Ptr<WeakReferent> weakRefNoCreate) {
        mWeakPtr = weakRefNoCreate;
    }
    mutable int mRefCount;
    mutable Ptr<WeakReferent>
        mWeakPtr;
};

template <typename T> inline WeakPtr<T> Ptr<T>::weakRefNoCreate() const {
    if (!referent_) {
        return WeakPtr<T>();
    }
    WeakReferent *tmp = get()->mWeakPtr.get();
    if (!tmp) {
        return WeakPtr<T>();
    }
    T *referent = static_cast<T *>(tmp->getReferent());
    if (!referent) {
        return WeakPtr<T>();
    }



    WeakPtr<T> out;
    out.mWeakPtr = get()->mWeakPtr;
    return out;
}

template <typename T, typename... Args> Ptr<T> NewPtr(Args... args) {
    return Ptr<T>::New(args...);
}

template <typename T> Ptr<T> NewPtrNoTracking(T &obj) {
    return Ptr<T>::NoTracking(obj);
}

}
# 18 "../../src/fl/str.h" 2

# 1 "../../src/fl/vector.h" 1
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 4 "../../src/fl/vector.h" 2



# 1 "../../src/fl/functional.h" 1
       



namespace fl {
# 15 "../../src/fl/functional.h"
template <typename T = void> struct less {







    constexpr bool operator()(const T &lhs, const T &rhs) const {
        return lhs < rhs;
    }
};







template <> struct less<void> {
# 44 "../../src/fl/functional.h"
    template <typename T, typename U>
    constexpr auto operator()(T &&lhs, U &&rhs) const
        -> decltype(fl::forward<T>(lhs) < fl::forward<U>(rhs)) {
        return fl::forward<T>(lhs) < fl::forward<U>(rhs);
    }
};

}
# 8 "../../src/fl/vector.h" 2
# 1 "../../src/fl/initializer_list.h" 1
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 4 "../../src/fl/initializer_list.h" 2
# 56 "../../src/fl/initializer_list.h"
# 1 "/usr/include/c++/14/initializer_list" 1 3
# 33 "/usr/include/c++/14/initializer_list" 3
       
# 34 "/usr/include/c++/14/initializer_list" 3








# 41 "/usr/include/c++/14/initializer_list" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };







  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }







  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}
# 57 "../../src/fl/initializer_list.h" 2

# 57 "../../src/fl/initializer_list.h"
namespace fl {
    using std::initializer_list;
}
# 9 "../../src/fl/vector.h" 2
# 1 "../../src/fl/insert_result.h" 1
       

namespace fl {






enum InsertResult {
    kInserted = 0,
    kExists = 1,
    kMaxSize = 2,
};

}
# 10 "../../src/fl/vector.h" 2






namespace fl {


template <typename T, size_t N> struct InlinedMemoryBlock {

    typedef uintptr_t MemoryType;
    enum {
        kTotalBytes = N * sizeof(T),
        kAlign = sizeof(MemoryType),
        kExtraSize =
            (kTotalBytes % kAlign) ? (kAlign - (kTotalBytes % kAlign)) : 0,
        kBlockSize = kTotalBytes / sizeof(MemoryType) + kExtraSize,
    };

    InlinedMemoryBlock() {
        memset(mMemoryBlock, 0, sizeof(mMemoryBlock));



    }

    InlinedMemoryBlock(const InlinedMemoryBlock &other) = default;
    InlinedMemoryBlock(InlinedMemoryBlock &&other) = default;




    MemoryType mMemoryBlock[kBlockSize];

    T *memory() {
        MemoryType *begin = &mMemoryBlock[0];
        uintptr_t shift_up =
            reinterpret_cast<uintptr_t>(begin) & (sizeof(MemoryType) - 1);
        MemoryType *raw = begin + shift_up;
        return reinterpret_cast<T *>(raw);
    }

    const T *memory() const {
        const MemoryType *begin = &mMemoryBlock[0];
        const uintptr_t shift_up =
            reinterpret_cast<uintptr_t>(begin) & (sizeof(MemoryType) - 1);
        const MemoryType *raw = begin + shift_up;
        return reinterpret_cast<const T *>(raw);
    }




};






template <typename T, size_t N> class FixedVector {
  private:
    InlinedMemoryBlock<T, N> mMemoryBlock;

    T *memory() { return mMemoryBlock.memory(); }

    const T *memory() const { return mMemoryBlock.memory(); }

  public:
    typedef T *iterator;
    typedef const T *const_iterator;

    constexpr FixedVector() : current_size(0) {}

    FixedVector(const T (&values)[N]) : current_size(N) {
        assign_array(values, N);
    }

    FixedVector(FixedVector &&other) {
        fl::swap(*this, other);
        other.clear();
    }

    FixedVector(const FixedVector &other) : current_size(other.current_size) {
        assign_array(other.memory(), other.current_size);
    }

    template <size_t M> FixedVector(T (&values)[M]) : current_size(0) {
        static_assert(M <= N, "Too many elements for FixedVector");
        assign_array(values, M);
    }


    FixedVector(fl::initializer_list<T> init) : current_size(0) {
        if (init.size() > N) {

            auto it = init.begin();
            for (size_t i = 0; i < N && it != init.end(); ++i, ++it) {
                push_back(*it);
            }
        } else {
            for (const auto& value : init) {
                push_back(value);
            }
        }
    }

    FixedVector &operator=(const FixedVector &other) {
        if (this != &other) {
            assign_array(other.memory(), other.current_size);
        }
        return *this;
    }


    ~FixedVector() { clear(); }


    T &operator[](size_t index) { return memory()[index]; }


    const T &operator[](size_t index) const {
        if (index >= current_size) {
            const T *out = nullptr;
            return *out;
        }
        return memory()[index];
    }

    void resize(size_t n) {
        while (current_size < n) {
            push_back(T());
        }
        while (current_size > n) {
            pop_back();
        }
    }


    constexpr size_t size() const { return current_size; }

    constexpr bool empty() const { return current_size == 0; }


    constexpr size_t capacity() const { return N; }


    void push_back(const T &value) {
        if (current_size < N) {
            void *mem = &memory()[current_size];
            new (mem) T(value);
            ++current_size;
        }
    }

    void reserve(size_t n) {
        if (n > N) {

            return;
        }
    }

    void assign_array(const T *values, size_t count) {
        clear();
        for (size_t i = 0; i < count; ++i) {
            push_back(values[i]);
        }
    }

    void assign(const_iterator begin, const_iterator end) {
        clear();
        for (const_iterator it = begin; it != end; ++it) {
            push_back(*it);
        }
    }


    void pop_back() {
        if (current_size > 0) {
            --current_size;
            memory()[current_size].~T();
        }
    }


    void clear() {
        while (current_size > 0) {
            pop_back();
        }
    }


    iterator erase(iterator pos) {
        if (pos != end()) {
            pos->~T();

            for (iterator p = pos; p != end() - 1; ++p) {
                new (p)
                    T(*(p + 1));
                (p + 1)->~T();
            }
            --current_size;
        }
        return pos;
    }

    iterator erase(const T &value) {
        iterator it = find(value);
        if (it != end()) {
            erase(it);
        }
        return it;
    }

    iterator find(const T &value) {
        for (iterator it = begin(); it != end(); ++it) {
            if (*it == value) {
                return it;
            }
        }
        return end();
    }

    template <typename Predicate> iterator find_if(Predicate pred) {
        for (iterator it = begin(); it != end(); ++it) {
            if (pred(*it)) {
                return it;
            }
        }
        return end();
    }

    bool insert(iterator pos, const T &value) {
        if (current_size < N) {







            for (iterator p = end(); p != pos; --p) {





                T temp = *(p - 1);
                (p)->~T();

                void *vp = static_cast<void *>(p);
                memset(vp, 0, sizeof(T));
                new (p) T(temp);

            }
            ++current_size;

            new (pos) T(value);
            return true;
        }
        return false;
    }

    const_iterator find(const T &value) const {
        for (const_iterator it = begin(); it != end(); ++it) {
            if (*it == value) {
                return it;
            }
        }
        return end();
    }

    iterator data() { return begin(); }

    const_iterator data() const { return begin(); }

    bool has(const T &value) const { return find(value) != end(); }


    T &front() { return memory()[0]; }

    const T &front() const { return memory()[0]; }

    T &back() { return memory()[current_size - 1]; }

    const T &back() const { return memory()[current_size - 1]; }


    iterator begin() { return &memory()[0]; }
    const_iterator begin() const { return &memory()[0]; }
    iterator end() { return &memory()[current_size]; }
    const_iterator end() const { return &memory()[current_size]; }

    void swap(FixedVector<T, N> &other) {
        if (this != &other) {
            const int max_size = fl::fl_max(current_size, other.current_size);
            for (int i = 0; i < max_size; ++i) {
                fl::swap(memory()[i], other.memory()[i]);
            }

            size_t temp_size = current_size;
            current_size = other.current_size;
            other.current_size = temp_size;
        }
    }

  private:
    size_t current_size = 0;
};

template <typename T, typename Allocator = fl::allocator<T>> class HeapVector {
  private:
    T* mArray = nullptr;
    size_t mCapacity = 0;
    size_t mSize = 0;
    Allocator mAlloc;

  public:
    typedef T *iterator;
    typedef const T *const_iterator;

    struct reverse_iterator {
        iterator it;
        reverse_iterator(iterator i) : it(i) {}
        T &operator*() { return *(it - 1); }
        reverse_iterator &operator++() {
            --it;
            return *this;
        }
        bool operator!=(const reverse_iterator &other) const {
            return it != other.it;
        }
    };


    HeapVector(size_t size = 0, const T &value = T()) : mCapacity(size), mSize(size) {
        if (size > 0) {

            mArray = mAlloc.allocate(size);
            for (size_t i = 0; i < size; ++i) {
                mAlloc.construct(&mArray[i], value);
            }
        }
    }
    HeapVector(const HeapVector<T> &other) {
        reserve(other.size());
        assign(other.begin(), other.end());
    }
    HeapVector(HeapVector<T> &&other) {
        this->swap(other);
        other.clear();
    }
    HeapVector &operator=(
        const HeapVector<T> &other) {
        if (this != &other) {
            mAlloc = other.mAlloc;
            assign(other.begin(), other.end());
        }
        return *this;
    }

    template <size_t N> HeapVector(T (&values)[N]) {
        T *begin = &values[0];
        T *end = &values[N];
        assign(begin, end);
    }


    HeapVector(fl::initializer_list<T> init) {
        reserve(init.size());
        for (const auto& value : init) {
            push_back(value);
        }
    }


    ~HeapVector() {
        clear();
        if (mArray) {
            for (size_t i = 0; i < mSize; ++i) {
                mAlloc.destroy(&mArray[i]);
            }
            mAlloc.deallocate(mArray, mCapacity);
            mArray = nullptr;
        }
    }

    void ensure_size(size_t n) {
        if (n > mCapacity) {
            size_t new_capacity = (3 * mCapacity) / 2;
            if (new_capacity < n) {
                new_capacity = n;
            }

            T* new_array = mAlloc.allocate(new_capacity);


            for (size_t i = 0; i < mSize; ++i) {
                mAlloc.construct(&new_array[i], mArray[i]);
            }


            if (mArray) {
                for (size_t i = 0; i < mSize; ++i) {
                    mAlloc.destroy(&mArray[i]);
                }
                mAlloc.deallocate(mArray, mCapacity);
            }

            mArray = new_array;
            mCapacity = new_capacity;
        }
    }

    void reserve(size_t n) {
        if (n > mCapacity) {
            ensure_size(n);
        }
    }

    void resize(size_t n) {
        if (mSize == n) {
            return;
        }
        if (n > mCapacity) {
            ensure_size(n);
        }
        while (mSize < n) {
            push_back(T());
        }
        while (mSize > n) {
            pop_back();
        }
    }

    void resize(size_t n, const T &value) {
        if (n > mCapacity) {

            T* new_array = mAlloc.allocate(n);


            for (size_t i = 0; i < mSize; ++i) {
                mAlloc.construct(&new_array[i], mArray[i]);
            }


            for (size_t i = mSize; i < n; ++i) {
                mAlloc.construct(&new_array[i], value);
            }


            if (mArray) {
                for (size_t i = 0; i < mSize; ++i) {
                    mAlloc.destroy(&mArray[i]);
                }
                mAlloc.deallocate(mArray, mCapacity);
            }

            mArray = new_array;
            mCapacity = n;
            mSize = n;
        } else if (n > mSize) {

            for (size_t i = mSize; i < n; ++i) {
                mAlloc.construct(&mArray[i], value);
            }
            mSize = n;
        } else if (n < mSize) {

            for (size_t i = n; i < mSize; ++i) {
                mAlloc.destroy(&mArray[i]);
            }
            mSize = n;
        }
    }

    template <typename InputIt,
              typename = fl::enable_if_t<!fl::is_integral<InputIt>::value>>
    void assign(InputIt begin, InputIt end) {
        clear();
        reserve(end - begin);
        for (InputIt it = begin; it != end; ++it) {
            push_back(*it);
        }
    }

    void assign(size_t new_cap, const T &value) {
        clear();
        reserve(new_cap);
        while (size() < new_cap) {
            push_back(value);
        }
    }


    T &operator[](size_t index) { return mArray[index]; }

    const T &operator[](size_t index) const { return mArray[index]; }


    size_t size() const { return mSize; }

    bool empty() const { return mSize == 0; }

    size_t capacity() const { return mCapacity; }


    void push_back(const T &value) {
        ensure_size(mSize + 1);
        if (mSize < mCapacity) {
            mAlloc.construct(&mArray[mSize], value);
            ++mSize;
        }
    }

    void pop_back() {
        if (mSize > 0) {
            --mSize;
            mAlloc.destroy(&mArray[mSize]);
        }
    }

    void clear() {
        for (size_t i = 0; i < mSize; ++i) {
            mAlloc.destroy(&mArray[i]);
        }
        mSize = 0;
    }


    iterator begin() { return &mArray[0]; }
    const_iterator begin() const { return &mArray[0]; }
    iterator end() { return &mArray[mSize]; }
    const_iterator end() const { return &mArray[mSize]; }

    reverse_iterator rbegin() { return reverse_iterator(end()); }

    reverse_iterator rend() { return reverse_iterator(begin()); }


    T &front() { return mArray[0]; }

    const T &front() const { return mArray[0]; }

    T &back() { return mArray[mSize - 1]; }

    const T &back() const { return mArray[mSize - 1]; }


    iterator find(const T &value) {
        for (iterator it = begin(); it != end(); ++it) {
            if (*it == value) {
                return it;
            }
        }
        return end();
    }

    const_iterator find(const T &value) const {
        for (const_iterator it = begin(); it != end(); ++it) {
            if (*it == value) {
                return it;
            }
        }
        return end();
    }

    template <typename Predicate> iterator find_if(Predicate pred) {
        for (iterator it = begin(); it != end(); ++it) {
            if (pred(*it)) {
                return it;
            }
        }
        return end();
    }

    bool has(const T &value) const { return find(value) != end(); }

    bool erase(iterator pos, T *out_value = nullptr) {
        if (pos == end() || empty()) {
            return false;
        }
        if (out_value) {
            *out_value = *pos;
        }
        while (pos != end() - 1) {
            *pos = *(pos + 1);
            ++pos;
        }
        back() = T();
        --mSize;
        return true;
    }

    void erase(const T &value) {
        iterator it = find(value);
        if (it != end()) {
            erase(it);
        }
    }

    void swap(HeapVector<T> &other) {
        fl::swap(mArray, other.mArray);
        fl::swap(mSize, other.mSize);
        fl::swap(mCapacity, other.mCapacity);
        fl::swap(mAlloc, other.mAlloc);
    }

    void swap(iterator a, iterator b) {
        T temp = *a;
        *a = *b;
        *b = temp;
    }

    bool full() const { return mSize >= mCapacity; }

    bool insert(iterator pos, const T &value) {


        size_t target_idx = pos - begin();
        push_back(value);
        auto last = end() - 1;
        for (size_t curr_idx = last - begin(); curr_idx > target_idx;
             --curr_idx) {
            auto first = begin() + curr_idx - 1;
            auto second = begin() + curr_idx;
            swap(first, second);
        }
        return true;
    }
# 671 "../../src/fl/vector.h"
    T *data() { return mArray; }

    const T *data() const { return mArray; }

    bool operator==(const HeapVector<T> &other) const {
        if (size() != other.size()) {
            return false;
        }
        for (size_t i = 0; i < size(); ++i) {
            if (mArray[i] != other.mArray[i]) {
                return false;
            }
        }
        return true;
    }

    bool operator!=(const HeapVector<T> &other) const {
        return !(*this == other);
    }
};

template <typename T, typename LessThan = fl::less<T>> class SortedHeapVector {
  private:
    HeapVector<T> mArray;
    LessThan mLess;
    size_t mMaxSize = size_t(-1);

  public:
    typedef typename HeapVector<T>::iterator iterator;
    typedef typename HeapVector<T>::const_iterator const_iterator;

    SortedHeapVector(LessThan less = LessThan()) : mLess(less) {}

    void setMaxSize(size_t n) {
        if (mMaxSize == n) {
            return;
        }
        mMaxSize = n;
        const bool needs_adjustment = mArray.size() > mMaxSize;
        if (needs_adjustment) {
            mArray.resize(n);
        } else {
            mArray.reserve(n);
        }
    }

    ~SortedHeapVector() { mArray.clear(); }

    void reserve(size_t n) { mArray.reserve(n); }


    bool insert(const T &value, InsertResult *result = nullptr) {

        iterator pos = lower_bound(value);
        if (pos != end() && !mLess(value, *pos) && !mLess(*pos, value)) {

            if (result) {

                *result = InsertResult::kExists;
            }

            return false;
        }
        if (mArray.size() >= mMaxSize) {

            if (result) {
                *result = InsertResult::kMaxSize;
            }
            return false;
        }
        mArray.insert(pos, value);
        if (result) {
            *result = kInserted;
        }

        return true;
    }



    iterator lower_bound(const T &value) {
        iterator first = mArray.begin();
        iterator last = mArray.end();

        while (first != last) {
            iterator mid = first + (last - first) / 2;

            if (mLess(*mid, value)) {
                first = mid + 1;
            } else {
                last = mid;
            }
        }
        return first;
    }

    const_iterator lower_bound(const T &value) const {
        return const_cast<SortedHeapVector *>(this)->lower_bound(value);
    }


    iterator find(const T &value) {
        iterator pos = lower_bound(value);
        if (pos != end() && !mLess(value, *pos) && !mLess(*pos, value)) {
            return pos;
        }
        return end();
    }

    void swap(SortedHeapVector &other) { mArray.swap(other.mArray); }

    const_iterator find(const T &value) const {
        return const_cast<SortedHeapVector *>(this)->find(value);
    }

    bool has(const T &value) const { return find(value) != end(); }


    bool erase(const T &value) {
        iterator it = find(value);
        if (it != end()) {
            return mArray.erase(it);
        }
        return false;
    }

    bool erase(iterator pos) { return mArray.erase(pos); }


    size_t size() const { return mArray.size(); }
    bool empty() const { return mArray.empty(); }
    size_t capacity() const { return mArray.capacity(); }
    void clear() { mArray.clear(); }
    bool full() const {
        if (mArray.size() >= mMaxSize) {
            return true;
        }
        return mArray.full();
    }


    T &operator[](size_t index) { return mArray[index]; }
    const T &operator[](size_t index) const { return mArray[index]; }

    T &front() { return mArray.front(); }
    const T &front() const { return mArray.front(); }

    T &back() { return mArray.back(); }
    const T &back() const { return mArray.back(); }


    iterator begin() { return mArray.begin(); }
    const_iterator begin() const { return mArray.begin(); }
    iterator end() { return mArray.end(); }
    const_iterator end() const { return mArray.end(); }


    T *data() { return mArray.data(); }
    const T *data() const { return mArray.data(); }
};

template <typename T, size_t INLINED_SIZE> class InlinedVector {
  public:
    using iterator = typename FixedVector<T, INLINED_SIZE>::iterator;
    using const_iterator =
        typename FixedVector<T, INLINED_SIZE>::const_iterator;

    InlinedVector() = default;
    InlinedVector(const InlinedVector &other) {
        if (other.mUsingHeap) {
            mHeap = other.mHeap;
            mUsingHeap = true;
        } else {
            mFixed = other.mFixed;
            mUsingHeap = false;
        }
    }
    InlinedVector(InlinedVector &&other) {

        fl::swap(*this, other);
        other.clear();
    }
    InlinedVector(size_t size) : mUsingHeap(false) {
        if (size > INLINED_SIZE) {
            mHeap.resize(size);
            mUsingHeap = true;
        } else {
            mFixed.resize(size);
        }
    }


    InlinedVector(fl::initializer_list<T> init) : mUsingHeap(false) {
        if (init.size() > INLINED_SIZE) {
            mHeap.reserve(init.size());
            for (const auto& value : init) {
                mHeap.push_back(value);
            }
            mUsingHeap = true;
        } else {
            for (const auto& value : init) {
                mFixed.push_back(value);
            }
        }
    }

    InlinedVector &operator=(const InlinedVector &other) {
        if (this != &other) {
            assign(other.begin(), other.end());
        }
        return *this;
    }

    InlinedVector &operator=(InlinedVector &&other) {
        this->clear();
        if (this != &other) {
            if (other.mUsingHeap) {
                mHeap.swap(other.mHeap);
                mUsingHeap = true;
            } else {
                mFixed.swap(other.mFixed);
                mUsingHeap = false;
            }
            other.clear();
        }
        return *this;
    }

    void reserve(size_t size) {
        if (size > INLINED_SIZE) {
            if (mUsingHeap) {
                mHeap.reserve(size);
            } else {
                mHeap.reserve(size);
                for (auto &v : mFixed) {
                    mHeap.push_back(v);
                }
                mFixed.clear();
                mUsingHeap = true;
            }
        } else {
            if (mUsingHeap) {
                mFixed.reserve(size);
                for (auto &v : mHeap) {
                    mFixed.push_back(v);
                }
                mHeap.clear();
                mUsingHeap = false;
            } else {
                mFixed.reserve(size);
            }
        }
    }

    void resize(size_t size) {
        if (size > INLINED_SIZE) {
            if (mUsingHeap) {
                mHeap.resize(size);
            } else {
                mHeap.resize(size);
                for (auto &v : mFixed) {
                    mHeap.push_back(v);
                }
                mFixed.clear();
                mUsingHeap = true;
            }
        } else {
            if (mUsingHeap) {
                mFixed.resize(size);
                for (auto &v : mHeap) {
                    mFixed.push_back(v);
                }
                mHeap.clear();
                mUsingHeap = false;
            } else {
                mFixed.resize(size);
            }
        }
    }


    size_t size() const { return mUsingHeap ? mHeap.size() : mFixed.size(); }
    bool empty() const { return size() == 0; }
    T *data() { return mUsingHeap ? mHeap.data() : mFixed.data(); }
    const T *data() const { return mUsingHeap ? mHeap.data() : mFixed.data(); }

    void assign(size_t new_cap, const T &value) {
        clear();
        if (INLINED_SIZE > new_cap) {

            while (size() < new_cap) {
                mFixed.push_back(value);
            }
            return;
        }

        mHeap.reserve(new_cap);
        mUsingHeap = true;
        while (size() < new_cap) {
            mHeap.push_back(value);
        }
    }

    template <typename InputIt,
              typename = fl::enable_if_t<!fl::is_integral<InputIt>::value>>
    void assign(InputIt begin, InputIt end) {
        clear();
        if (uint32_t(end - begin) <= INLINED_SIZE) {
            mFixed.assign(begin, end);
            return;
        }
        mHeap.assign(begin, end);
        mUsingHeap = true;
    }
# 997 "../../src/fl/vector.h"
    T &operator[](size_t idx) { return mUsingHeap ? mHeap[idx] : mFixed[idx]; }
    const T &operator[](size_t idx) const {
        return mUsingHeap ? mHeap[idx] : mFixed[idx];
    }

    bool full() const { return INLINED_SIZE == size(); }


    void push_back(const T &value) {
        if (!mUsingHeap) {
            if (mFixed.size() < INLINED_SIZE) {
                mFixed.push_back(value);
                return;
            }

            mHeap.reserve(INLINED_SIZE * 2);
            for (auto &v : mFixed) {
                mHeap.push_back(v);
            }
            mFixed.clear();
            mUsingHeap = true;
        }
        mHeap.push_back(value);
    }


    void pop_back() {
        if (mUsingHeap) {
            mHeap.pop_back();
        } else {
            mFixed.pop_back();
        }
    }


    void clear() {
        if (mUsingHeap) {
            mHeap.clear();

        } else {
            mFixed.clear();
        }
    }

    template <typename Predicate> iterator find_if(Predicate pred) {
        for (iterator it = begin(); it != end(); ++it) {
            if (pred(*it)) {
                return it;
            }
        }
        return end();
    }

    void erase(iterator pos) {
        if (mUsingHeap) {
            mHeap.erase(pos);
        } else {
            mFixed.erase(pos);
        }
    }

    bool insert(iterator pos, const T &value) {
        if (mUsingHeap) {

            return mHeap.insert(pos, value);
        }

        if (mFixed.size() < INLINED_SIZE) {
            return mFixed.insert(pos, value);
        }



        size_t idx = mFixed.end() - pos;


        mHeap.reserve(INLINED_SIZE * 2);
        for (auto &v : mFixed) {
            mHeap.push_back(v);
        }
        mFixed.clear();
        return mHeap.insert(mHeap.begin() + idx, value);
    }


    iterator begin() { return mUsingHeap ? mHeap.begin() : mFixed.begin(); }
    iterator end() { return mUsingHeap ? mHeap.end() : mFixed.end(); }
    const_iterator begin() const {
        return mUsingHeap ? mHeap.begin() : mFixed.begin();
    }
    const_iterator end() const {
        return mUsingHeap ? mHeap.end() : mFixed.end();
    }


    T &front() { return mUsingHeap ? mHeap.front() : mFixed.front(); }
    const T &front() const {
        return mUsingHeap ? mHeap.front() : mFixed.front();
    }

    T &back() { return mUsingHeap ? mHeap.back() : mFixed.back(); }
    const T &back() const { return mUsingHeap ? mHeap.back() : mFixed.back(); }

    void swap(InlinedVector &other) {
        if (this != &other) {
            fl::swap(mUsingHeap, other.mUsingHeap);
            fl::swap(mFixed, other.mFixed);
            fl::swap(mHeap, other.mHeap);
        }
    }

  private:
    bool mUsingHeap = false;
    FixedVector<T, INLINED_SIZE> mFixed;
    HeapVector<T> mHeap;
};

template <typename T, typename Allocator = fl::allocator<T>> using vector = HeapVector<T, Allocator>;

template <typename T, size_t INLINED_SIZE>
using vector_fixed = FixedVector<T, INLINED_SIZE>;

template <typename T, size_t INLINED_SIZE = 64>
using vector_inlined = InlinedVector<T, INLINED_SIZE>;

}
# 20 "../../src/fl/str.h" 2






struct CRGB;
;

namespace fl {


class string;
using Str = fl::string;
class Tile2x2_u8_wrap;
class JsonUiInternal;

template <typename T> struct rect;
template <typename T> struct vec2;
template <typename T> struct vec3;
template <typename T> class Slice;
template <typename T, typename Allocator> class HeapVector;
template <typename T, size_t N> class InlinedVector;
template <typename T, size_t N> class FixedVector;
template <size_t N> class StrN;

template <typename T> class WeakPtr;
template <typename T> class Ptr;

template <typename T> struct Hash;

template <typename T> struct EqualTo;

template <typename Key, typename Hash, typename KeyEqual> class HashSet;

class XYMap;

struct FFTBins;
# 75 "../../src/fl/str.h"
class StringHolder; using StringHolderPtr = fl::Ptr<StringHolder>;;

class StringFormatter {
  public:
    static void append(int32_t val, StrN<64> *dst);
    static bool isSpace(char c) {
        return c == ' ' || c == '\t' || c == '\n' || c == '\r';
    }
    static float parseFloat(const char *str, size_t len);
    static bool isDigit(char c) { return c >= '0' && c <= '9'; }
    static void appendFloat(const float &val, StrN<64> *dst);
};

class StringHolder : public fl::Referent {
  public:
    StringHolder(const char *str);
    StringHolder(size_t length);
    StringHolder(const char *str, size_t length);
    StringHolder(const StringHolder &other) = delete;
    StringHolder &operator=(const StringHolder &other) = delete;
    ~StringHolder();

    bool isShared() const { return ref_count() > 1; }
    void grow(size_t newLength);
    bool hasCapacity(size_t newLength) const { return newLength <= mCapacity; }
    const char *data() const { return mData; }
    char *data() { return mData; }
    size_t length() const { return mLength; }
    size_t capacity() const { return mCapacity; }
    bool copy(const char *str, size_t len) {
        if ((len + 1) > mCapacity) {
            return false;
        }
        memcpy(mData, str, len);
        mData[len] = '\0';
        mLength = len;
        return true;
    }

  private:
    char *mData = nullptr;
    size_t mLength = 0;
    size_t mCapacity = 0;
};

template <size_t SIZE = 64> class StrN {
  protected:
    size_t mLength = 0;
    char mInlineData[SIZE] = {0};
    StringHolderPtr mHeapData;

  public:

    StrN() = default;


    template <size_t M> StrN(const StrN<M> &other) { copy(other); }
    StrN(const char *str) {
        size_t len = strlen(str);
        mLength = len;
        if (len + 1 <= SIZE) {
            memcpy(mInlineData, str, len + 1);
            mHeapData.reset();
        } else {
            mHeapData = StringHolderPtr::New(str);
        }
    }
    StrN(const StrN &other) { copy(other); }
    void copy(const char *str) {
        size_t len = strlen(str);
        mLength = len;
        if (len + 1 <= SIZE) {
            memcpy(mInlineData, str, len + 1);
            mHeapData.reset();
        } else {
            if (mHeapData && !mHeapData->isShared()) {

                mHeapData->copy(str, len);
                return;
            }
            mHeapData.reset();
            mHeapData = StringHolderPtr::New(str);
        }
    }

    template <int N> StrN(const char (&str)[N]) {
        copy(str, N - 1);
    }
    template <int N> StrN &operator=(const char (&str)[N]) {
        assign(str, N);
        return *this;
    }
    StrN &operator=(const StrN &other) {
        copy(other);
        return *this;
    }
    template <size_t M> StrN &operator=(const StrN<M> &other) {
        copy(other);
        return *this;
    }


    bool operator==(const StrN &other) const {
        return strcmp(c_str(), other.c_str()) == 0;
    }

    bool operator!=(const StrN &other) const {
        return strcmp(c_str(), other.c_str()) != 0;
    }

    void copy(const char *str, size_t len) {
        mLength = len;
        if (len + 1 <= SIZE) {
            memcpy(mInlineData, str, len + 1);
            mHeapData.reset();
        } else {
            mHeapData = StringHolderPtr::New(str, len);
        }
    }

    template <size_t M> void copy(const StrN<M> &other) {
        size_t len = other.size();
        if (len + 1 <= SIZE) {
            memcpy(mInlineData, other.c_str(), len + 1);
            mHeapData.reset();
        } else {
            if (other.mHeapData) {
                mHeapData = other.mHeapData;
            } else {
                mHeapData = StringHolderPtr::New(other.c_str());
            }
        }
        mLength = len;
    }

    size_t capacity() const { return mHeapData ? mHeapData->capacity() : SIZE; }

    size_t write(const uint8_t *data, size_t n) {
        const char *str = reinterpret_cast<const char *>(data);
        return write(str, n);
    }

    size_t write(const char *str, size_t n) {
        size_t newLen = mLength + n;
        if (mHeapData && !mHeapData->isShared()) {
            if (!mHeapData->hasCapacity(newLen)) {
                size_t grow_length = fl::fl_max(3, newLen * 3 / 2);
                mHeapData->grow(grow_length);
            }
            memcpy(mHeapData->data() + mLength, str, n);
            mLength = newLen;
            mHeapData->data()[mLength] = '\0';
            return mLength;
        }
        if (newLen + 1 <= SIZE) {
            memcpy(mInlineData + mLength, str, n);
            mLength = newLen;
            mInlineData[mLength] = '\0';
            return mLength;
        }
        mHeapData.reset();
        StringHolderPtr newData = StringHolderPtr::New(newLen);
        if (newData) {
            memcpy(newData->data(), c_str(), mLength);
            memcpy(newData->data() + mLength, str, n);
            newData->data()[newLen] = '\0';
            mHeapData = newData;
            mLength = newLen;
        }
        mHeapData = newData;
        return mLength;
    }

    size_t write(char c) { return write(&c, 1); }

    size_t write(uint8_t c) {
        const char *str = reinterpret_cast<const char *>(&c);
        return write(str, 1);
    }

    size_t write(const uint16_t &n) {
        StrN<64> dst;
        StringFormatter::append(n, &dst);
        return write(dst.c_str(), dst.size());
    }

    size_t write(const uint32_t &val) {
        StrN<64> dst;
        StringFormatter::append(val, &dst);
        return write(dst.c_str(), dst.size());
    }

    size_t write(const int32_t &val) {
        StrN<64> dst;
        StringFormatter::append(val, &dst);
        return write(dst.c_str(), dst.size());
    }

    size_t write(const int8_t val) {
        StrN<64> dst;
        StringFormatter::append(int16_t(val),
                                &dst);
        return write(dst.c_str(), dst.size());
    }


    ~StrN() {}


    size_t size() const { return mLength; }
    size_t length() const { return size(); }
    const char *c_str() const {
        return mHeapData ? mHeapData->data() : mInlineData;
    }

    char *c_str_mutable() {
        return mHeapData ? mHeapData->data() : mInlineData;
    }

    char &operator[](size_t index) {
        if (index >= mLength) {
            static char dummy = '\0';
            return dummy;
        }
        return c_str_mutable()[index];
    }

    char operator[](size_t index) const {
        if (index >= mLength) {
            static char dummy = '\0';
            return dummy;
        }
        return c_str()[index];
    }

    bool empty() const { return mLength == 0; }



    bool operator<(const StrN &other) const {
        return strcmp(c_str(), other.c_str()) < 0;
    }

    template <size_t M> bool operator<(const StrN<M> &other) const {
        return strcmp(c_str(), other.c_str()) < 0;
    }

    void reserve(size_t newCapacity) {

        if (newCapacity <= mLength) {
            return;
        }


        if (newCapacity + 1 <= SIZE) {
            return;
        }



        if (mHeapData && !mHeapData->isShared() &&
            mHeapData->hasCapacity(newCapacity)) {
            return;
        }


        StringHolderPtr newData = StringHolderPtr::New(newCapacity);
        if (newData) {

            memcpy(newData->data(), c_str(), mLength);
            newData->data()[mLength] = '\0';
            mHeapData = newData;
        }
    }

    void clear(bool freeMemory = false) {
        mLength = 0;
        if (freeMemory && mHeapData) {
            mHeapData.reset();
        }
    }




    size_t find(const char &value) const {
        for (size_t i = 0; i < mLength; ++i) {
            if (c_str()[i] == value) {
                return i;
            }
        }
        return static_cast<size_t>(-1);
    }


    size_t find(const char* substr) const {
        if (!substr) {
            return static_cast<size_t>(-1);
        }
        auto begin = c_str();
        const char* found = strstr(begin, substr);
        if (found) {
            return found - begin;
        }
        return static_cast<size_t>(-1);
    }


    template<size_t M>
    size_t find(const StrN<M>& other) const {
        return find(other.c_str());
    }

    StrN substring(size_t start, size_t end) const {

        if (start == 0 && end == mLength) {
            return *this;
        }
        if (start >= mLength) {
            return StrN();
        }
        if (end > mLength) {
            end = mLength;
        }
        if (start >= end) {
            return StrN();
        }
        StrN out;
        out.copy(c_str() + start, end - start);
        return out;
    }

     StrN substr(size_t start, size_t end) {
        return substring(start, end);
    }

    StrN trim() const {
        StrN out;
        size_t start = 0;
        size_t end = mLength;
        while (start < mLength && StringFormatter::isSpace(c_str()[start])) {
            start++;
        }
        while (end > start && StringFormatter::isSpace(c_str()[end - 1])) {
            end--;
        }
        return substring(start, end);
    }

    float toFloat() const {
        return StringFormatter::parseFloat(c_str(), mLength);
    }

  private:
    StringHolderPtr mData;
};

class string : public StrN<64> {
  public:

    static const size_t npos = static_cast<size_t>(-1);

    string() : StrN<64>() {}
    string(const char *str) : StrN<64>(str) {}
    string(const string &other) : StrN<64>(other) {}
    template <size_t M>
    string(const StrN<M> &other) : StrN<64>(other) {}
    string &operator=(const string &other) {
        copy(other);
        return *this;
    }

    string &operator=(const char *str) {
        copy(str, strlen(str));
        return *this;
    }
# 467 "../../src/fl/str.h"
    bool operator>(const string &other) const {
        return strcmp(c_str(), other.c_str()) > 0;
    }

    bool operator>=(const string &other) const {
        return strcmp(c_str(), other.c_str()) >= 0;
    }

    bool operator<(const string &other) const {
        return strcmp(c_str(), other.c_str()) < 0;
    }

    bool operator<=(const string &other) const {
        return strcmp(c_str(), other.c_str()) <= 0;
    }

    bool operator==(const string &other) const {
        return strcmp(c_str(), other.c_str()) == 0;
    }

    bool operator!=(const string &other) const {
        return strcmp(c_str(), other.c_str()) != 0;
    }

    string &operator+=(const string &other) {
        append(other.c_str(), other.size());
        return *this;
    }

    template <typename T> string &operator+=(const T &val) {
        append(val);
        return *this;
    }

    char front() const {
        if (empty()) {
            return '\0';
        }
        return c_str()[0];
    }
    char back() const {
        if (empty()) {
            return '\0';
        }
        return c_str()[size() - 1];
    }





    template <typename T, typename = fl::enable_if_t<fl::is_integral<T>::value>>
    string &append(const T &val) {
        write(int32_t(val));
        return *this;
    }

    template <typename T> string &append(const Slice<T> &slice) {
        append("[");
        for (size_t i = 0; i < slice.size(); ++i) {
            if (i > 0) {
                append(", ");
            }
            append(slice[i]);
        }
        append("]");
        return *this;
    }

    template <typename T> string &append(const fl::HeapVector<T> &vec) {
        Slice<const T> slice(vec.data(), vec.size());
        append(slice);
        return *this;
    }

    template <typename T, size_t N>
    string &append(const fl::InlinedVector<T, N> &vec) {
        Slice<const T> slice(vec.data(), vec.size());
        append(slice);
        return *this;
    }

    string &append(const char *str) {
        write(str, strlen(str));
        return *this;
    }
    string &append(const char *str, size_t len) {
        write(str, len);
        return *this;
    }

    string &append(const int8_t &c) {
        const char *str = reinterpret_cast<const char *>(&c);
        write(str, 1);
        return *this;
    }
    string &append(const uint8_t &c) {
        write(uint16_t(c));
        return *this;
    }
    string &append(const uint16_t &val) {
        write(val);
        return *this;
    }
    string &append(const int16_t &val) {
        write(int32_t(val));
        return *this;
    }
    string &append(const uint32_t &val) {
        write(val);
        return *this;
    }
    string &append(const int32_t &c) {
        write(c);
        return *this;
    }

    string &append(const bool &val) {
        if (val) {
            return append("true");
        } else {
            return append("false");
        }
    }

    template <typename T> string &append(const rect<T> &rect) {
        append(rect.mMin.x);
        append(",");
        append(rect.mMin.y);
        append(",");
        append(rect.mMax.x);
        append(",");
        append(rect.mMax.y);
        return *this;
    }

    template <typename T> string &append(const vec2<T> &pt) {
        append("(");
        append(pt.x);
        append(",");
        append(pt.y);
        append(")");
        return *this;
    }

    template <typename T> string &append(const vec3<T> &pt) {
        append("(");
        append(pt.x);
        append(",");
        append(pt.y);
        append(",");
        append(pt.z);
        append(")");
        return *this;
    }


    template <typename T> string &append(const WeakPtr<T> &val) {
        Ptr<T> ptr = val.lock();
        append(ptr);
        return *this;
    }

    template <typename T> string &append(const Ptr<T>& val) {

        if (!val) {
            append("null");
        } else {
            T* ptr = val.get();
            append(*ptr);
        }
        return *this;
    }

    string &append(const JsonUiInternal& val);

    template <typename T, size_t N>
    string &append(const fl::FixedVector<T, N> &vec) {
        Slice<const T> slice(vec.data(), vec.size());
        append(slice);
        return *this;
    }

    string &append(const CRGB &c);

    string &append(const float &_val) {

        StringFormatter::appendFloat(_val, this);
        return *this;
    }

    string &append(const double &val) { return append(float(val)); }

    string &append(const StrN &str) {
        write(str.c_str(), str.size());
        return *this;
    }

    string &append(const FFTBins &str);

    string &append(const XYMap &map);

    string &append(const Tile2x2_u8_wrap &tile);

    template <typename Key, typename Hash, typename KeyEqual>
    string &append(const HashSet<Key, Hash, KeyEqual> &set) {
        append("{");
        for (auto it = set.begin(); it != set.end(); ++it) {
            if (it != set.begin()) {
                append(", ");
            }
            auto p = *it;
            append(p.first);
        }
        append("}");
        return *this;
    }

    const char *data() const { return c_str(); }

    void swap(string &other);

  private:
    enum {






        kStrInlineSize = 64,
    };

    static void compileTimeAssertions();
};

}
# 13 "../../src/crgb.hpp" 2









__attribute__((always_inline)) inline CRGB& CRGB::addToRGB (uint8_t d )
{
    r = qadd8( r, d);
    g = qadd8( g, d);
    b = qadd8( b, d);
    return *this;
}

__attribute__((always_inline)) inline CRGB& CRGB::operator-= (const CRGB& rhs )
{
    r = qsub8( r, rhs.r);
    g = qsub8( g, rhs.g);
    b = qsub8( b, rhs.b);
    return *this;
}


__attribute__((always_inline)) inline CRGB& CRGB::operator++ ()
{
    addToRGB(1);
    return *this;
}


__attribute__((always_inline)) inline CRGB CRGB::operator++ (int )
{
    CRGB retval(*this);
    ++(*this);
    return retval;
}

__attribute__((always_inline)) inline CRGB& CRGB::subtractFromRGB(uint8_t d)
{
    r = qsub8( r, d);
    g = qsub8( g, d);
    b = qsub8( b, d);
    return *this;
}

__attribute__((always_inline)) inline CRGB& CRGB::operator*= (uint8_t d )
{
    r = qmul8( r, d);
    g = qmul8( g, d);
    b = qmul8( b, d);
    return *this;
}

__attribute__((always_inline)) inline CRGB& CRGB::nscale8_video(uint8_t scaledown )
{
    nscale8x3_video( r, g, b, scaledown);
    return *this;
}

__attribute__((always_inline)) inline CRGB& CRGB::operator%= (uint8_t scaledown )
{
    nscale8x3_video( r, g, b, scaledown);
    return *this;
}

__attribute__((always_inline)) inline CRGB& CRGB::fadeLightBy (uint8_t fadefactor )
{
    nscale8x3_video( r, g, b, 255 - fadefactor);
    return *this;
}


__attribute__((always_inline)) inline CRGB& CRGB::operator-- ()
{
    subtractFromRGB(1);
    return *this;
}


__attribute__((always_inline)) inline CRGB CRGB::operator-- (int )
{
    CRGB retval(*this);
    --(*this);
    return retval;
}


constexpr CRGB CRGB::nscale8_constexpr(const CRGB scaledown) const
{
    return CRGB(
        scale8_constexpr(r, scaledown.r),
        scale8_constexpr(g, scaledown.g),
        scale8_constexpr(b, scaledown.b)
    );
}


__attribute__((always_inline)) inline CRGB& CRGB::nscale8 (const CRGB & scaledown )
{
    r = ::scale8(r,scaledown.r);
    g = ::scale8(g,scaledown.g);
    b = ::scale8(b,scaledown.b);
    return *this;
}

__attribute__((always_inline)) inline CRGB CRGB::scale8 (uint8_t scaledown ) const
{
    CRGB out = *this;
    nscale8x3( out.r, out.g, out.b, scaledown);
    return out;
}

__attribute__((always_inline)) inline CRGB CRGB::scale8 (const CRGB & scaledown ) const
{
    CRGB out;
    out.r = ::scale8(r,scaledown.r);
    out.g = ::scale8(g,scaledown.g);
    out.b = ::scale8(b,scaledown.b);
    return out;
}


__attribute__((always_inline)) inline uint8_t CRGB::getLuma( ) const {



    uint8_t luma = scale8_LEAVING_R1_DIRTY( r, 54) +
    scale8_LEAVING_R1_DIRTY( g, 183) +
    scale8_LEAVING_R1_DIRTY( b, 18);
    cleanup_R1();
    return luma;
}

__attribute__((always_inline)) inline uint8_t CRGB::getAverageLight( ) const {

    const uint8_t eightyfive = 85;



    uint8_t avg = scale8_LEAVING_R1_DIRTY( r, eightyfive) +
    scale8_LEAVING_R1_DIRTY( g, eightyfive) +
    scale8_LEAVING_R1_DIRTY( b, eightyfive);
    cleanup_R1();
    return avg;
}



__attribute__((always_inline)) inline CRGB CRGB::lerp16( const CRGB& other, fract16 frac) const
{
    CRGB ret;

    ret.r = lerp16by16(r<<8,other.r<<8,frac)>>8;
    ret.g = lerp16by16(g<<8,other.g<<8,frac)>>8;
    ret.b = lerp16by16(b<<8,other.b<<8,frac)>>8;

    return ret;
}



__attribute__((always_inline)) inline CRGB operator+( const CRGB& p1, const CRGB& p2)
{
    return CRGB( qadd8( p1.r, p2.r),
                 qadd8( p1.g, p2.g),
                 qadd8( p1.b, p2.b));
}


__attribute__((always_inline)) inline CRGB operator-( const CRGB& p1, const CRGB& p2)
{
    return CRGB( qsub8( p1.r, p2.r),
                 qsub8( p1.g, p2.g),
                 qsub8( p1.b, p2.b));
}


__attribute__((always_inline)) inline CRGB operator*( const CRGB& p1, uint8_t d)
{
    return CRGB( qmul8( p1.r, d),
                 qmul8( p1.g, d),
                 qmul8( p1.b, d));
}


__attribute__((always_inline)) inline CRGB operator%( const CRGB& p1, uint8_t d)
{
    CRGB retval( p1);
    retval.nscale8_video( d);
    return retval;
}


# 12 "../../src/pixeltypes.h" 2
# 11 "../../src/cpixel_ledcontroller.h" 2




# 1 "../../src/pixel_controller.h" 1
       
# 12 "../../src/pixel_controller.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 13 "../../src/pixel_controller.h" 2



# 1 "../../src/rgbw.h" 1



       










enum RGBW_MODE {
    kRGBWInvalid,
    kRGBWNullWhitePixel,
    kRGBWExactColors,
    kRGBWBoostedWhite,
    kRGBWMaxBrightness,
    kRGBWUserFunction
};

enum {
    kRGBWDefaultColorTemp = 6000,
};

struct Rgbw {
    explicit Rgbw(uint16_t white_color_temp = kRGBWDefaultColorTemp,
                  RGBW_MODE rgbw_mode = kRGBWExactColors,
                  EOrderW _w_placement = WDefault)
        : white_color_temp(white_color_temp), w_placement(_w_placement),
          rgbw_mode(rgbw_mode) {}
    uint16_t white_color_temp = kRGBWDefaultColorTemp;
    EOrderW w_placement = WDefault;
    RGBW_MODE rgbw_mode = kRGBWExactColors;
    __attribute__((always_inline)) inline bool active() const {
        return rgbw_mode != kRGBWInvalid;
    }

    static uint32_t size_as_rgb(uint32_t num_of_rgbw_pixels) {




        num_of_rgbw_pixels = (num_of_rgbw_pixels * 4 + 2) / 3;
        uint32_t extra = num_of_rgbw_pixels % 3 ? 1 : 0;
        num_of_rgbw_pixels += extra;
        return num_of_rgbw_pixels;
    }
};

struct RgbwInvalid : public Rgbw {
    RgbwInvalid() {
        white_color_temp = kRGBWDefaultColorTemp;
        rgbw_mode = kRGBWInvalid;
    }
    static Rgbw value() {
        RgbwInvalid invalid;
        return invalid;
    }
};

struct RgbwDefault : public Rgbw {
    RgbwDefault() {
        white_color_temp = kRGBWDefaultColorTemp;
        rgbw_mode = kRGBWExactColors;
    }
    static Rgbw value() {
        RgbwDefault _default;
        return _default;
    }
};

struct RgbwWhiteIsOff : public Rgbw {
    RgbwWhiteIsOff() {
        white_color_temp = kRGBWDefaultColorTemp;
        rgbw_mode = kRGBWNullWhitePixel;
    }
    static Rgbw value() {
        RgbwWhiteIsOff _default;
        return _default;
    }
};

typedef void (*rgb_2_rgbw_function)(uint16_t w_color_temperature, uint8_t r,
                                    uint8_t g, uint8_t b, uint8_t r_scale,
                                    uint8_t g_scale, uint8_t b_scale,
                                    uint8_t *out_r, uint8_t *out_g,
                                    uint8_t *out_b, uint8_t *out_w);
# 105 "../../src/rgbw.h"
void rgb_2_rgbw_exact(uint16_t w_color_temperature, uint8_t r, uint8_t g,
                      uint8_t b, uint8_t r_scale, uint8_t g_scale,
                      uint8_t b_scale, uint8_t *out_r, uint8_t *out_g,
                      uint8_t *out_b, uint8_t *out_w);
# 118 "../../src/rgbw.h"
void rgb_2_rgbw_max_brightness(uint16_t w_color_temperature, uint8_t r,
                               uint8_t g, uint8_t b, uint8_t r_scale,
                               uint8_t g_scale, uint8_t b_scale, uint8_t *out_r,
                               uint8_t *out_g, uint8_t *out_b, uint8_t *out_w);






void rgb_2_rgbw_null_white_pixel(uint16_t w_color_temperature, uint8_t r,
                                 uint8_t g, uint8_t b, uint8_t r_scale,
                                 uint8_t g_scale, uint8_t b_scale,
                                 uint8_t *out_r, uint8_t *out_g, uint8_t *out_b,
                                 uint8_t *out_w);


void rgb_2_rgbw_white_boosted(uint16_t w_color_temperature, uint8_t r,
                              uint8_t g, uint8_t b, uint8_t r_scale,
                              uint8_t g_scale, uint8_t b_scale, uint8_t *out_r,
                              uint8_t *out_g, uint8_t *out_b, uint8_t *out_w);

void rgb_2_rgbw_user_function(uint16_t w_color_temperature, uint8_t r,
                              uint8_t g, uint8_t b, uint8_t r_scale,
                              uint8_t g_scale, uint8_t b_scale, uint8_t *out_r,
                              uint8_t *out_g, uint8_t *out_b, uint8_t *out_w);

void set_rgb_2_rgbw_function(rgb_2_rgbw_function func);




__attribute__((always_inline)) inline void rgb_2_rgbw(
    RGBW_MODE mode, uint16_t w_color_temperature, uint8_t r, uint8_t g,
    uint8_t b, uint8_t r_scale, uint8_t g_scale, uint8_t b_scale,
    uint8_t *out_r, uint8_t *out_g, uint8_t *out_b, uint8_t *out_w) {
    switch (mode) {
    case kRGBWInvalid:
    case kRGBWNullWhitePixel:
        rgb_2_rgbw_null_white_pixel(w_color_temperature, r, g, b, r_scale,
                                    g_scale, b_scale, out_r, out_g, out_b,
                                    out_w);
        return;
    case kRGBWExactColors:
        rgb_2_rgbw_exact(w_color_temperature, r, g, b, r_scale, g_scale,
                         b_scale, out_r, out_g, out_b, out_w);
        return;
    case kRGBWBoostedWhite:
        rgb_2_rgbw_white_boosted(w_color_temperature, r, g, b, r_scale, g_scale,
                                 b_scale, out_r, out_g, out_b, out_w);
        return;
    case kRGBWMaxBrightness:
        rgb_2_rgbw_max_brightness(w_color_temperature, r, g, b, r_scale,
                                  g_scale, b_scale, out_r, out_g, out_b, out_w);
        return;
    case kRGBWUserFunction:
        rgb_2_rgbw_user_function(w_color_temperature, r, g, b, r_scale, g_scale,
                                 b_scale, out_r, out_g, out_b, out_w);
        return;
    }
    rgb_2_rgbw_null_white_pixel(w_color_temperature, r, g, b, r_scale, g_scale,
                                b_scale, out_r, out_g, out_b, out_w);
}


template <RGBW_MODE MODE>
__attribute__((always_inline)) inline void
rgb_2_rgbw(uint16_t w_color_temperature, uint8_t r, uint8_t g, uint8_t b,
           uint8_t r_scale, uint8_t g_scale, uint8_t b_scale, uint8_t *out_r,
           uint8_t *out_g, uint8_t *out_b, uint8_t *out_w) {

    rgb_2_rgbw(MODE, w_color_temperature, r, g, b, r_scale, g_scale, b_scale,
               out_r, out_g, out_b, out_w);
}







void rgbw_partial_reorder(EOrderW w_placement, uint8_t b0, uint8_t b1,
                          uint8_t b2, uint8_t w, uint8_t *out_b0,
                          uint8_t *out_b1, uint8_t *out_b2, uint8_t *out_b3);



# 17 "../../src/pixel_controller.h" 2
# 1 "../../src/fl/five_bit_hd_gamma.h" 1



       

# 1 "../../src/fl/gamma.h" 1
       




namespace fl {

inline void gamma16(const CRGB &rgb, uint16_t* r16, uint16_t* g16, uint16_t* b16) {

    static const uint16_t _gamma_2_8[256] = {
        0, 0, 0, 1, 1, 2, 4, 6, 8, 11,
        14, 18, 23, 29, 35, 41, 49, 57, 67, 77,
        88, 99, 112, 126, 141, 156, 173, 191, 210, 230,
        251, 274, 297, 322, 348, 375, 404, 433, 464, 497,
        531, 566, 602, 640, 680, 721, 763, 807, 853, 899,
        948, 998, 1050, 1103, 1158, 1215, 1273, 1333, 1394, 1458,
        1523, 1590, 1658, 1729, 1801, 1875, 1951, 2029, 2109, 2190,
        2274, 2359, 2446, 2536, 2627, 2720, 2816, 2913, 3012, 3114,
        3217, 3323, 3431, 3541, 3653, 3767, 3883, 4001, 4122, 4245,
        4370, 4498, 4627, 4759, 4893, 5030, 5169, 5310, 5453, 5599,
        5747, 5898, 6051, 6206, 6364, 6525, 6688, 6853, 7021, 7191,
        7364, 7539, 7717, 7897, 8080, 8266, 8454, 8645, 8838, 9034,
        9233, 9434, 9638, 9845, 10055, 10267, 10482, 10699, 10920, 11143,
        11369, 11598, 11829, 12064, 12301, 12541, 12784, 13030, 13279, 13530,
        13785, 14042, 14303, 14566, 14832, 15102, 15374, 15649, 15928, 16209,
        16493, 16781, 17071, 17365, 17661, 17961, 18264, 18570, 18879, 19191,
        19507, 19825, 20147, 20472, 20800, 21131, 21466, 21804, 22145, 22489,
        22837, 23188, 23542, 23899, 24260, 24625, 24992, 25363, 25737, 26115,
        26496, 26880, 27268, 27659, 28054, 28452, 28854, 29259, 29667, 30079,
        30495, 30914, 31337, 31763, 32192, 32626, 33062, 33503, 33947, 34394,
        34846, 35300, 35759, 36221, 36687, 37156, 37629, 38106, 38586, 39071,
        39558, 40050, 40545, 41045, 41547, 42054, 42565, 43079, 43597, 44119,
        44644, 45174, 45707, 46245, 46786, 47331, 47880, 48432, 48989, 49550,
        50114, 50683, 51255, 51832, 52412, 52996, 53585, 54177, 54773, 55374,
        55978, 56587, 57199, 57816, 58436, 59061, 59690, 60323, 60960, 61601,
        62246, 62896, 63549, 64207, 64869, 65535};

    *r16 = _gamma_2_8[rgb.r];
    *g16 = _gamma_2_8[rgb.g];
    *b16 = _gamma_2_8[rgb.b];
}


}
# 7 "../../src/fl/five_bit_hd_gamma.h" 2







# 1 "../../src/lib8tion/brightness_bitshifter.h" 1



       
# 14 "../../src/lib8tion/brightness_bitshifter.h"
inline uint8_t brightness_bitshifter8(uint8_t *brightness_src, uint8_t *brightness_dst, uint8_t max_shifts) {
    uint8_t src = *brightness_src;
    if (*brightness_dst == 0 || src == 0) {
        return 0;
    }





    uint8_t curr = *brightness_dst;
    uint8_t shifts = 0;
    for (uint8_t i = 0; i < max_shifts && src > 1; i++) {
        if (curr & 0b10000000) {

            break;
        }
        curr <<= 1;
        src >>= 1;
        shifts++;
    }

    *brightness_dst = curr;
    *brightness_src = src;
    return shifts;
}



inline uint8_t brightness_bitshifter16(uint8_t *brightness_src, uint16_t *brightness_dst, uint8_t max_shifts, uint8_t steps=2) {
    uint8_t src = *brightness_src;
    if (*brightness_dst == 0 || src == 0) {
        return 0;
    }
    uint16_t overflow_mask = 0b1000000000000000;
    for (uint8_t i = 1; i < steps; i++) {
        overflow_mask >>= 1;
        overflow_mask |= 0b1000000000000000;
    }
    const uint8_t underflow_mask = 0x1;



    uint16_t curr = *brightness_dst;
    uint8_t shifts = 0;
    for (uint8_t i = 0; i < max_shifts; i++) {
        if (src & underflow_mask) {
            break;
        }
        if (curr & overflow_mask) {

            break;
        }
        curr <<= steps;
        src >>= 1;
        shifts++;
    }

    *brightness_dst = curr;
    *brightness_src = src;
    return shifts;
}
# 15 "../../src/fl/five_bit_hd_gamma.h" 2

namespace fl {

enum FiveBitGammaCorrectionMode {
    kFiveBitGammaCorrectionMode_Null = 0,
    kFiveBitGammaCorrectionMode_BitShift = 1
};
# 43 "../../src/fl/five_bit_hd_gamma.h"
void internal_builtin_five_bit_hd_gamma_bitshift(CRGB colors, CRGB colors_scale,
                                                 uint8_t global_brightness,
                                                 CRGB *out_colors,
                                                 uint8_t *out_power_5bit);


uint8_t five_bit_bitshift(uint16_t r16, uint16_t g16, uint16_t b16,
                          uint8_t brightness, CRGB *out,
                          uint8_t *out_power_5bit);
# 61 "../../src/fl/five_bit_hd_gamma.h"
inline void five_bit_hd_gamma_bitshift(CRGB colors, CRGB colors_scale,
                                       uint8_t global_brightness,
                                       CRGB *out_colors,
                                       uint8_t *out_power_5bit) {
    internal_builtin_five_bit_hd_gamma_bitshift(
        colors, colors_scale, global_brightness, out_colors, out_power_5bit);
}
# 89 "../../src/fl/five_bit_hd_gamma.h"
inline void five_bit_hd_gamma_function(CRGB color, uint16_t *r16, uint16_t *g16,
                                       uint16_t *b16) {

    gamma16(color, r16, g16, b16);
}


inline void internal_builtin_five_bit_hd_gamma_bitshift(
    CRGB colors, CRGB colors_scale, uint8_t global_brightness, CRGB *out_colors,
    uint8_t *out_power_5bit) {

    if (global_brightness == 0) {
        *out_colors = CRGB(0, 0, 0);
        *out_power_5bit = 0;
        return;
    }


    uint16_t r16, g16, b16;
    five_bit_hd_gamma_function(colors, &r16, &g16, &b16);



    if (colors_scale.r != 0xff) {
        r16 = scale16by8(r16, colors_scale.r);
    }
    if (colors_scale.g != 0xff) {
        g16 = scale16by8(g16, colors_scale.g);
    }
    if (colors_scale.b != 0xff) {
        b16 = scale16by8(b16, colors_scale.b);
    }

    five_bit_bitshift(r16, g16, b16, global_brightness, out_colors,
                      out_power_5bit);
}

inline uint8_t five_bit_bitshift(uint16_t r16, uint16_t g16, uint16_t b16,
                                 uint8_t brightness, CRGB *out,
                                 uint8_t *out_power_5bit) {

    auto max3 = [](uint16_t a, uint16_t b, uint16_t c) {
        return fl_max(fl_max(a, b), c);
    };

    if (brightness == 0) {
        *out = CRGB(0, 0, 0);
        *out_power_5bit = 0;
        return 0;
    }
    if (r16 == 0 && g16 == 0 && b16 == 0) {
        *out = CRGB(0, 0, 0);
        *out_power_5bit = (brightness <= 31) ? brightness : 31;
        return brightness;
    }







    static const uint8_t kStartBrightness = 0b00010000;
    uint8_t v5 = kStartBrightness;

    brightness_bitshifter8(&v5, &brightness, 4);



    uint16_t max_component = max3(r16, g16, b16);

    uint8_t shifts = brightness_bitshifter16(&v5, &max_component, 4, 2);
    if (shifts) {
        r16 = r16 << shifts;
        g16 = g16 << shifts;
        b16 = b16 << shifts;
    }


    if (brightness != 0xff) {
        r16 = scale16by8(r16, brightness);
        g16 = scale16by8(g16, brightness);
        b16 = scale16by8(b16, brightness);
    }


    if (v5 > 1) {



        v5 = v5 | (v5 - 1);
    }

    *out = CRGB(map16_to_8(r16), map16_to_8(g16), map16_to_8(b16));
    *out_power_5bit = v5;
    return brightness;
}

}
# 18 "../../src/pixel_controller.h" 2




# 1 "../../src/dither_mode.h" 1



       
# 15 "../../src/dither_mode.h"

typedef uint8_t EDitherMode;

# 23 "../../src/pixel_controller.h" 2
# 1 "../../src/pixel_iterator.h" 1



       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 7 "../../src/pixel_iterator.h" 2
# 15 "../../src/pixel_iterator.h"







template<typename PixelControllerT>
struct PixelControllerVtable {
  static void loadAndScaleRGBW(void* pixel_controller, Rgbw rgbw, uint8_t* b0_out, uint8_t* b1_out, uint8_t* b2_out, uint8_t* b3_out) {
    PixelControllerT* pc = static_cast<PixelControllerT*>(pixel_controller);
    pc->loadAndScaleRGBW(rgbw, b0_out, b1_out, b2_out, b3_out);
  }

  static void loadAndScaleRGB(void* pixel_controller, uint8_t* r_out, uint8_t* g_out, uint8_t* b_out) {
    PixelControllerT* pc = static_cast<PixelControllerT*>(pixel_controller);
    pc->loadAndScaleRGB(r_out, g_out, b_out);
  }
# 43 "../../src/pixel_iterator.h"
  static void loadAndScale_WS2816_HD(void* pixel_controller, uint16_t *s0_out, uint16_t* s1_out, uint16_t* s2_out) {
    PixelControllerT* pc = static_cast<PixelControllerT*>(pixel_controller);
    pc->loadAndScale_WS2816_HD(s0_out, s1_out, s2_out);
  }

  static void stepDithering(void* pixel_controller) {
    PixelControllerT* pc = static_cast<PixelControllerT*>(pixel_controller);
    pc->stepDithering();
  }

  static void advanceData(void* pixel_controller) {
    PixelControllerT* pc = static_cast<PixelControllerT*>(pixel_controller);
    pc->advanceData();
  }

  static int size(void* pixel_controller) {
    PixelControllerT* pc = static_cast<PixelControllerT*>(pixel_controller);
    return pc->size();
  }
  static bool has(void* pixel_controller, int n) {
    PixelControllerT* pc = static_cast<PixelControllerT*>(pixel_controller);
    return pc->has(n);
  }



  static void getHdScale(void* pixel_controller, uint8_t* c0, uint8_t* c1, uint8_t* c2, uint8_t* brightness) {
    PixelControllerT* pc = static_cast<PixelControllerT*>(pixel_controller);
    pc->getHdScale(c0, c1, c2, brightness);
  }

};

typedef void (*loadAndScaleRGBWFunction)(void* pixel_controller, Rgbw rgbw, uint8_t* b0_out, uint8_t* b1_out, uint8_t* b2_out, uint8_t* b3_out);
typedef void (*loadAndScaleRGBFunction)(void* pixel_controller, uint8_t* r_out, uint8_t* g_out, uint8_t* b_out);



typedef void (*loadAndScale_WS2816_HDFunction)(void* pixel_controller, uint16_t* b0_out, uint16_t* b1_out, uint16_t* b2_out);
typedef void (*stepDitheringFunction)(void* pixel_controller);
typedef void (*advanceDataFunction)(void* pixel_controller);
typedef int (*sizeFunction)(void* pixel_controller);
typedef bool (*hasFunction)(void* pixel_controller, int n);
typedef uint8_t (*globalBrightness)(void* pixel_controller);
typedef void (*getHdScaleFunction)(void* pixel_controller, uint8_t* c0, uint8_t* c1, uint8_t* c2, uint8_t* brightness);
# 96 "../../src/pixel_iterator.h"
class PixelIterator {
  public:
    template<typename PixelControllerT>
    PixelIterator(PixelControllerT* pc, Rgbw rgbw)
         : mPixelController(pc), mRgbw(rgbw) {
# 125 "../../src/pixel_iterator.h"
      typedef PixelControllerVtable<PixelControllerT> Vtable;
      mLoadAndScaleRGBW = &Vtable::loadAndScaleRGBW;
      mLoadAndScaleRGB = &Vtable::loadAndScaleRGB;



      mLoadAndScale_WS2816_HD = &Vtable::loadAndScale_WS2816_HD;
      mStepDithering = &Vtable::stepDithering;
      mAdvanceData = &Vtable::advanceData;
      mSize = &Vtable::size;
      mHas = &Vtable::has;

      mGetHdScale = &Vtable::getHdScale;

    }

    bool has(int n) { return mHas(mPixelController, n); }
    void loadAndScaleRGBW(uint8_t *b0_out, uint8_t *b1_out, uint8_t *b2_out, uint8_t *w_out) {
      mLoadAndScaleRGBW(mPixelController, mRgbw, b0_out, b1_out, b2_out, w_out);
    }
    void loadAndScaleRGB(uint8_t *r_out, uint8_t *g_out, uint8_t *b_out) {
      mLoadAndScaleRGB(mPixelController, r_out, g_out, b_out);
    }





    void loadAndScale_WS2816_HD(uint16_t *s0_out, uint16_t *s1_out, uint16_t *s2_out) {
      mLoadAndScale_WS2816_HD(mPixelController, s0_out, s1_out, s2_out);
    }
    void stepDithering() { mStepDithering(mPixelController); }
    void advanceData() { mAdvanceData(mPixelController); }
    int size() { return mSize(mPixelController); }

    void set_rgbw(Rgbw rgbw) { mRgbw = rgbw; }
    Rgbw get_rgbw() const { return mRgbw; }


    void getHdScale(uint8_t* c0, uint8_t* c1, uint8_t* c2, uint8_t* brightness) {
      mGetHdScale(mPixelController, c0, c1, c2, brightness);
    }


  private:

    void* mPixelController = nullptr;
    Rgbw mRgbw;
    loadAndScaleRGBWFunction mLoadAndScaleRGBW = nullptr;
    loadAndScaleRGBFunction mLoadAndScaleRGB = nullptr;



    loadAndScale_WS2816_HDFunction mLoadAndScale_WS2816_HD = nullptr;
    stepDitheringFunction mStepDithering = nullptr;
    advanceDataFunction mAdvanceData = nullptr;
    sizeFunction mSize = nullptr;
    hasFunction mHas = nullptr;

    getHdScaleFunction mGetHdScale = nullptr;

};



# 24 "../../src/pixel_controller.h" 2






# 60 "../../src/pixel_controller.h"
struct ColorAdjustment {
    CRGB premixed;

    CRGB color;
    uint8_t brightness;

};
# 75 "../../src/pixel_controller.h"
template<EOrder RGB_ORDER, int LANES=1, uint32_t MASK=0xFFFFFFFF>
struct PixelController {
    const uint8_t *mData;
    int mLen;
    int mLenRemaining;
    uint8_t d[3];
    uint8_t e[3];
    int8_t mAdvance;
    int mOffsets[LANES];
    ColorAdjustment mColorAdjustment;

    enum {
        kLanes = LANES,
        kMask = MASK
    };

    __attribute__((always_inline)) inline PixelIterator as_iterator(const Rgbw& rgbw) {
        return PixelIterator(this, rgbw);
    }

    void disableColorAdjustment() {

        mColorAdjustment.premixed = CRGB(mColorAdjustment.brightness, mColorAdjustment.brightness, mColorAdjustment.brightness);
        mColorAdjustment.color = CRGB(0xff, 0xff, 0xff);

    }



    PixelController(const PixelController & other) {
        copy(other);
    }

    template<EOrder RGB_ORDER_OTHER>
    PixelController(const PixelController<RGB_ORDER_OTHER, LANES, MASK> & other) {
        copy(other);
    }

    template<typename PixelControllerT>
    void copy(const PixelControllerT& other) {
        static_assert(int(kLanes) == int(PixelControllerT::kLanes), "PixelController lanes must match or mOffsets will be wrong");
        static_assert(int(kMask) == int(PixelControllerT::kMask), "PixelController mask must match or else one or the other controls different lanes");
        d[0] = other.d[0];
        d[1] = other.d[1];
        d[2] = other.d[2];
        e[0] = other.e[0];
        e[1] = other.e[1];
        e[2] = other.e[2];
        mData = other.mData;
        mColorAdjustment = other.mColorAdjustment;
        mAdvance = other.mAdvance;
        mLenRemaining = mLen = other.mLen;
        for(int i = 0; i < LANES; ++i) { mOffsets[i] = other.mOffsets[i]; }
    }



    void initOffsets(int len) {
        int nOffset = 0;
        for(int i = 0; i < LANES; ++i) {
            mOffsets[i] = nOffset;
            if((1<<i) & MASK) { nOffset += (len * mAdvance); }
        }
    }
# 147 "../../src/pixel_controller.h"
    PixelController(
            const uint8_t *d, int len, ColorAdjustment color_adjustment,
            EDitherMode dither, bool advance, uint8_t skip)
                : mData(d), mLen(len), mLenRemaining(len), mColorAdjustment(color_adjustment) {
        enable_dithering(dither);
        mData += skip;
        mAdvance = (advance) ? 3+skip : 0;
        initOffsets(len);
    }






    PixelController(
            const CRGB *d, int len, ColorAdjustment color_adjustment,
            EDitherMode dither)
                : mData((const uint8_t*)d), mLen(len), mLenRemaining(len), mColorAdjustment(color_adjustment) {
        enable_dithering(dither);
        mAdvance = 3;
        initOffsets(len);
    }






    PixelController(
            const CRGB &d, int len, ColorAdjustment color_adjustment, EDitherMode dither)
                : mData((const uint8_t*)&d), mLen(len), mLenRemaining(len), mColorAdjustment(color_adjustment) {
        enable_dithering(dither);
        mAdvance = 0;
        initOffsets(len);
    }


    uint8_t global_brightness() const {
        return mColorAdjustment.brightness;
    }
# 231 "../../src/pixel_controller.h"
    void init_binary_dithering() {


        static uint8_t R = 0;
        ++R;



        uint8_t ditherBits = (((400 / 50)>1) + ((400 / 50)>2) + ((400 / 50)>4) + ((400 / 50)>8) + ((400 / 50)>16) + ((400 / 50)>32) + ((400 / 50)>64) + ((400 / 50)>128) );
        R &= (0x01 << ditherBits) - 1;




        uint8_t Q = 0;


        {
            if(R & 0x01) { Q |= 0x80; }
            if(R & 0x02) { Q |= 0x40; }
            if(R & 0x04) { Q |= 0x20; }
            if(R & 0x08) { Q |= 0x10; }
            if(R & 0x10) { Q |= 0x08; }
            if(R & 0x20) { Q |= 0x04; }
            if(R & 0x40) { Q |= 0x02; }
            if(R & 0x80) { Q |= 0x01; }
        }





        if( ditherBits < 8) {
            Q += 0x01 << (7 - ditherBits);
        }






        for(int i = 0; i < 3; ++i) {
                uint8_t s = mColorAdjustment.premixed.raw[i];
                e[i] = s ? (256/s) + 1 : 0;
                d[i] = scale8(Q, e[i]);

                if(d[i]) (--d[i]);

                if(e[i]) --e[i];
        }

    }




    __attribute__((always_inline)) inline bool has(int n) {
        return mLenRemaining >= n;
    }






    void enable_dithering(EDitherMode dither) {
        switch(dither) {
            case 0x01: init_binary_dithering(); break;
            default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
        }
    }



    __attribute__((always_inline)) inline int size() { return mLen; }



    __attribute__((always_inline)) inline int lanes() { return LANES; }



    __attribute__((always_inline)) inline int advanceBy() { return mAdvance; }


    __attribute__((always_inline)) inline void advanceData() { mData += mAdvance; --mLenRemaining;}



    __attribute__((always_inline)) inline void stepDithering() {


            d[0] = e[0] - d[0];
            d[1] = e[1] - d[1];
            d[2] = e[2] - d[2];
    }


    __attribute__((always_inline)) inline void preStepFirstByteDithering() {
        d[(((RGB_ORDER)>>(3*(2-(0)))) & 0x3)] = e[(((RGB_ORDER)>>(3*(2-(0)))) & 0x3)] - d[(((RGB_ORDER)>>(3*(2-(0)))) & 0x3)];
    }
# 340 "../../src/pixel_controller.h"
    template<int SLOT> __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc) { return pc.mData[(((RGB_ORDER)>>(3*(2-(SLOT)))) & 0x3)]; }





    template<int SLOT> __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc, int lane) { return pc.mData[pc.mOffsets[lane] + (((RGB_ORDER)>>(3*(2-(SLOT)))) & 0x3)]; }






    template<int SLOT> __attribute__((always_inline)) inline static uint8_t dither(PixelController & pc, uint8_t b) { return b ? qadd8(b, pc.d[(((RGB_ORDER)>>(3*(2-(SLOT)))) & 0x3)]) : 0; }





    template<int SLOT> __attribute__((always_inline)) inline static uint8_t dither(PixelController & , uint8_t b, uint8_t d) { return b ? qadd8(b,d) : 0; }






    template<int SLOT> __attribute__((always_inline)) inline static uint8_t scale(PixelController & pc, uint8_t b) { return scale8(b, pc.mColorAdjustment.premixed.raw[(((RGB_ORDER)>>(3*(2-(SLOT)))) & 0x3)]); }





    template<int SLOT> __attribute__((always_inline)) inline static uint8_t scale(PixelController & , uint8_t b, uint8_t scale) { return scale8(b, scale); }
# 384 "../../src/pixel_controller.h"
    template<int SLOT> __attribute__((always_inline)) inline static uint8_t loadAndScale(PixelController & pc) { return scale<SLOT>(pc, pc.dither<SLOT>(pc, pc.loadByte<SLOT>(pc))); }





    template<int SLOT> __attribute__((always_inline)) inline static uint8_t loadAndScale(PixelController & pc, int lane) { return scale<SLOT>(pc, pc.dither<SLOT>(pc, pc.loadByte<SLOT>(pc, lane))); }







    template<int SLOT> __attribute__((always_inline)) inline static uint8_t loadAndScale(PixelController & pc, int lane, uint8_t d, uint8_t scale) { return scale8(pc.dither<SLOT>(pc, pc.loadByte<SLOT>(pc, lane), d), scale); }






    template<int SLOT> __attribute__((always_inline)) inline static uint8_t loadAndScale(PixelController & pc, int lane, uint8_t scale) { return scale8(pc.loadByte<SLOT>(pc, lane), scale); }




    template<int SLOT> __attribute__((always_inline)) inline static uint8_t advanceAndLoadAndScale(PixelController & pc) { pc.advanceData(); return pc.loadAndScale<SLOT>(pc); }




    template<int SLOT> __attribute__((always_inline)) inline static uint8_t advanceAndLoadAndScale(PixelController & pc, int lane) { pc.advanceData(); return pc.loadAndScale<SLOT>(pc, lane); }





    template<int SLOT> __attribute__((always_inline)) inline static uint8_t advanceAndLoadAndScale(PixelController & pc, int lane, uint8_t scale) { pc.advanceData(); return pc.loadAndScale<SLOT>(pc, lane, scale); }
# 436 "../../src/pixel_controller.h"
    template<int SLOT> __attribute__((always_inline)) inline static uint8_t getd(PixelController & pc) { return pc.d[(((RGB_ORDER)>>(3*(2-(SLOT)))) & 0x3)]; }






    template<int SLOT> __attribute__((always_inline)) inline static uint8_t getscale(PixelController & pc) { return pc.mColorAdjustment.premixed.raw[(((RGB_ORDER)>>(3*(2-(SLOT)))) & 0x3)]; }







    __attribute__((always_inline)) inline uint8_t loadAndScale0(int lane, uint8_t scale) { return loadAndScale<0>(*this, lane, scale); }
    __attribute__((always_inline)) inline uint8_t loadAndScale1(int lane, uint8_t scale) { return loadAndScale<1>(*this, lane, scale); }
    __attribute__((always_inline)) inline uint8_t loadAndScale2(int lane, uint8_t scale) { return loadAndScale<2>(*this, lane, scale); }
    __attribute__((always_inline)) inline uint8_t advanceAndLoadAndScale0(int lane, uint8_t scale) { return advanceAndLoadAndScale<0>(*this, lane, scale); }
    __attribute__((always_inline)) inline uint8_t stepAdvanceAndLoadAndScale0(int lane, uint8_t scale) { stepDithering(); return advanceAndLoadAndScale<0>(*this, lane, scale); }

    __attribute__((always_inline)) inline uint8_t loadAndScale0(int lane) { return loadAndScale<0>(*this, lane); }
    __attribute__((always_inline)) inline uint8_t loadAndScale1(int lane) { return loadAndScale<1>(*this, lane); }
    __attribute__((always_inline)) inline uint8_t loadAndScale2(int lane) { return loadAndScale<2>(*this, lane); }
    __attribute__((always_inline)) inline uint8_t advanceAndLoadAndScale0(int lane) { return advanceAndLoadAndScale<0>(*this, lane); }
    __attribute__((always_inline)) inline uint8_t stepAdvanceAndLoadAndScale0(int lane) { stepDithering(); return advanceAndLoadAndScale<0>(*this, lane); }



    __attribute__((always_inline)) inline uint8_t loadAndScale0() { return loadAndScale<0>(*this); }
    __attribute__((always_inline)) inline uint8_t loadAndScale1() { return loadAndScale<1>(*this); }
    __attribute__((always_inline)) inline uint8_t loadAndScale2() { return loadAndScale<2>(*this); }
    __attribute__((always_inline)) inline uint8_t advanceAndLoadAndScale0() { return advanceAndLoadAndScale<0>(*this); }
    __attribute__((always_inline)) inline uint8_t stepAdvanceAndLoadAndScale0() { stepDithering(); return advanceAndLoadAndScale<0>(*this); }

    __attribute__((always_inline)) inline uint8_t getScale0() { return getscale<0>(*this); }
    __attribute__((always_inline)) inline uint8_t getScale1() { return getscale<1>(*this); }
    __attribute__((always_inline)) inline uint8_t getScale2() { return getscale<2>(*this); }


    template<int SLOT> __attribute__((always_inline)) inline static uint8_t getScaleFullBrightness(PixelController & pc) { return pc.mColorAdjustment.color.raw[(((RGB_ORDER)>>(3*(2-(SLOT)))) & 0x3)]; }


    __attribute__((always_inline)) inline void getHdScale(uint8_t* c0, uint8_t* c1, uint8_t* c2, uint8_t* brightness) {
        *c0 = getScaleFullBrightness<0>(*this);
        *c1 = getScaleFullBrightness<1>(*this);
        *c2 = getScaleFullBrightness<2>(*this);
        *brightness = mColorAdjustment.brightness;
    }



    __attribute__((always_inline)) inline void loadAndScale_APA102_HD(uint8_t *b0_out, uint8_t *b1_out,
                                                     uint8_t *b2_out,
                                                     uint8_t *brightness_out) {
        CRGB rgb = CRGB(mData[0], mData[1], mData[2]);
        uint8_t brightness = 0;
        if (rgb) {

            brightness = mColorAdjustment.brightness;
            CRGB scale = mColorAdjustment.color;




            fl::five_bit_hd_gamma_bitshift(
                rgb,
                scale,
                brightness,
                &rgb,
                &brightness);
        }
        const uint8_t b0_index = ((RGB_ORDER>>6) & 0x3);
        const uint8_t b1_index = ((RGB_ORDER>>3) & 0x3);
        const uint8_t b2_index = ((RGB_ORDER) & 0x3);
        *b0_out = rgb.raw[b0_index];
        *b1_out = rgb.raw[b1_index];
        *b2_out = rgb.raw[b2_index];
        *brightness_out = brightness;
    }

    __attribute__((always_inline)) inline void loadAndScaleRGB(uint8_t *b0_out, uint8_t *b1_out,
                                              uint8_t *b2_out) {
        *b0_out = loadAndScale0();
        *b1_out = loadAndScale1();
        *b2_out = loadAndScale2();
    }



    __attribute__((always_inline)) inline void loadAndScale_WS2816_HD(uint16_t *s0_out, uint16_t *s1_out, uint16_t *s2_out) {



        uint16_t r16 = map8_to_16(mData[0]);
        uint16_t g16 = map8_to_16(mData[1]);
        uint16_t b16 = map8_to_16(mData[2]);
        if (r16 || g16 || b16) {

            uint8_t brightness = mColorAdjustment.brightness;
            CRGB scale = mColorAdjustment.color;




            if (scale[0] != 255) {
                r16 = scale16by8(r16, scale[0]);
            }
            if (scale[1] != 255) {
                g16 = scale16by8(g16, scale[1]);
            }
            if (scale[2] != 255) {
                b16 = scale16by8(b16, scale[2]);
            }
            if (brightness != 255) {
                r16 = scale16by8(r16, brightness);
                g16 = scale16by8(g16, brightness);
                b16 = scale16by8(b16, brightness);
            }
        }
        uint16_t rgb16[3] = {r16, g16, b16};
        const uint8_t s0_index = ((RGB_ORDER>>6) & 0x3);
        const uint8_t s1_index = ((RGB_ORDER>>3) & 0x3);
        const uint8_t s2_index = ((RGB_ORDER) & 0x3);
        *s0_out = rgb16[s0_index];
        *s1_out = rgb16[s1_index];
        *s2_out = rgb16[s2_index];
    }

    __attribute__((always_inline)) inline void loadAndScaleRGBW(Rgbw rgbw, uint8_t *b0_out, uint8_t *b1_out,
                                               uint8_t *b2_out, uint8_t *b3_out) {
# 583 "../../src/pixel_controller.h"
        const uint8_t b0_index = ((RGB_ORDER>>6) & 0x3);
        const uint8_t b1_index = ((RGB_ORDER>>3) & 0x3);
        const uint8_t b2_index = ((RGB_ORDER) & 0x3);

        CRGB rgb(mData[0], mData[1], mData[2]);
        uint8_t w = 0;
        rgb_2_rgbw(rgbw.rgbw_mode,
                   rgbw.white_color_temp,
                   rgb.r, rgb.g, rgb.b,
                   mColorAdjustment.premixed.r, mColorAdjustment.premixed.g, mColorAdjustment.premixed.b,
                   &rgb.r, &rgb.g, &rgb.b, &w);

        rgbw_partial_reorder(
            rgbw.w_placement,
            rgb.raw[b0_index],
            rgb.raw[b1_index],
            rgb.raw[b2_index],
            w,
            b0_out, b1_out, b2_out, b3_out);

    }
};



# 16 "../../src/cpixel_ledcontroller.h" 2
# 1 "../../src/cled_controller.h" 1
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 4 "../../src/cled_controller.h" 2
# 18 "../../src/cled_controller.h"
# 1 "../../src/fl/engine_events.h" 1
       


# 1 "../../src/fl/screenmap.h" 1
       




# 1 "../../src/fl/lut.h" 1
       
# 15 "../../src/fl/lut.h"
namespace fl {





template <typename T> class LUT;

typedef LUT<uint16_t> LUT16;
typedef LUT<vec2<uint16_t>> LUTXY16;
typedef LUT<vec2f> LUTXYFLOAT;
typedef LUT<vec3f> LUTXYZFLOAT;

using LUT16Ptr = fl::Ptr<LUT16>;;
using LUTXY16Ptr = fl::Ptr<LUTXY16>;;
using LUTXYFLOATPtr = fl::Ptr<LUTXYFLOAT>;;
using LUTXYZFLOATPtr = fl::Ptr<LUTXYZFLOAT>;;


template <typename T> class LUT : public fl::Referent {
  public:
    LUT(uint32_t length) : length(length) {
        T *ptr = PSRamAllocator<T>::Alloc(length);
        mDataHandle.reset(ptr);
        data = ptr;
    }

    LUT(uint32_t length, T *data) : length(length) { this->data = data; }
    ~LUT() {
        PSRamAllocator<T>::Free(mDataHandle.release());
        data = mDataHandle.get();
    }

    const T &operator[](uint32_t index) const { return data[index]; }

    const T &operator[](uint16_t index) const { return data[index]; }

    T *getDataMutable() { return data; }

    const T *getData() const { return data; }

    uint32_t size() const { return length; }

    T interp8(uint8_t alpha) {
        if (length == 0)
            return T();
        if (alpha == 0)
            return data[0];
        if (alpha == 255)
            return data[length - 1];


        uint32_t maxIndex = length - 1;
        uint32_t pos = uint32_t(alpha) * maxIndex;
        uint32_t idx0 = pos / 255;
        uint32_t idx1 = idx0 < maxIndex ? idx0 + 1 : maxIndex;
        uint8_t blend = pos % 255;

        const T &a = data[idx0];
        const T &b = data[idx1];

        return a + (b - a) * blend / 255;
    }

    T interp16(uint16_t alpha) {
        if (length == 0)
            return T();
        if (alpha == 0)
            return data[0];
        if (alpha == 65535)
            return data[length - 1];


        uint32_t maxIndex = length - 1;
        uint32_t pos = uint32_t(alpha) * maxIndex;
        uint32_t idx0 = pos / 65535;
        uint32_t idx1 = idx0 < maxIndex ? idx0 + 1 : maxIndex;
        uint16_t blend = pos % 65535;

        const T &a = data[idx0];
        const T &b = data[idx1];

        return a + (b - a) * blend / 65535;
    }

  private:
    fl::scoped_ptr<T> mDataHandle;
    T *data = nullptr;
    uint32_t length;
};

}
# 7 "../../src/fl/screenmap.h" 2


# 1 "../../src/fl/map.h" 1
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 4 "../../src/fl/map.h" 2


# 1 "../../src/fl/assert.h" 1
       

# 1 "../../src/platforms/assert_defs.h" 1
       

# 1 "../../src/fl/strstream.h" 1
       
# 14 "../../src/fl/strstream.h"
namespace fl {

class Tile2x2_u8;

template <typename T> struct StrStreamHelper {
    static void append(string &str, const T &n) { str.append(n); }
};

template <> struct StrStreamHelper<int> {
    static void append(string &str, const int &n) { str.append(int32_t(n)); }
};

template <> struct StrStreamHelper<uint8_t> {
    static void append(string &str, const uint8_t &n) { str.append(uint16_t(n)); }
};

template <> struct StrStreamHelper<char> {
    static void append(string &str, const char &n) { str.append(uint16_t(n)); }
};

template <> struct StrStreamHelper<unsigned int> {
    static void append(string &str, const unsigned int &n) {
        str.append(uint32_t(n));
    }
};

class StrStream {
  public:
    StrStream() = default;
    StrStream(const string &str) : mStr(str) {}

    void setTreatCharAsInt(bool treatCharAsInt) {
        mTreatCharAsInt = treatCharAsInt;
    }

    const string &str() const { return mStr; }
    const char *c_str() const { return mStr.c_str(); }

    StrStream &operator<<(const CRGB &rgb) {
        mStr.append(rgb);
        return *this;
    }
    StrStream &operator<<(const StrStream &strStream) {
        mStr.append(strStream.str());
        return *this;
    }

    StrStream &operator<<(const Tile2x2_u8 &subpixel);

    StrStream &operator=(const uint16_t &n) {
        mStr.clear();
        (*this) << n;
        return *this;
    }

    StrStream &operator=(const uint8_t &n) {
        mStr.clear();
        (*this) << n;
        return *this;
    }

    StrStream &operator=(char c) {
        mStr.clear();
        (*this) << c;
        return *this;
    }


    StrStream &operator<<(const string &str) {
        mStr.append(str);
        return *this;
    }

    StrStream &operator<<(const char *str) {
        mStr.append(str);
        return *this;
    }

    StrStream &operator<<(const float &f) {

        mStr.append(f);
        return *this;
    }

    StrStream &operator<<(const double &f) {

        mStr.append(f);
        return *this;
    }

    StrStream &operator<<(const char &c) {
        if (mTreatCharAsInt) {
            StrStreamHelper<int>::append(mStr, c);
        } else {
            StrStreamHelper<char>::append(mStr, c);
        }
        return *this;
    }


    StrStream &operator<<(size_t n) {
        mStr.append(uint32_t(n));
        return *this;
    }


    template <typename T> StrStream &operator<<(T n) {
        StrStreamHelper<T>::append(mStr, n);
        return *this;
    }

    StrStream &operator<<(const uint8_t &n) {
        if (mTreatCharAsInt) {
            mStr.append(uint16_t(n));
        } else {
            mStr.append(n);
        }
        return *this;
    }

    StrStream &operator<<(const uint16_t &n) {
        mStr.append(n);
        return *this;
    }

    StrStream &operator<<(const int16_t &n) {
        mStr.append(n);
        return *this;
    }

    StrStream &operator<<(const uint32_t &n) {
        mStr.append(uint32_t(n));
        return *this;
    }

    StrStream &operator<<(const int32_t &n) {
        mStr.append(n);
        return *this;
    }


    StrStream &operator=(const string &str) {
        mStr = str;
        return *this;
    }

    StrStream &operator=(const char *str) {
        mStr.clear();
        mStr.append(str);
        return *this;
    }


    StrStream &operator=(const CRGB &rgb) {
        mStr.clear();
        (*this) << rgb;
        return *this;
    }

    void clear() { mStr.clear(); }

  private:
    string mStr;
    bool mTreatCharAsInt = true;
};

class FakeStrStream {
  public:
    template <typename T> FakeStrStream &operator<<(const T &) { return *this; }

    FakeStrStream &operator<<(const char *) { return *this; }

    template <typename T> FakeStrStream &operator=(const T &) { return *this; }

    FakeStrStream &operator<<(const CRGB &) { return *this; }
    FakeStrStream &operator<<(const string &) { return *this; }
    FakeStrStream &operator<<(char) { return *this; }


    FakeStrStream &operator<<(size_t) { return *this; }


    FakeStrStream &operator<<(uint8_t) { return *this; }
    FakeStrStream &operator<<(uint16_t) { return *this; }
    FakeStrStream &operator<<(int16_t) { return *this; }
    FakeStrStream &operator<<(uint32_t) { return *this; }
    FakeStrStream &operator<<(int32_t) { return *this; }

    FakeStrStream &operator=(const string &) { return *this; }
    FakeStrStream &operator=(const CRGB &) { return *this; }
    FakeStrStream &operator=(uint16_t) { return *this; }
    FakeStrStream &operator=(uint8_t) { return *this; }
    FakeStrStream &operator=(char) { return *this; }
};

}
# 4 "../../src/platforms/assert_defs.h" 2
# 1 "../../src/fl/warn.h" 1
       

# 1 "../../src/fl/dbg.h" 1
       


# 1 "../../src/fl/sketch_macros.h" 1
       
# 5 "../../src/fl/dbg.h" 2



namespace fl {
    void println(const char* str);
}

namespace fl {


inline const char *fastled_file_offset(const char *file) {
    const char *p = file;
    const char *last_slash = nullptr;

    while (*p) {
        if (p[0] == 's' && p[1] == 'r' && p[2] == 'c' && p[3] == '/') {
            return p;
        }
        if (*p == '/') {
            last_slash = p;
        }
        p++;
    }


    if (last_slash) {
        return last_slash + 1;
    }
    return file;
}
}
# 4 "../../src/fl/warn.h" 2
# 5 "../../src/platforms/assert_defs.h" 2

# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4

# 66 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__)) __attribute__ ((__cold__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__)) __attribute__ ((__cold__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     noexcept (true) __attribute__ ((__noreturn__)) __attribute__ ((__cold__));


}
# 7 "../../src/platforms/assert_defs.h" 2
# 4 "../../src/fl/assert.h" 2
# 7 "../../src/fl/map.h" 2
# 1 "../../src/fl/comparators.h" 1
       


# 3 "../../src/fl/comparators.h"
namespace fl {

template <typename T> struct DefaultLess {
    bool operator()(const T &a, const T &b) const { return a < b; }
};

}
# 8 "../../src/fl/map.h" 2


# 1 "../../src/fl/pair.h" 1
       




namespace fl {

template <typename Key, typename Value> struct Pair {
    Key first = Key();
    Value second = Value();
    Pair() = default;
    
# 12 "../../src/fl/pair.h"
#pragma GCC diagnostic push
    
# 13 "../../src/fl/pair.h"
#pragma GCC diagnostic ignored "-W" "null-dereference"
    Pair(const Key &k, const Value &v) : first(k), second(v) {}
    
# 15 "../../src/fl/pair.h"
#pragma GCC diagnostic pop


    Pair(const Pair &other) = default;
    Pair &operator=(const Pair &other) = default;
    Pair(Pair &&other) noexcept : first(fl::move(other.first)), second(fl::move(other.second)) {}
    Pair &operator=(Pair &&other) noexcept {
        if (this != &other) {
            first = fl::move(other.first);
            second = fl::move(other.second);
        }
        return *this;
    }
};


template <typename Key, typename Value> using pair = Pair<Key, Value>;

}
# 11 "../../src/fl/map.h" 2



# 1 "../../src/fl/rbtree.h" 1
       







# 1 "../../src/fl/algorithm.h" 1
       



# 1 "../../src/fl/random.h" 1
       




namespace fl {
# 19 "../../src/fl/random.h"
class fl_random {
private:

    uint16_t seed_;



    uint16_t next_random16() {
        seed_ = (seed_ * ((uint16_t)(2053))) + ((uint16_t)(13849));
        return seed_;
    }



    uint32_t next_random32() {
        uint32_t high = next_random16();
        uint32_t low = next_random16();
        return (high << 16) | low;
    }

public:

    typedef uint32_t result_type;


    fl_random() : seed_(random16_get_seed()) {}



    explicit fl_random(uint16_t seed) : seed_(seed) {}



    result_type operator()() {
        return next_random32();
    }




    result_type operator()(result_type n) {
        if (n == 0) return 0;
        uint32_t r = next_random32();
        uint64_t p = (uint64_t)n * (uint64_t)r;
        return (uint32_t)(p >> 32);
    }





    result_type operator()(result_type min, result_type max) {
        result_type delta = max - min;
        result_type r = (*this)(delta) + min;
        return r;
    }



    void set_seed(uint16_t seed) {
        seed_ = seed;
    }



    uint16_t get_seed() const {
        return seed_;
    }



    void add_entropy(uint16_t entropy) {
        seed_ += entropy;
    }



    static constexpr result_type minimum() {
        return 0;
    }



    static constexpr result_type maximum() {
        return 4294967295U;
    }



    uint8_t random8() {
        uint16_t r = next_random16();

        return (uint8_t)(((uint8_t)(r & 0xFF)) + ((uint8_t)(r >> 8)));
    }




    uint8_t random8(uint8_t n) {
        uint8_t r = random8();
        r = (r * n) >> 8;
        return r;
    }





    uint8_t random8(uint8_t min, uint8_t max) {
        uint8_t delta = max - min;
        uint8_t r = random8(delta) + min;
        return r;
    }



    uint16_t random16() {
        return next_random16();
    }




    uint16_t random16(uint16_t n) {
        return (*this)(n);
    }





    uint16_t random16(uint16_t min, uint16_t max) {
        return (*this)(min, max);
    }
};
# 165 "../../src/fl/random.h"
fl_random& default_random();

}
# 6 "../../src/fl/algorithm.h" 2

namespace fl {

template <typename Iterator>
void reverse(Iterator first, Iterator last) {
    while ((first != last) && (first != --last)) {
        swap(*first++, *last);
    }
}

template <typename Iterator>
Iterator max_element(Iterator first, Iterator last) {
    if (first == last) {
        return last;
    }

    Iterator max_iter = first;
    ++first;

    while (first != last) {
        if (*max_iter < *first) {
            max_iter = first;
        }
        ++first;
    }

    return max_iter;
}

template <typename Iterator, typename Compare>
Iterator max_element(Iterator first, Iterator last, Compare comp) {
    if (first == last) {
        return last;
    }

    Iterator max_iter = first;
    ++first;

    while (first != last) {
        if (comp(*max_iter, *first)) {
            max_iter = first;
        }
        ++first;
    }

    return max_iter;
}

template <typename Iterator>
Iterator min_element(Iterator first, Iterator last) {
    if (first == last) {
        return last;
    }

    Iterator min_iter = first;
    ++first;

    while (first != last) {
        if (*first < *min_iter) {
            min_iter = first;
        }
        ++first;
    }

    return min_iter;
}

template <typename Iterator, typename Compare>
Iterator min_element(Iterator first, Iterator last, Compare comp) {
    if (first == last) {
        return last;
    }

    Iterator min_iter = first;
    ++first;

    while (first != last) {
        if (comp(*first, *min_iter)) {
            min_iter = first;
        }
        ++first;
    }

    return min_iter;
}



template <typename Iterator1, typename Iterator2>
bool equal(Iterator1 first1, Iterator1 last1, Iterator2 first2) {
    while (first1 != last1) {
        if (*first1 != *first2) {
            return false;
        }
        ++first1;
        ++first2;
    }
    return true;
}

template <typename Iterator1, typename Iterator2, typename BinaryPredicate>
bool equal(Iterator1 first1, Iterator1 last1, Iterator2 first2, BinaryPredicate pred) {
    while (first1 != last1) {
        if (!pred(*first1, *first2)) {
            return false;
        }
        ++first1;
        ++first2;
    }
    return true;
}

template <typename Iterator1, typename Iterator2>
bool equal(Iterator1 first1, Iterator1 last1, Iterator2 first2, Iterator2 last2) {
    while (first1 != last1 && first2 != last2) {
        if (*first1 != *first2) {
            return false;
        }
        ++first1;
        ++first2;
    }
    return first1 == last1 && first2 == last2;
}

template <typename Iterator1, typename Iterator2, typename BinaryPredicate>
bool equal(Iterator1 first1, Iterator1 last1, Iterator2 first2, Iterator2 last2, BinaryPredicate pred) {
    while (first1 != last1 && first2 != last2) {
        if (!pred(*first1, *first2)) {
            return false;
        }
        ++first1;
        ++first2;
    }
    return first1 == last1 && first2 == last2;
}

template <typename Container1, typename Container2>
bool equal_container(const Container1& c1, const Container2& c2) {
    size_t size1 = c1.size();
    size_t size2 = c2.size();
    if (size1 != size2) {
        return false;
    }
    return equal(c1.begin(), c1.end(), c2.begin(), c2.end());
}

template <typename Container1, typename Container2, typename BinaryPredicate>
bool equal_container(const Container1& c1, const Container2& c2, BinaryPredicate pred) {
    size_t size1 = c1.size();
    size_t size2 = c2.size();
    if (size1 != size2) {
        return false;
    }
    return equal(c1.begin(), c1.end(), c2.begin(), c2.end(), pred);
}


template <typename Iterator, typename T>
void fill(Iterator first, Iterator last, const T& value) {
    while (first != last) {
        *first = value;
        ++first;
    }
}

template <typename Iterator, typename T>
Iterator find(Iterator first, Iterator last, const T& value) {
    while (first != last) {
        if (*first == value) {
            return first;
        }
        ++first;
    }
    return last;
}

template <typename Iterator, typename UnaryPredicate>
Iterator find_if(Iterator first, Iterator last, UnaryPredicate pred) {
    while (first != last) {
        if (pred(*first)) {
            return first;
        }
        ++first;
    }
    return last;
}

template <typename Iterator, typename UnaryPredicate>
Iterator find_if_not(Iterator first, Iterator last, UnaryPredicate pred) {
    while (first != last) {
        if (!pred(*first)) {
            return first;
        }
        ++first;
    }
    return last;
}

namespace detail {


template <typename Iterator, typename Compare>
void insertion_sort(Iterator first, Iterator last, Compare comp) {
    if (first == last) return;

    for (Iterator i = first + 1; i != last; ++i) {
        auto value = fl::move(*i);
        Iterator j = i;

        while (j != first && comp(value, *(j - 1))) {
            *j = fl::move(*(j - 1));
            --j;
        }

        *j = fl::move(value);
    }
}


template <typename Iterator, typename Compare>
Iterator median_of_three(Iterator first, Iterator middle, Iterator last, Compare comp) {
    if (comp(*middle, *first)) {
        if (comp(*last, *middle)) {
            return middle;
        } else if (comp(*last, *first)) {
            return last;
        } else {
            return first;
        }
    } else {
        if (comp(*last, *first)) {
            return first;
        } else if (comp(*last, *middle)) {
            return last;
        } else {
            return middle;
        }
    }
}


template <typename Iterator, typename Compare>
Iterator partition(Iterator first, Iterator last, Compare comp) {
    Iterator middle = first + (last - first) / 2;
    Iterator pivot_iter = median_of_three(first, middle, last - 1, comp);


    swap(*pivot_iter, *(last - 1));
    Iterator pivot = last - 1;

    Iterator i = first;
    for (Iterator j = first; j != pivot; ++j) {
        if (comp(*j, *pivot)) {
            swap(*i, *j);
            ++i;
        }
    }

    swap(*i, *pivot);
    return i;
}


template <typename Iterator, typename Compare>
void sift_down(Iterator first, Iterator start, Iterator end, Compare comp) {
    Iterator root = start;

    while (root - first <= (end - first - 2) / 2) {
        Iterator child = first + 2 * (root - first) + 1;
        Iterator swap_iter = root;

        if (comp(*swap_iter, *child)) {
            swap_iter = child;
        }

        if (child + 1 <= end && comp(*swap_iter, *(child + 1))) {
            swap_iter = child + 1;
        }

        if (swap_iter == root) {
            return;
        } else {
            swap(*root, *swap_iter);
            root = swap_iter;
        }
    }
}

template <typename Iterator, typename Compare>
void heapify(Iterator first, Iterator last, Compare comp) {
    Iterator start = first + (last - first - 2) / 2;

    while (true) {
        sift_down(first, start, last - 1, comp);
        if (start == first) {
            break;
        }
        --start;
    }
}

template <typename Iterator, typename Compare>
void heap_sort(Iterator first, Iterator last, Compare comp) {
    heapify(first, last, comp);

    Iterator end = last - 1;
    while (end > first) {
        swap(*end, *first);
        sift_down(first, first, end - 1, comp);
        --end;
    }
}


template <typename Iterator, typename Compare>
void quicksort_impl(Iterator first, Iterator last, Compare comp) {
    if (last - first <= 16) {
        insertion_sort(first, last, comp);
        return;
    }

    Iterator pivot = partition(first, last, comp);
    quicksort_impl(first, pivot, comp);
    quicksort_impl(pivot + 1, last, comp);
}


template <typename Iterator>
void rotate_impl(Iterator first, Iterator middle, Iterator last) {
    if (first == middle || middle == last) {
        return;
    }

    Iterator next = middle;
    while (first != next) {
        swap(*first++, *next++);
        if (next == last) {
            next = middle;
        } else if (first == middle) {
            middle = next;
        }
    }
}


template <typename Iterator, typename T, typename Compare>
Iterator lower_bound_impl(Iterator first, Iterator last, const T& value, Compare comp) {
    auto count = last - first;
    while (count > 0) {
        auto step = count / 2;
        Iterator it = first + step;
        if (comp(*it, value)) {
            first = ++it;
            count -= step + 1;
        } else {
            count = step;
        }
    }
    return first;
}


template <typename Iterator, typename Compare>
void merge_inplace(Iterator first, Iterator middle, Iterator last, Compare comp) {

    if (first == middle || middle == last) {
        return;
    }


    auto left_size = middle - first;
    auto right_size = last - middle;
    if (left_size + right_size <= 32) {

        Iterator left = first;
        Iterator right = middle;

        while (left < middle && right < last) {
            if (!comp(*right, *left)) {

                ++left;
            } else {

                auto value = fl::move(*right);
                Iterator shift_end = right;
                Iterator shift_start = left;


                while (shift_end > shift_start) {
                    *shift_end = fl::move(*(shift_end - 1));
                    --shift_end;
                }

                *left = fl::move(value);
                ++left;
                ++middle;
                ++right;
            }
        }
        return;
    }


    if (left_size == 0 || right_size == 0) {
        return;
    }

    if (left_size == 1) {

        Iterator pos = lower_bound_impl(middle, last, *first, comp);
        rotate_impl(first, middle, pos);
        return;
    }

    if (right_size == 1) {

        Iterator pos = lower_bound_impl(first, middle, *(last - 1), comp);
        rotate_impl(pos, middle, last);
        return;
    }


    Iterator left_mid = first + left_size / 2;
    Iterator right_mid = lower_bound_impl(middle, last, *left_mid, comp);


    rotate_impl(left_mid, middle, right_mid);


    Iterator new_middle = left_mid + (right_mid - middle);


    merge_inplace(first, left_mid, new_middle, comp);
    merge_inplace(new_middle, right_mid, last, comp);
}


template <typename Iterator, typename Compare>
void mergesort_impl(Iterator first, Iterator last, Compare comp) {
    auto size = last - first;
    if (size <= 16) {
        insertion_sort(first, last, comp);
        return;
    }

    Iterator middle = first + size / 2;
    mergesort_impl(first, middle, comp);
    mergesort_impl(middle, last, comp);
    merge_inplace(first, middle, last, comp);
}

}


template <typename Iterator, typename Compare>
void sort(Iterator first, Iterator last, Compare comp) {
    if (first == last || first + 1 == last) {
        return;
    }

    detail::quicksort_impl(first, last, comp);
}


template <typename Iterator>
void sort(Iterator first, Iterator last) {

    typedef typename fl::remove_reference<decltype(*first)>::type value_type;
    sort(first, last, [](const value_type& a, const value_type& b) { return a < b; });
}


template <typename Iterator, typename Compare>
void stable_sort(Iterator first, Iterator last, Compare comp) {
    if (first == last || first + 1 == last) {
        return;
    }

    detail::mergesort_impl(first, last, comp);
}


template <typename Iterator>
void stable_sort(Iterator first, Iterator last) {

    typedef typename fl::remove_reference<decltype(*first)>::type value_type;
    stable_sort(first, last, [](const value_type& a, const value_type& b) { return a < b; });
}


template <typename Iterator, typename RandomGenerator>
void shuffle(Iterator first, Iterator last, RandomGenerator& g) {
    if (first == last) {
        return;
    }

    auto n = last - first;
    for (auto i = n - 1; i > 0; --i) {

        auto j = g() % (i + 1);


        swap(*(first + i), *(first + j));
    }
}


template <typename Iterator>
void shuffle(Iterator first, Iterator last, fl_random& rng) {
    if (first == last) {
        return;
    }

    auto n = last - first;
    for (auto i = n - 1; i > 0; --i) {

        auto j = rng(static_cast<uint32_t>(i + 1));


        swap(*(first + i), *(first + j));
    }
}


template <typename Iterator>
void shuffle(Iterator first, Iterator last) {
    shuffle(first, last, default_random());
}

}
# 10 "../../src/fl/rbtree.h" 2
# 1 "../../src/fl/slab_allocator.h" 1
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 4 "../../src/fl/slab_allocator.h" 2
# 1 "/usr/include/c++/14/stdlib.h" 1 3
# 5 "../../src/fl/slab_allocator.h" 2






namespace fl {




template <typename T, size_t SLAB_SIZE = 64>
class SlabAllocator {
private:
    struct FreeBlock {
        FreeBlock* next;
    };

    struct Slab {
        Slab* next;
        uint8_t* memory;
        size_t allocated_count;

        Slab() : next(nullptr), memory(nullptr), allocated_count(0) {}

        ~Slab() {
            if (memory) {
                free(memory);
            }
        }
    };

    static constexpr size_t BLOCK_SIZE = sizeof(T) > sizeof(FreeBlock*) ? sizeof(T) : sizeof(FreeBlock*);
    static constexpr size_t BLOCKS_PER_SLAB = SLAB_SIZE;
    static constexpr size_t SLAB_MEMORY_SIZE = BLOCK_SIZE * BLOCKS_PER_SLAB;

    static Slab* slabs_;
    static FreeBlock* free_list_;
    static size_t total_allocated_;
    static size_t total_deallocated_;

    static Slab* createSlab() {
        Slab* slab = static_cast<Slab*>(malloc(sizeof(Slab)));
        if (!slab) {
            return nullptr;
        }


        new(slab) Slab();

        slab->memory = static_cast<uint8_t*>(malloc(SLAB_MEMORY_SIZE));
        if (!slab->memory) {
            slab->~Slab();
            free(slab);
            return nullptr;
        }


        for (size_t i = 0; i < BLOCKS_PER_SLAB; ++i) {
            FreeBlock* block = reinterpret_cast<FreeBlock*>(slab->memory + i * BLOCK_SIZE);
            block->next = free_list_;
            free_list_ = block;
        }


        slab->next = slabs_;
        slabs_ = slab;

        return slab;
    }

    static void* allocateFromSlab() {
        if (!free_list_) {
            if (!createSlab()) {
                return nullptr;
            }
        }

        FreeBlock* block = free_list_;
        free_list_ = free_list_->next;
        ++total_allocated_;


        for (Slab* slab = slabs_; slab; slab = slab->next) {
            uint8_t* slab_start = slab->memory;
            uint8_t* slab_end = slab_start + SLAB_MEMORY_SIZE;
            uint8_t* block_ptr = reinterpret_cast<uint8_t*>(block);

            if (block_ptr >= slab_start && block_ptr < slab_end) {
                ++slab->allocated_count;
                break;
            }
        }

        return block;
    }

    static void deallocateToSlab(void* ptr) {
        if (!ptr) {
            return;
        }


        for (Slab* slab = slabs_; slab; slab = slab->next) {
            uint8_t* slab_start = slab->memory;
            uint8_t* slab_end = slab_start + SLAB_MEMORY_SIZE;
            uint8_t* block_ptr = reinterpret_cast<uint8_t*>(ptr);

            if (block_ptr >= slab_start && block_ptr < slab_end) {
                if (!(slab->allocated_count > 0)) fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fl/slab_allocator.h")) << "(" << 114 << "): " << "Slab allocated count underflow") .c_str());
                --slab->allocated_count;
                break;
            }
        }

        FreeBlock* block = reinterpret_cast<FreeBlock*>(ptr);
        block->next = free_list_;
        free_list_ = block;
        ++total_deallocated_;
    }

public:
    static T* allocate(size_t n = 1) {
        if (n != 1) {


            void* ptr = malloc(sizeof(T) * n);
            if (ptr) {
                memset(ptr, 0, sizeof(T) * n);
            }
            return static_cast<T*>(ptr);
        }

        void* ptr = allocateFromSlab();
        if (ptr) {
            memset(ptr, 0, sizeof(T));
        }
        return static_cast<T*>(ptr);
    }

    static void deallocate(T* ptr, size_t n = 1) {
        if (!ptr) {
            return;
        }

        if (n != 1) {

            free(ptr);
            return;
        }

        deallocateToSlab(ptr);
    }


    static size_t getTotalAllocated() { return total_allocated_; }
    static size_t getTotalDeallocated() { return total_deallocated_; }
    static size_t getActiveAllocations() { return total_allocated_ - total_deallocated_; }


    static size_t getSlabCount() {
        size_t count = 0;
        for (Slab* slab = slabs_; slab; slab = slab->next) {
            ++count;
        }
        return count;
    }


    static void cleanup() {
        while (slabs_) {
            Slab* next = slabs_->next;
            slabs_->~Slab();
            free(slabs_);
            slabs_ = next;
        }
        free_list_ = nullptr;
        total_allocated_ = 0;
        total_deallocated_ = 0;
    }
};


template <typename T, size_t SLAB_SIZE>
typename SlabAllocator<T, SLAB_SIZE>::Slab* SlabAllocator<T, SLAB_SIZE>::slabs_ = nullptr;

template <typename T, size_t SLAB_SIZE>
typename SlabAllocator<T, SLAB_SIZE>::FreeBlock* SlabAllocator<T, SLAB_SIZE>::free_list_ = nullptr;

template <typename T, size_t SLAB_SIZE>
size_t SlabAllocator<T, SLAB_SIZE>::total_allocated_ = 0;

template <typename T, size_t SLAB_SIZE>
size_t SlabAllocator<T, SLAB_SIZE>::total_deallocated_ = 0;


template <typename T, size_t SLAB_SIZE = 64>
class allocator_slab {
public:

    using value_type = T;
    using pointer = T*;
    using const_pointer = const T*;
    using reference = T&;
    using const_reference = const T&;
    using size_type = size_t;
    using difference_type = ptrdiff_t;


    template <typename U>
    struct rebind {
        using other = typename fl::conditional<
            fl::is_same<U, void>::value,
            allocator_slab<char, SLAB_SIZE>,
            allocator_slab<U, SLAB_SIZE>
        >::type;
    };


    allocator_slab() noexcept {}


    template <typename U>
    allocator_slab(const allocator_slab<U, SLAB_SIZE>&) noexcept {}


    ~allocator_slab() noexcept {}


    T* allocate(size_t n) {
        return SlabAllocator<T, SLAB_SIZE>::allocate(n);
    }


    void deallocate(T* p, size_t n) {
        SlabAllocator<T, SLAB_SIZE>::deallocate(p, n);
    }


    template <typename U, typename... Args>
    void construct(U* p, Args&&... args) {
        if (p == nullptr) return;
        new(static_cast<void*>(p)) U(fl::forward<Args>(args)...);
    }


    template <typename U>
    void destroy(U* p) {
        if (p == nullptr) return;
        p->~U();
    }


    bool operator==(const allocator_slab& other) const noexcept {
        (void)(other);
        return true;
    }

    bool operator!=(const allocator_slab& other) const noexcept {
        return !(*this == other);
    }
};

}
# 11 "../../src/fl/rbtree.h" 2

namespace fl {



template <typename Key, typename Value, typename Compare = DefaultLess<Key>, typename Allocator = allocator_slab<char>>
class MapRedBlackTree {
public:
    using key_type = Key;
    using mapped_type = Value;
    using value_type = fl::Pair<Key, Value>;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using key_compare = Compare;
    using reference = value_type&;
    using const_reference = const value_type&;
    using pointer = value_type*;
    using const_pointer = const value_type*;
    using allocator_type = Allocator;


    enum Color { RED, BLACK };

private:
    struct Node {
        value_type data;
        Color color;
        Node* left;
        Node* right;
        Node* parent;

        Node(const value_type& val, Color c = RED, Node* p = nullptr)
            : data(val), color(c), left(nullptr), right(nullptr), parent(p) {}

        Node(const Key& k, const Value& v, Color c = RED, Node* p = nullptr)
            : data(k, v), color(c), left(nullptr), right(nullptr), parent(p) {}
    };

    using NodeAllocator = typename Allocator::template rebind<Node>::other;

    Node* root_;
    size_type size_;
    Compare comp_;
    NodeAllocator alloc_;


    void rotateLeft(Node* x) {
        Node* y = x->right;
        x->right = y->left;
        if (y->left != nullptr) {
            y->left->parent = x;
        }
        y->parent = x->parent;
        if (x->parent == nullptr) {
            root_ = y;
        } else if (x == x->parent->left) {
            x->parent->left = y;
        } else {
            x->parent->right = y;
        }
        y->left = x;
        x->parent = y;
    }

    void rotateRight(Node* x) {
        Node* y = x->left;
        x->left = y->right;
        if (y->right != nullptr) {
            y->right->parent = x;
        }
        y->parent = x->parent;
        if (x->parent == nullptr) {
            root_ = y;
        } else if (x == x->parent->right) {
            x->parent->right = y;
        } else {
            x->parent->left = y;
        }
        y->right = x;
        x->parent = y;
    }

    void insertFixup(Node* z) {
        while (z->parent != nullptr && z->parent->color == RED) {
            if (z->parent == z->parent->parent->left) {
                Node* y = z->parent->parent->right;
                if (y != nullptr && y->color == RED) {
                    z->parent->color = BLACK;
                    y->color = BLACK;
                    z->parent->parent->color = RED;
                    z = z->parent->parent;
                } else {
                    if (z == z->parent->right) {
                        z = z->parent;
                        rotateLeft(z);
                    }
                    z->parent->color = BLACK;
                    z->parent->parent->color = RED;
                    rotateRight(z->parent->parent);
                }
            } else {
                Node* y = z->parent->parent->left;
                if (y != nullptr && y->color == RED) {
                    z->parent->color = BLACK;
                    y->color = BLACK;
                    z->parent->parent->color = RED;
                    z = z->parent->parent;
                } else {
                    if (z == z->parent->left) {
                        z = z->parent;
                        rotateRight(z);
                    }
                    z->parent->color = BLACK;
                    z->parent->parent->color = RED;
                    rotateLeft(z->parent->parent);
                }
            }
        }
        root_->color = BLACK;
    }

    void transplant(Node* u, Node* v) {
        if (u->parent == nullptr) {
            root_ = v;
        } else if (u == u->parent->left) {
            u->parent->left = v;
        } else {
            u->parent->right = v;
        }
        if (v != nullptr) {
            v->parent = u->parent;
        }
    }

    Node* minimum(Node* x) const {
        while (x->left != nullptr) {
            x = x->left;
        }
        return x;
    }

    Node* maximum(Node* x) const {
        while (x->right != nullptr) {
            x = x->right;
        }
        return x;
    }

    void deleteFixup(Node* x) {
        while (x != root_ && (x == nullptr || x->color == BLACK)) {
            if (x == (x && x->parent ? x->parent->left : nullptr)) {
                Node* w = x && x->parent ? x->parent->right : nullptr;
                if (w && w->color == RED) {
                    w->color = BLACK;
                    if (x && x->parent) {
                        x->parent->color = RED;
                        rotateLeft(x->parent);
                        w = x->parent->right;
                    }
                }
                if (w && (w->left == nullptr || w->left->color == BLACK) &&
                    (w->right == nullptr || w->right->color == BLACK)) {
                    w->color = RED;
                    x = x ? x->parent : nullptr;
                } else {
                    if (w && (w->right == nullptr || w->right->color == BLACK)) {
                        if (w->left) w->left->color = BLACK;
                        w->color = RED;
                        rotateRight(w);
                        w = x && x->parent ? x->parent->right : nullptr;
                    }
                    if (w) {
                        w->color = x && x->parent ? x->parent->color : BLACK;
                        if (w->right) w->right->color = BLACK;
                    }
                    if (x && x->parent) {
                        x->parent->color = BLACK;
                        rotateLeft(x->parent);
                    }
                    x = root_;
                }
            } else {
                Node* w = x && x->parent ? x->parent->left : nullptr;
                if (w && w->color == RED) {
                    w->color = BLACK;
                    if (x && x->parent) {
                        x->parent->color = RED;
                        rotateRight(x->parent);
                        w = x->parent->left;
                    }
                }
                if (w && (w->right == nullptr || w->right->color == BLACK) &&
                    (w->left == nullptr || w->left->color == BLACK)) {
                    w->color = RED;
                    x = x ? x->parent : nullptr;
                } else {
                    if (w && (w->left == nullptr || w->left->color == BLACK)) {
                        if (w->right) w->right->color = BLACK;
                        w->color = RED;
                        rotateLeft(w);
                        w = x && x->parent ? x->parent->left : nullptr;
                    }
                    if (w) {
                        w->color = x && x->parent ? x->parent->color : BLACK;
                        if (w->left) w->left->color = BLACK;
                    }
                    if (x && x->parent) {
                        x->parent->color = BLACK;
                        rotateRight(x->parent);
                    }
                    x = root_;
                }
            }
        }
        if (x) x->color = BLACK;
    }

    Node* findNode(const Key& key) const {
        Node* current = root_;
        while (current != nullptr) {
            if (comp_(key, current->data.first)) {
                current = current->left;
            } else if (comp_(current->data.first, key)) {
                current = current->right;
            } else {
                return current;
            }
        }
        return nullptr;
    }

    void destroyTree(Node* node) {
        if (node != nullptr) {
            destroyTree(node->left);
            destroyTree(node->right);
            alloc_.destroy(node);
            alloc_.deallocate(node, 1);
        }
    }

    Node* copyTree(Node* node, Node* parent = nullptr) {
        if (node == nullptr) return nullptr;

        Node* newNode = alloc_.allocate(1);
        if (newNode == nullptr) {


            return nullptr;
        }

        alloc_.construct(newNode, node->data, node->color, parent);
        newNode->left = copyTree(node->left, newNode);
        newNode->right = copyTree(node->right, newNode);
        return newNode;
    }

public:

    class iterator {
        friend class MapRedBlackTree;
        friend class const_iterator;
    private:
        Node* node_;
        const MapRedBlackTree* tree_;

        Node* successor(Node* x) const {
            if (x == nullptr) return nullptr;
            if (x->right != nullptr) {
                return tree_->minimum(x->right);
            }
            Node* y = x->parent;
            while (y != nullptr && x == y->right) {
                x = y;
                y = y->parent;
            }
            return y;
        }

        Node* predecessor(Node* x) const {
            if (x == nullptr) return nullptr;
            if (x->left != nullptr) {
                return tree_->maximum(x->left);
            }
            Node* y = x->parent;
            while (y != nullptr && x == y->left) {
                x = y;
                y = y->parent;
            }
            return y;
        }

    public:
        iterator() : node_(nullptr), tree_(nullptr) {}
        iterator(Node* n, const MapRedBlackTree* t) : node_(n), tree_(t) {}

        value_type& operator*() const {
            if (!(node_ != nullptr)) fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fl/rbtree.h")) << "(" << 307 << "): " << "MapRedBlackTree::iterator: dereferencing end iterator") .c_str());
            return node_->data;
        }
        value_type* operator->() const {
            if (!(node_ != nullptr)) fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fl/rbtree.h")) << "(" << 311 << "): " << "MapRedBlackTree::iterator: dereferencing end iterator") .c_str());
            return &(node_->data);
        }

        iterator& operator++() {
            if (node_) {
                node_ = successor(node_);
            }
            return *this;
        }

        iterator operator++(int) {
            iterator temp = *this;
            ++(*this);
            return temp;
        }

        iterator& operator--() {
            if (node_) {
                node_ = predecessor(node_);
            } else if (tree_ && tree_->root_) {

                node_ = tree_->maximum(tree_->root_);
            }
            return *this;
        }

        iterator operator--(int) {
            iterator temp = *this;
            --(*this);
            return temp;
        }

        bool operator==(const iterator& other) const {
            return node_ == other.node_;
        }

        bool operator!=(const iterator& other) const {
            return node_ != other.node_;
        }
    };

    class const_iterator {
        friend class MapRedBlackTree;
        friend class iterator;
    private:
        const Node* node_;
        const MapRedBlackTree* tree_;

        const Node* successor(const Node* x) const {
            if (x == nullptr) return nullptr;
            if (x->right != nullptr) {
                return tree_->minimum(x->right);
            }
            const Node* y = x->parent;
            while (y != nullptr && x == y->right) {
                x = y;
                y = y->parent;
            }
            return y;
        }

        const Node* predecessor(const Node* x) const {
            if (x == nullptr) return nullptr;
            if (x->left != nullptr) {
                return tree_->maximum(x->left);
            }
            const Node* y = x->parent;
            while (y != nullptr && x == y->left) {
                x = y;
                y = y->parent;
            }
            return y;
        }

    public:
        const_iterator() : node_(nullptr), tree_(nullptr) {}
        const_iterator(const Node* n, const MapRedBlackTree* t) : node_(n), tree_(t) {}
        const_iterator(const iterator& it) : node_(it.node_), tree_(it.tree_) {}

        const value_type& operator*() const {
            if (!(node_ != nullptr)) fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fl/rbtree.h")) << "(" << 392 << "): " << "MapRedBlackTree::iterator: dereferencing end iterator") .c_str());
            return node_->data;
        }
        const value_type* operator->() const {
            if (!(node_ != nullptr)) fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fl/rbtree.h")) << "(" << 396 << "): " << "MapRedBlackTree::iterator: dereferencing end iterator") .c_str());
            return &(node_->data);
        }

        const_iterator& operator++() {
            if (node_) {
                node_ = successor(node_);
            }
            return *this;
        }

        const_iterator operator++(int) {
            const_iterator temp = *this;
            ++(*this);
            return temp;
        }

        const_iterator& operator--() {
            if (node_) {
                node_ = predecessor(node_);
            } else if (tree_ && tree_->root_) {

                node_ = tree_->maximum(tree_->root_);
            }
            return *this;
        }

        const_iterator operator--(int) {
            const_iterator temp = *this;
            --(*this);
            return temp;
        }

        bool operator==(const const_iterator& other) const {
            return node_ == other.node_;
        }

        bool operator!=(const const_iterator& other) const {
            return node_ != other.node_;
        }
    };


    MapRedBlackTree(const Compare& comp = Compare(), const Allocator& alloc = Allocator())
        : root_(nullptr), size_(0), comp_(comp), alloc_(alloc) {}

    MapRedBlackTree(const MapRedBlackTree& other)
        : root_(nullptr), size_(other.size_), comp_(other.comp_), alloc_(other.alloc_) {
        if (other.root_) {
            root_ = copyTree(other.root_);
        }
    }

    MapRedBlackTree& operator=(const MapRedBlackTree& other) {
        if (this != &other) {
            clear();
            size_ = other.size_;
            comp_ = other.comp_;
            alloc_ = other.alloc_;
            if (other.root_) {
                root_ = copyTree(other.root_);
            }
        }
        return *this;
    }

    ~MapRedBlackTree() {
        clear();
    }


    iterator begin() {
        if (root_ == nullptr) return end();
        return iterator(minimum(root_), this);
    }

    const_iterator begin() const {
        if (root_ == nullptr) return end();
        return const_iterator(minimum(root_), this);
    }

    const_iterator cbegin() const {
        return begin();
    }

    iterator end() {
        return iterator(nullptr, this);
    }

    const_iterator end() const {
        return const_iterator(nullptr, this);
    }

    const_iterator cend() const {
        return end();
    }


    bool empty() const { return size_ == 0; }
    size_type size() const { return size_; }
    size_type max_size() const { return size_type(-1); }


    Value& operator[](const Key& key) {
        Node* node = findNode(key);
        if (node) {
            return node->data.second;
        }


        Node* newNode = alloc_.allocate(1);
        if (newNode == nullptr) {


            static Value default_value;
            return default_value;
        }
        alloc_.construct(newNode, key, Value());

        if (root_ == nullptr) {
            root_ = newNode;
            root_->color = BLACK;
        } else {
            Node* parent = nullptr;
            Node* current = root_;

            while (current != nullptr) {
                parent = current;
                if (comp_(key, current->data.first)) {
                    current = current->left;
                } else {
                    current = current->right;
                }
            }

            newNode->parent = parent;
            if (comp_(key, parent->data.first)) {
                parent->left = newNode;
            } else {
                parent->right = newNode;
            }

            insertFixup(newNode);
        }

        ++size_;
        return newNode->data.second;
    }

    Value& at(const Key& key) {
        Node* node = findNode(key);
        if (!(node != nullptr)) fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fl/rbtree.h")) << "(" << 547 << "): " << "MapRedBlackTree::at: key not found") .c_str());
        return node->data.second;
    }

    const Value& at(const Key& key) const {
        Node* node = findNode(key);
        if (!(node != nullptr)) fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fl/rbtree.h")) << "(" << 553 << "): " << "MapRedBlackTree::at: key not found") .c_str());
        return node->data.second;
    }


    void clear() {
        destroyTree(root_);
        root_ = nullptr;
        size_ = 0;
    }

    fl::Pair<iterator, bool> insert(const value_type& value) {
        Node* existing = findNode(value.first);
        if (existing) {
            return fl::Pair<iterator, bool>(iterator(existing, this), false);
        }

        Node* newNode = alloc_.allocate(1);
        if (newNode == nullptr) {

            return fl::Pair<iterator, bool>(end(), false);
        }
        alloc_.construct(newNode, value);

        if (root_ == nullptr) {
            root_ = newNode;
            root_->color = BLACK;
        } else {
            Node* parent = nullptr;
            Node* current = root_;

            while (current != nullptr) {
                parent = current;
                if (comp_(value.first, current->data.first)) {
                    current = current->left;
                } else {
                    current = current->right;
                }
            }

            newNode->parent = parent;
            if (comp_(value.first, parent->data.first)) {
                parent->left = newNode;
            } else {
                parent->right = newNode;
            }

            insertFixup(newNode);
        }

        ++size_;
        return fl::Pair<iterator, bool>(iterator(newNode, this), true);
    }

    template<class... Args>
    fl::Pair<iterator, bool> emplace(Args&&... args) {
        value_type value(fl::forward<Args>(args)...);
        return insert(value);
    }

    iterator erase(const_iterator pos) {
        if (pos == end()) return end();

        Node* nodeToDelete = const_cast<Node*>(pos.node_);
        Node* successor = nullptr;

        if (pos != end()) {
            const_iterator next = pos;
            ++next;
            successor = const_cast<Node*>(next.node_);
        }

        erase(nodeToDelete->data.first);
        return iterator(successor, this);
    }

    size_type erase(const Key& key) {
        Node* nodeToDelete = findNode(key);
        if (nodeToDelete == nullptr) {
            return 0;
        }

        Node* y = nodeToDelete;
        Node* x;
        Color yOriginalColor = y->color;

        if (nodeToDelete->left == nullptr) {
            x = nodeToDelete->right;
            transplant(nodeToDelete, nodeToDelete->right);
        } else if (nodeToDelete->right == nullptr) {
            x = nodeToDelete->left;
            transplant(nodeToDelete, nodeToDelete->left);
        } else {
            y = minimum(nodeToDelete->right);
            yOriginalColor = y->color;
            x = y->right;

            if (y->parent == nodeToDelete) {
                if (x) x->parent = y;
            } else {
                transplant(y, y->right);
                y->right = nodeToDelete->right;
                y->right->parent = y;
            }

            transplant(nodeToDelete, y);
            y->left = nodeToDelete->left;
            y->left->parent = y;
            y->color = nodeToDelete->color;
        }

        alloc_.destroy(nodeToDelete);
        alloc_.deallocate(nodeToDelete, 1);
        --size_;

        if (yOriginalColor == BLACK) {
            deleteFixup(x);
        }

        return 1;
    }

    void swap(MapRedBlackTree& other) {
        fl::swap(root_, other.root_);
        fl::swap(size_, other.size_);
        fl::swap(comp_, other.comp_);
    }


    size_type count(const Key& key) const {
        return findNode(key) != nullptr ? 1 : 0;
    }

    iterator find(const Key& key) {
        Node* node = findNode(key);
        return node ? iterator(node, this) : end();
    }

    const_iterator find(const Key& key) const {
        Node* node = findNode(key);
        return node ? const_iterator(node, this) : end();
    }

    bool contains(const Key& key) const {
        return findNode(key) != nullptr;
    }

    fl::Pair<iterator, iterator> equal_range(const Key& key) {
        iterator it = find(key);
        if (it == end()) {
            return fl::Pair<iterator, iterator>(it, it);
        }
        iterator next = it;
        ++next;
        return fl::Pair<iterator, iterator>(it, next);
    }

    fl::Pair<const_iterator, const_iterator> equal_range(const Key& key) const {
        const_iterator it = find(key);
        if (it == end()) {
            return fl::Pair<const_iterator, const_iterator>(it, it);
        }
        const_iterator next = it;
        ++next;
        return fl::Pair<const_iterator, const_iterator>(it, next);
    }

    iterator lower_bound(const Key& key) {
        Node* current = root_;
        Node* result = nullptr;

        while (current != nullptr) {
            if (!comp_(current->data.first, key)) {
                result = current;
                current = current->left;
            } else {
                current = current->right;
            }
        }

        return result ? iterator(result, this) : end();
    }

    const_iterator lower_bound(const Key& key) const {
        Node* current = root_;
        Node* result = nullptr;

        while (current != nullptr) {
            if (!comp_(current->data.first, key)) {
                result = current;
                current = current->left;
            } else {
                current = current->right;
            }
        }

        return result ? const_iterator(result, this) : end();
    }

    iterator upper_bound(const Key& key) {
        Node* current = root_;
        Node* result = nullptr;

        while (current != nullptr) {
            if (comp_(key, current->data.first)) {
                result = current;
                current = current->left;
            } else {
                current = current->right;
            }
        }

        return result ? iterator(result, this) : end();
    }

    const_iterator upper_bound(const Key& key) const {
        Node* current = root_;
        Node* result = nullptr;

        while (current != nullptr) {
            if (comp_(key, current->data.first)) {
                result = current;
                current = current->left;
            } else {
                current = current->right;
            }
        }

        return result ? const_iterator(result, this) : end();
    }


    key_compare key_comp() const {
        return comp_;
    }


    bool operator==(const MapRedBlackTree& other) const {
        if (size() != other.size()) {
            return false;
        }

        const_iterator it1 = begin();
        const_iterator it2 = other.begin();

        while (it1 != end() && it2 != other.end()) {
            if (it1->first != it2->first || it1->second != it2->second) {
                return false;
            }
            ++it1;
            ++it2;
        }

        return it1 == end() && it2 == other.end();
    }

    bool operator!=(const MapRedBlackTree& other) const {
        return !(*this == other);
    }
};

}
# 15 "../../src/fl/map.h" 2


namespace fl {






template <typename Key, typename Value, size_t N> class FixedMap {
  public:
    using PairKV = fl::Pair<Key, Value>;

    typedef FixedVector<PairKV, N> VectorType;
    typedef typename VectorType::iterator iterator;
    typedef typename VectorType::const_iterator const_iterator;


    constexpr FixedMap() = default;

    iterator begin() { return data.begin(); }
    iterator end() { return data.end(); }
    const_iterator begin() const { return data.begin(); }
    const_iterator end() const { return data.end(); }

    iterator find(const Key &key) {
        for (auto it = begin(); it != end(); ++it) {
            if (it->first == key) {
                return it;
            }
        }
        return end();
    }

    const_iterator find(const Key &key) const {
        for (auto it = begin(); it != end(); ++it) {
            if (it->first == key) {
                return it;
            }
        }
        return end();
    }

    template <typename Less> iterator lowest(Less less_than = Less()) {
        iterator lowest = end();
        for (iterator it = begin(); it != end(); ++it) {
            if (lowest == end() || less_than(it->first, lowest->first)) {
                lowest = it;
            }
        }
        return lowest;
    }

    template <typename Less>
    const_iterator lowest(Less less_than = Less()) const {
        const_iterator lowest = end();
        for (const_iterator it = begin(); it != end(); ++it) {
            if (lowest == end() || less_than(it->first, lowest->first)) {
                lowest = it;
            }
        }
        return lowest;
    }

    template <typename Less> iterator highest(Less less_than = Less()) {
        iterator highest = end();
        for (iterator it = begin(); it != end(); ++it) {
            if (highest == end() || less_than(highest->first, it->first)) {
                highest = it;
            }
        }
        return highest;
    }

    template <typename Less>
    const_iterator highest(Less less_than = Less()) const {
        const_iterator highest = end();
        for (const_iterator it = begin(); it != end(); ++it) {
            if (highest == end() || less_than(highest->first, it->first)) {
                highest = it;
            }
        }
        return highest;
    }



    bool get(const Key &key, Value *value) const {
        const_iterator it = find(key);
        if (it != end()) {
            *value = it->second;
            return true;
        }
        return false;
    }

    Value get(const Key &key, bool *has = nullptr) const {
        const_iterator it = find(key);
        if (it != end()) {
            if (has) {
                *has = true;
            }
            return it->second;
        }
        if (has) {
            *has = false;
        }
        return Value();
    }

    Pair<bool, iterator> insert(const Key &key, const Value &value,
                                InsertResult *result = nullptr) {
        iterator it = find(key);
        if (it != end()) {
            if (result) {
                *result = InsertResult::kExists;
            }

            return {false, it};
        }
        if (data.size() < N) {
            data.push_back(PairKV(key, value));
            if (result) {
                *result = InsertResult::kInserted;
            }

            return {true, data.end() - 1};
        }
        if (result) {
            *result = InsertResult::kMaxSize;
        }

        return {false, end()};
    }

    bool update(const Key &key, const Value &value,
                bool insert_if_missing = true) {
        iterator it = find(key);
        if (it != end()) {
            it->second = value;
            return true;
        } else if (insert_if_missing) {
            return insert(key, value).first;
        }
        return false;
    }

    Value &operator[](const Key &key) {
        iterator it = find(key);
        if (it != end()) {
            return it->second;
        }
        data.push_back(PairKV(key, Value()));
        return data.back().second;
    }

    const Value &operator[](const Key &key) const {
        const_iterator it = find(key);
        if (it != end()) {
            return it->second;
        }
        static Value default_value;
        return default_value;
    }

    bool next(const Key &key, Key *next_key,
              bool allow_rollover = false) const {
        const_iterator it = find(key);
        if (it != end()) {
            ++it;
            if (it != end()) {
                *next_key = it->first;
                return true;
            } else if (allow_rollover && !empty()) {
                *next_key = begin()->first;
                return true;
            }
        }
        return false;
    }

    bool prev(const Key &key, Key *prev_key,
              bool allow_rollover = false) const {
        const_iterator it = find(key);
        if (it != end()) {
            if (it != begin()) {
                --it;
                *prev_key = it->first;
                return true;
            } else if (allow_rollover && !empty()) {
                *prev_key = data[data.size() - 1].first;
                return true;
            }
        }
        return false;
    }


    constexpr size_t size() const { return data.size(); }

    constexpr bool empty() const { return data.empty(); }


    constexpr size_t capacity() const { return N; }


    void clear() { data.clear(); }

    bool has(const Key &it) const { return find(it) != end(); }

    bool contains(const Key &key) const { return has(key); }

  private:
    VectorType data;
};



template <typename Key, typename Value, typename Less = fl::DefaultLess<Key>>
class SortedHeapMap {
  public:

    using key_type = Key;
    using mapped_type = Value;
    using value_type = fl::Pair<Key, Value>;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using key_compare = Less;
    using reference = value_type&;
    using const_reference = const value_type&;
    using pointer = value_type*;
    using const_pointer = const value_type*;

  private:
    struct PairLess {
        Less less;
        bool operator()(const value_type &a, const value_type &b) const {
            return less(a.first, b.first);
        }
    };

    SortedHeapVector<value_type, PairLess> data;


    class value_compare {
        friend class SortedHeapMap;
        Less comp_;
        value_compare(Less c) : comp_(c) {}
    public:
        bool operator()(const value_type& x, const value_type& y) const {
            return comp_(x.first, y.first);
        }
    };

  public:
    typedef typename SortedHeapVector<value_type, PairLess>::iterator iterator;
    typedef typename SortedHeapVector<value_type, PairLess>::const_iterator const_iterator;


    SortedHeapMap(Less less = Less()) : data(PairLess{less}) {}
    SortedHeapMap(const SortedHeapMap& other) = default;
    SortedHeapMap& operator=(const SortedHeapMap& other) = default;


    iterator begin() { return data.begin(); }
    iterator end() { return data.end(); }
    const_iterator begin() const { return data.begin(); }
    const_iterator end() const { return data.end(); }
    const_iterator cbegin() const { return data.begin(); }
    const_iterator cend() const { return data.end(); }


    size_t size() const { return data.size(); }
    bool empty() const { return data.empty(); }
    bool full() const { return data.full(); }
    size_t capacity() const { return data.capacity(); }
    size_t max_size() const { return data.capacity(); }


    void setMaxSize(size_t n) { data.setMaxSize(n); }
    void reserve(size_t n) { data.reserve(n); }


    Value &operator[](const Key &key) {
        iterator it = find(key);
        if (it != end()) {
            return it->second;
        }
        value_type pair(key, Value());
        bool ok = data.insert(pair);
        if (!(ok)) fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fl/map.h")) << "(" << 305 << "): " << "Failed to insert into SortedHeapMap") .c_str());
        return data.find(pair)->second;
    }

    Value &at(const Key &key) {
        iterator it = find(key);
        if (!(it != end())) fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fl/map.h")) << "(" << 311 << "): " << "SortedHeapMap::at: key not found") .c_str());
        return it->second;
    }

    const Value &at(const Key &key) const {
        const_iterator it = find(key);
        if (!(it != end())) fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fl/map.h")) << "(" << 317 << "): " << "SortedHeapMap::at: key not found") .c_str());
        return it->second;
    }


    void clear() { data.clear(); }

    fl::Pair<iterator, bool> insert(const value_type& value) {
        InsertResult result;
        bool success = data.insert(value, &result);
        iterator it = success ? data.find(value) : data.end();
        return fl::Pair<iterator, bool>(it, success);
    }

    bool insert(const Key &key, const Value &value, InsertResult *result = nullptr) {
        return data.insert(value_type(key, value), result);
    }

    template<class... Args>
    fl::Pair<iterator, bool> emplace(Args&&... args) {
        value_type pair(fl::forward<Args>(args)...);
        InsertResult result;
        bool success = data.insert(pair, &result);
        iterator it = success ? data.find(pair) : data.end();
        return fl::Pair<iterator, bool>(it, success);
    }

    iterator erase(const_iterator pos) {
        Key key = pos->first;
        data.erase(*pos);
        return upper_bound(key);
    }

    size_type erase(const Key& key) {
        return data.erase(value_type(key, Value())) ? 1 : 0;
    }

    bool erase(iterator it) {
        return data.erase(it);
    }

    void swap(SortedHeapMap &other) {
        data.swap(other.data);
    }


    size_type count(const Key& key) const {
        return contains(key) ? 1 : 0;
    }

    iterator find(const Key &key) {
        return data.find(value_type(key, Value()));
    }

    const_iterator find(const Key &key) const {
        return data.find(value_type(key, Value()));
    }

    bool contains(const Key &key) const {
        return has(key);
    }

    bool has(const Key &key) const {
        return data.has(value_type(key, Value()));
    }

    fl::Pair<iterator, iterator> equal_range(const Key& key) {
        iterator lower = lower_bound(key);
        iterator upper = upper_bound(key);
        return fl::Pair<iterator, iterator>(lower, upper);
    }

    fl::Pair<const_iterator, const_iterator> equal_range(const Key& key) const {
        const_iterator lower = lower_bound(key);
        const_iterator upper = upper_bound(key);
        return fl::Pair<const_iterator, const_iterator>(lower, upper);
    }

    iterator lower_bound(const Key &key) {
        return data.lower_bound(value_type(key, Value()));
    }

    const_iterator lower_bound(const Key &key) const {
        return data.lower_bound(value_type(key, Value()));
    }

    iterator upper_bound(const Key &key) {
        iterator it = lower_bound(key);
        if (it != end() && it->first == key) {
            ++it;
        }
        return it;
    }

    const_iterator upper_bound(const Key &key) const {
        const_iterator it = lower_bound(key);
        if (it != end() && it->first == key) {
            ++it;
        }
        return it;
    }


    key_compare key_comp() const {
        return key_compare();
    }

    value_compare value_comp() const {
        return value_compare(key_comp());
    }


    value_type &front() { return data.front(); }
    const value_type &front() const { return data.front(); }
    value_type &back() { return data.back(); }
    const value_type &back() const { return data.back(); }

    void update(const Key &key, const Value &value) {
        if (!insert(key, value)) {
            iterator it = find(key);
            it->second = value;
        }
    }


    bool get(const Key &key, Value *value) const {
        const_iterator it = find(key);
        if (it != end()) {
            *value = it->second;
            return true;
        }
        return false;
    }


    bool operator==(const SortedHeapMap &other) const {
        if (size() != other.size()) {
            return false;
        }
        for (const_iterator it = begin(), other_it = other.begin(); it != end();
             ++it, ++other_it) {
            if (it->first != other_it->first ||
                it->second != other_it->second) {
                return false;
            }
        }
        return true;
    }

    bool operator!=(const SortedHeapMap &other) const {
        return !(*this == other);
    }
};

}





namespace fl {




template <typename Key, typename T, typename Compare = fl::DefaultLess<Key>>
using fl_map = MapRedBlackTree<Key, T, Compare, fl::allocator_slab<char>>;


}
# 10 "../../src/fl/screenmap.h" 2
# 19 "../../src/fl/screenmap.h"
namespace fl {

class string;
class JsonDocument;




class ScreenMap {
  public:
    static ScreenMap Circle(int numLeds, float cm_between_leds = 1.5f,
                            float cm_led_diameter = 0.5f,
                            float completion = 1.0f);

    static ScreenMap DefaultStrip(int numLeds, float cm_between_leds = 1.5f,
                                  float cm_led_diameter = 0.2f,
                                  float completion = .9f) {
        return Circle(numLeds, cm_between_leds, cm_led_diameter, completion);
    }

    ScreenMap() = default;


    ScreenMap(uint32_t length, float mDiameter = -1.0f);

    ScreenMap(const vec2f *lut, uint32_t length, float diameter = -1.0);

    template <uint32_t N>
    ScreenMap(const vec2f (&lut)[N], float diameter = -1.0)
        : ScreenMap(lut, N, diameter) {}

    ScreenMap(const ScreenMap &other);

    const vec2f &operator[](uint32_t x) const;

    void set(uint16_t index, const vec2f &p);

    void addOffset(const vec2f &p);
    void addOffsetX(float x);
    void addOffsetY(float y);

    vec2f &operator[](uint32_t x);



    void setDiameter(float diameter);


    ScreenMap &operator=(const ScreenMap &other);

    vec2f mapToIndex(uint32_t x) const;

    uint32_t getLength() const;

    float getDiameter() const;


    vec2f getBounds() const;

    static bool ParseJson(const char *jsonStrScreenMap,
                          FixedMap<string, ScreenMap, 16> *segmentMaps,
                          string *err = nullptr);

    static bool ParseJson(const char *jsonStrScreenMap,
                          const char *screenMapName, ScreenMap *screenmap,
                          string *err = nullptr);

    static void toJsonStr(const FixedMap<string, ScreenMap, 16> &,
                          string *jsonBuffer);
    static void toJson(const FixedMap<string, ScreenMap, 16> &, JsonDocument *doc);

  private:
    static const vec2f &empty();
    uint32_t length = 0;
    float mDiameter = -1.0f;
    LUTXYFLOATPtr mLookUpTable;
};

}
# 5 "../../src/fl/engine_events.h" 2
# 1 "../../src/fl/singleton.h" 1
       



namespace fl {



template <typename T, int N = 0> class Singleton {
  public:
    static T &instance() {


        static T instance;
        return instance;
    }
    static T *instanceRef() { return &instance(); }
    Singleton(const Singleton &) = delete;
    Singleton &operator=(const Singleton &) = delete;

  private:
    Singleton() = default;
    ~Singleton() = default;
};

}
# 6 "../../src/fl/engine_events.h" 2

# 1 "../../src/fl/xymap.h" 1
       
# 12 "../../src/fl/xymap.h"
# 1 "../../src/fl/xmap.h" 1
       
# 12 "../../src/fl/xmap.h"
namespace fl {

__attribute__((always_inline)) inline uint16_t x_linear(uint16_t x, uint16_t length) {
    (void)length;
    return x;
}

__attribute__((always_inline)) inline uint16_t x_reverse(uint16_t x, uint16_t length) {
    return length - 1 - x;
}


typedef uint16_t (*XFunction)(uint16_t x, uint16_t length);



class XMap {
  public:
    enum Type { kLinear = 0, kReverse, kFunction, kLookUpTable };

    static XMap constructWithUserFunction(uint16_t length, XFunction xFunction,
                                          uint16_t offset = 0);



    static XMap constructWithLookUpTable(uint16_t length,
                                         const uint16_t *lookUpTable,
                                         uint16_t offset = 0);


    XMap(uint16_t length, bool is_reverse = false, uint16_t offset = 0);

    XMap(const XMap &other);


    XMap &operator=(const XMap &other);

    void convertToLookUpTable();

    uint16_t mapToIndex(uint16_t x) const;

    uint16_t operator()(uint16_t x) const { return mapToIndex(x); }

    uint16_t getLength() const;

    Type getType() const;

  private:
    XMap(uint16_t length, Type type);
    uint16_t length = 0;
    Type type = kLinear;
    XFunction xFunction = nullptr;
    const uint16_t *mData = nullptr;
    fl::LUT16Ptr mLookUpTable;
    uint16_t mOffset = 0;
};

}
# 13 "../../src/fl/xymap.h" 2

namespace fl {
class ScreenMap;

__attribute__((always_inline)) inline uint16_t xy_serpentine(uint16_t x, uint16_t y,
                                            uint16_t width, uint16_t height) {
    (void)height;
    if (y & 1)

        return (y + 1) * width - 1 - x;
    else
        return y * width + x;
}

__attribute__((always_inline)) inline uint16_t xy_line_by_line(uint16_t x, uint16_t y,
                                              uint16_t width, uint16_t height) {
    (void)height;
    return y * width + x;
}


typedef uint16_t (*XYFunction)(uint16_t x, uint16_t y, uint16_t width,
                               uint16_t height);







class XYMap {
  public:
    enum XyMapType { kSerpentine = 0, kLineByLine, kFunction, kLookUpTable };

    static XYMap constructWithUserFunction(uint16_t width, uint16_t height,
                                           XYFunction xyFunction,
                                           uint16_t offset = 0);

    static XYMap constructRectangularGrid(uint16_t width, uint16_t height,
                                          uint16_t offset = 0);

    static XYMap constructWithLookUpTable(uint16_t width, uint16_t height,
                                          const uint16_t *lookUpTable,
                                          uint16_t offset = 0);

    static XYMap constructSerpentine(uint16_t width, uint16_t height,
                                     uint16_t offset = 0);

    static XYMap identity(uint16_t width, uint16_t height) {
        return constructRectangularGrid(width, height);
    }



    XYMap(uint16_t width, uint16_t height, bool is_serpentine = true,
          uint16_t offset = 0);

    XYMap(const XYMap &other) = default;
    XYMap &operator=(const XYMap &other) = default;

    fl::ScreenMap toScreenMap() const;

    void mapPixels(const CRGB *input, CRGB *output) const;

    void convertToLookUpTable();

    void setRectangularGrid();

    uint16_t operator()(uint16_t x, uint16_t y) const {
        return mapToIndex(x, y);
    }

    uint16_t mapToIndex(const uint16_t &x, const uint16_t &y) const;

    template <typename IntType,
              typename = fl::enable_if_t<!fl::is_integral<IntType>::value>>
    uint16_t mapToIndex(IntType x, IntType y) const {
        x = fl::clamp<int>(x, 0, width - 1);
        y = fl::clamp<int>(y, 0, height - 1);
        return mapToIndex((uint16_t)x, (uint16_t)y);
    }

    bool has(uint16_t x, uint16_t y) const {
        return (x < width) && (y < height);
    }

    bool has(int x, int y) const {
        return (x >= 0) && (y >= 0) && has((uint16_t)x, (uint16_t)y);
    }

    bool isSerpentine() const { return type == kSerpentine; }
    bool isLineByLine() const { return type == kLineByLine; }
    bool isFunction() const { return type == kFunction; }
    bool isLUT() const { return type == kLookUpTable; }
    bool isRectangularGrid() const { return type == kLineByLine; }
    bool isSerpentineOrLineByLine() const {
        return type == kSerpentine || type == kLineByLine;
    }

    uint16_t getWidth() const;
    uint16_t getHeight() const;
    uint16_t getTotal() const;
    XyMapType getType() const;

  private:
    XYMap(uint16_t width, uint16_t height, XyMapType type);

    XyMapType type;
    uint16_t width;
    uint16_t height;
    XYFunction xyFunction = nullptr;
    fl::LUT16Ptr mLookUpTable;
    uint16_t mOffset = 0;
};

}
# 8 "../../src/fl/engine_events.h" 2
# 1 "../../src/fl/string.h" 1
       
# 9 "../../src/fl/engine_events.h" 2






class CLEDController;



namespace fl {

class EngineEvents {
  public:
    class Listener {
      public:



        Listener();
        virtual ~Listener();
        virtual void onBeginFrame() {}
        virtual void onEndShowLeds() {}
        virtual void onEndFrame() {}
        virtual void onStripAdded(CLEDController *strip, uint32_t num_leds) {
            (void)strip;
            (void)num_leds;
        }

        virtual void onCanvasUiSet(CLEDController *strip,
                                   const ScreenMap &screenmap) {
            (void)strip;
            (void)screenmap;
        }
        virtual void onPlatformPreLoop() {}
        virtual void onPlatformPreLoop2() {}
    };

    static void addListener(Listener *listener, int priority = 0) {

        EngineEvents::getInstance()->_addListener(listener, priority);




    }

    static void removeListener(Listener *listener) {

        EngineEvents::getInstance()->_removeListener(listener);



    }

    static bool hasListener(Listener *listener) {

        return EngineEvents::getInstance()->_hasListener(listener);




    }

    static void onBeginFrame() {

        EngineEvents::getInstance()->_onBeginFrame();

    }

    static void onEndShowLeds() {

        EngineEvents::getInstance()->_onEndShowLeds();

    }

    static void onEndFrame() {

        EngineEvents::getInstance()->_onEndFrame();

    }

    static void onStripAdded(CLEDController *strip, uint32_t num_leds) {

        EngineEvents::getInstance()->_onStripAdded(strip, num_leds);




    }

    static void onCanvasUiSet(CLEDController *strip, const ScreenMap &xymap) {

        EngineEvents::getInstance()->_onCanvasUiSet(strip, xymap);




    }

    static void onPlatformPreLoop() {

        EngineEvents::getInstance()->_onPlatformPreLoop();

    }


    EngineEvents() = default;

  private:

    void _addListener(Listener *listener, int priority);

    void _removeListener(Listener *listener);
    void _onBeginFrame();
    void _onEndShowLeds();
    void _onEndFrame();
    void _onStripAdded(CLEDController *strip, uint32_t num_leds);
    void _onCanvasUiSet(CLEDController *strip, const ScreenMap &xymap);
    void _onPlatformPreLoop();
    bool _hasListener(Listener *listener);

    struct Pair {
        Pair() = default;
        Listener *listener = nullptr;
        int priority = 0;
        Pair(Listener *listener, int priority)
            : listener(listener), priority(priority) {}
    };

    typedef fl::vector_inlined<Pair, 16> ListenerList;
    ListenerList mListeners;


    static EngineEvents *getInstance();

    friend class fl::Singleton<EngineEvents>;

};

}
# 19 "../../src/cled_controller.h" 2

# 1 "../../src/fl/virtual_if_not_avr.h" 1
       
# 21 "../../src/cled_controller.h" 2


# 36 "../../src/cled_controller.h"
class CLEDController {
protected:
    friend class CFastLED;
    CRGB *m_Data;
    CLEDController *m_pNext;
    CRGB m_ColorCorrection;
    CRGB m_ColorTemperature;
    EDitherMode m_DitherMode;
    bool m_enabled = true;
    int m_nLeds;
    static CLEDController *m_pHead;
    static CLEDController *m_pTail;

public:





    virtual void showColor(const CRGB & data, int nLeds, uint8_t brightness) = 0;





    virtual void show(const struct CRGB *data, int nLeds, uint8_t brightness) = 0;


    Rgbw mRgbMode = RgbwInvalid::value();
    CLEDController& setRgbw(const Rgbw& arg = RgbwDefault::value()) {


        mRgbMode = arg;
        return *this;
    }

    void setEnabled(bool enabled) { m_enabled = enabled; }
    bool getEnabled() { return m_enabled; }

    CLEDController();







    virtual ~CLEDController();

    Rgbw getRgbw() const { return mRgbMode; }


    virtual void init() = 0;



    virtual void clearLeds(int nLeds = -1) {
        clearLedDataInternal(nLeds);
        showLeds(0);
    }


    virtual void showLeds(uint8_t brightness) {
        void* data = beginShowLeds(m_nLeds);
        showLedsInternal(brightness);
        endShowLeds(data);
    }

    ColorAdjustment getAdjustmentData(uint8_t brightness);
# 113 "../../src/cled_controller.h"
    void showInternal(const struct CRGB *data, int nLeds, uint8_t brightness) {
        if (m_enabled) {
           show(data, nLeds,brightness);
        }
    }
# 126 "../../src/cled_controller.h"
    void showColorInternal(const struct CRGB &data, int nLeds, uint8_t brightness) {
        if (m_enabled) {
            showColor(data, nLeds, brightness);
        }
    }




    void showLedsInternal(uint8_t brightness) {
        if (m_enabled) {
            show(m_Data, m_nLeds, brightness);
        }
    }






    void showColorInternal(const struct CRGB & data, uint8_t brightness) {
        if (m_enabled) {
            showColor(data, m_nLeds, brightness);
        }
    }



    static CLEDController *head() { return m_pHead; }



    CLEDController *next() { return m_pNext; }




    CLEDController & setLeds(CRGB *data, int nLeds) {
        m_Data = data;
        m_nLeds = nLeds;
        return *this;
    }


    void clearLedDataInternal(int nLeds = -1);



    virtual int size() { return m_nLeds; }



    virtual int lanes() { return 1; }



    CRGB* leds() { return m_Data; }




    CRGB &operator[](int x) { return m_Data[x]; }




    inline CLEDController & setDither(uint8_t ditherMode = 0x01) { m_DitherMode = ditherMode; return *this; }

    CLEDController& setScreenMap(const fl::XYMap& map, float diameter = -1.f) {

        fl::ScreenMap screenmap = map.toScreenMap();
        if (diameter <= 0.0f) {

            if (map.getTotal() <= (64*64)) {
                screenmap.setDiameter(.1);
            }
        }
        fl::EngineEvents::onCanvasUiSet(this, screenmap);
        return *this;
    }

    CLEDController& setScreenMap(const fl::ScreenMap& map) {
        fl::EngineEvents::onCanvasUiSet(this, map);
        return *this;
    }

    CLEDController& setScreenMap(uint16_t width, uint16_t height, float diameter = -1.f) {
        fl::XYMap xymap = fl::XYMap::constructRectangularGrid(width, height);
        return setScreenMap(xymap, diameter);
    }



    inline uint8_t getDither() { return m_DitherMode; }

    virtual void* beginShowLeds(int size) {
        (void)(size);
# 235 "../../src/cled_controller.h"
        uintptr_t d = getDither();
        void* out = reinterpret_cast<void*>(d);
        return out;
    }

    virtual void endShowLeds(void* data) {



        uintptr_t d = reinterpret_cast<uintptr_t>(data);
        setDither(static_cast<uint8_t>(d));
    }




    CLEDController & setCorrection(CRGB correction) { m_ColorCorrection = correction; return *this; }


    CLEDController & setCorrection(LEDColorCorrection correction) { m_ColorCorrection = correction; return *this; }



    CRGB getCorrection() { return m_ColorCorrection; }




    CLEDController & setTemperature(CRGB temperature) { m_ColorTemperature = temperature; return *this; }


    CLEDController & setTemperature(ColorTemperature temperature) { m_ColorTemperature = temperature; return *this; }



    CRGB getTemperature() { return m_ColorTemperature; }




    CRGB getAdjustment(uint8_t scale) {
        return CRGB::computeAdjustment(scale, m_ColorCorrection, m_ColorTemperature);
    }



    virtual uint16_t getMaxRefreshRate() const { return 0; }
};


# 17 "../../src/cpixel_ledcontroller.h" 2









template<EOrder RGB_ORDER, int LANES=1, uint32_t MASK=0xFFFFFFFF> class CPixelLEDController : public CLEDController {
protected:






    virtual void showColor(const CRGB& data, int nLeds, uint8_t brightness) override {



        ColorAdjustment color_adjustment = getAdjustmentData(brightness);
        PixelController<RGB_ORDER, LANES, MASK> pixels(data, nLeds, color_adjustment, getDither());
        showPixels(pixels);
    }





    virtual void show(const struct CRGB *data, int nLeds, uint8_t brightness) override {
        ColorAdjustment color_adjustment = getAdjustmentData(brightness);
        PixelController<RGB_ORDER, LANES, MASK> pixels(data, nLeds < 0 ? -nLeds : nLeds, color_adjustment, getDither());
        if(nLeds < 0) {

            pixels.mAdvance = -pixels.mAdvance;
        }
        showPixels(pixels);
    }

public:
    static const EOrder RGB_ORDER_VALUE = RGB_ORDER;
    static const int LANES_VALUE = LANES;
    static const uint32_t MASK_VALUE = MASK;
    CPixelLEDController() : CLEDController() {}



    virtual void showPixels(PixelController<RGB_ORDER,LANES,MASK> & pixels) = 0;



    int lanes() override { return LANES; }
};



# 10 "../../src/controller.h" 2
# 81 "../../src/FastLED.h" 2
# 1 "../../src/fastpin.h" 1
       
# 10 "../../src/fastpin.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/14/include/stddef.h" 1 3 4
# 11 "../../src/fastpin.h" 2


 
# 13 "../../src/fastpin.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wignored-qualifiers"
# 24 "../../src/fastpin.h"

# 37 "../../src/fastpin.h"
class Selectable {
public:

 virtual ~Selectable() {}

 virtual void select() = 0;
 virtual void release() = 0;
 virtual bool isSelected() = 0;
};




class Pin : public Selectable {
 volatile RwReg *mPort;
 volatile RoReg *mInPort;
 RwReg mPinMask;
 uint8_t mPin;



 void _init() {
  mPinMask = ( 0 );
  mPort = (volatile RwReg*)( 0 );
  mInPort = (volatile RoReg*)( 0 );
 }

public:


 Pin(int pin) : mPin(pin) { _init(); }

 virtual ~Pin() {}


 typedef volatile RwReg * port_ptr_t;
 typedef RwReg port_t;


 inline void setOutput() { pinMode(mPin, 1); }


 inline void setInput() { pinMode(mPin, 0); }

 inline void setInputPullup() { pinMode(mPin, 2); }


 
# 84 "../../src/fastpin.h"
#pragma GCC diagnostic push
 
# 85 "../../src/fastpin.h"
#pragma GCC diagnostic ignored "-W" "null-dereference"
 inline void hi() __attribute__ ((always_inline)) { *mPort |= mPinMask; }

 inline void lo() __attribute__ ((always_inline)) { *mPort &= ~mPinMask; }
 
# 89 "../../src/fastpin.h"
#pragma GCC diagnostic pop


 inline void strobe() __attribute__ ((always_inline)) { toggle(); toggle(); }


 inline void toggle() __attribute__ ((always_inline)) { *mInPort = mPinMask; }



 inline void hi( port_ptr_t port) __attribute__ ((always_inline)) { *port |= mPinMask; }


 inline void lo( port_ptr_t port) __attribute__ ((always_inline)) { *port &= ~mPinMask; }



 inline void set( port_t val) __attribute__ ((always_inline)) { *mPort = val; }




 inline void fastset( port_ptr_t port, port_t val) __attribute__ ((always_inline)) { *port = val; }


 port_t hival() __attribute__ ((always_inline)) { return *mPort | mPinMask; }

 port_t loval() __attribute__ ((always_inline)) { return *mPort & ~mPinMask; }

 port_ptr_t port() __attribute__ ((always_inline)) { return mPort; }

 port_t mask() __attribute__ ((always_inline)) { return mPinMask; }


 virtual void select() override { hi(); }

 virtual void release() override { lo(); }

 virtual bool isSelected() override { return (*mPort & mPinMask) == mPinMask; }
};


class OutputPin : public Pin {
public:

 OutputPin(int pin) : Pin(pin) { setOutput(); }
};


class InputPin : public Pin {
public:

 InputPin(int pin) : Pin(pin) { setInput(); }
};
# 289 "../../src/fastpin.h"
template<uint8_t PIN> class FastPin {






 constexpr static bool validpin() { return false; }
 constexpr static bool LowSpeedOnlyRecommended() {


        return false;
    }

 static_assert(validpin(), "Invalid pin specified");

 static void _init() { }

public:
 typedef volatile RwReg * port_ptr_t;
 typedef RwReg port_t;


 inline static void setOutput() { }

 inline static void setInput() { }


 inline static void hi() __attribute__ ((always_inline)) { }

 inline static void lo() __attribute__ ((always_inline)) { }


 inline static void strobe() __attribute__ ((always_inline)) { }


 inline static void toggle() __attribute__ ((always_inline)) { }


 inline static void hi( port_ptr_t port) __attribute__ ((always_inline)) {
  (void)(port);
 }

 inline static void lo( port_ptr_t port) __attribute__ ((always_inline)) {
  (void)(port);
 }

 inline static void set( port_t val) __attribute__ ((always_inline)) {
  (void)(val);
 }


 inline static void fastset( port_ptr_t port, port_t val) __attribute__ ((always_inline)) {
  (void)(port);
  (void)(val);
 }


 static port_t hival() __attribute__ ((always_inline)) { return 0; }

 static port_t loval() __attribute__ ((always_inline)) { return 0;}

 static port_ptr_t port() __attribute__ ((always_inline)) { return 
# 351 "../../src/fastpin.h" 3 4
                                                                   __null
# 351 "../../src/fastpin.h"
                                                                       ; }

 static port_t mask() __attribute__ ((always_inline)) { return 0; }
};






template<uint8_t PIN> class FastPinBB : public FastPin<PIN> {};

typedef volatile uint32_t & reg32_t;
typedef volatile uint32_t * ptr_reg32_t;



template<uint8_t port> struct __FL_PORT_INFO {

 static bool hasPort() { return 0; }

 static const char *portName() { return "--"; }

 static const void *portAddr() { return 
# 374 "../../src/fastpin.h" 3 4
                                       __null
# 374 "../../src/fastpin.h"
                                           ; }
};
# 406 "../../src/fastpin.h"


 
# 408 "../../src/fastpin.h"
#pragma GCC diagnostic pop
# 82 "../../src/FastLED.h" 2
# 1 "../../src/fastspi_types.h" 1
       
# 13 "../../src/fastspi_types.h"

# 38 "../../src/fastspi_types.h"
class DATA_NOP {
public:


    static __attribute__((always_inline)) inline uint8_t adjust( uint8_t data) { return data; }





    static __attribute__((always_inline)) inline uint8_t adjust( uint8_t data, uint8_t scale) { return scale8(data, scale); }



    static __attribute__((always_inline)) inline void postBlock(int , void* context = 
# 52 "../../src/fastspi_types.h" 3 4
                                                                             __null
# 52 "../../src/fastspi_types.h"
                                                                                 ) {
        (void)(context);
    }
};
# 87 "../../src/fastspi_types.h"

# 83 "../../src/FastLED.h" 2
# 1 "../../src/dmx.h" 1



       
# 84 "../../src/FastLED.h" 2

# 1 "../../src/platforms.h" 1
       
# 54 "../../src/platforms.h"
# 1 "../../src/platforms/stub/fastled_stub.h" 1




# 1 "../../src/platforms/stub/fastspi_stub.h" 1
       





# 1 "../../src/platforms/stub/fastspi_stub_generic.h" 1
       
# 14 "../../src/platforms/stub/fastspi_stub_generic.h"


class StubSPIOutput {
public:
    StubSPIOutput() { }
    void select() { }
    void init() {}
    void waitFully() {}
    void release() {}
    void writeByte(uint8_t byte) { (void)(byte); }
    void writeWord(uint16_t word) { (void)(word); }
};



# 8 "../../src/platforms/stub/fastspi_stub.h" 2
# 6 "../../src/platforms/stub/fastled_stub.h" 2
# 1 "../../src/platforms/stub/clockless_stub.h" 1
       




# 1 "../../src/platforms/stub/clockless_stub_generic.h" 1
       









template <int DATA_PIN, int T1, int T2, int T3, EOrder RGB_ORDER = RGB, int XTRA0 = 0, bool FLIP = false, int WAIT_TIME = 0>
class ClocklessController : public CPixelLEDController<RGB_ORDER> {
public:
 virtual void init() { }

protected:
 virtual void showPixels(PixelController<RGB_ORDER> & pixels) {
  (void)(pixels);
 }
};


# 7 "../../src/platforms/stub/clockless_stub.h" 2
# 7 "../../src/platforms/stub/fastled_stub.h" 2
# 55 "../../src/platforms.h" 2
# 86 "../../src/FastLED.h" 2
# 1 "../../src/fastled_progmem.h" 1
       


# 1 "../../src/platforms/null_progmem.h" 1
       
# 5 "../../src/fastled_progmem.h" 2
# 87 "../../src/FastLED.h" 2




# 1 "../../src/colorutils.h" 1
       




# 1 "../../src/fl/colorutils.h" 1
       
# 10 "../../src/fl/colorutils.h"
# 1 "../../src/fl/blur.h" 1
       






namespace fl {
# 28 "../../src/fl/blur.h"
void blur1d(CRGB *leds, uint16_t numLeds, fract8 blur_amount);
# 45 "../../src/fl/blur.h"
void blur2d(CRGB *leds, uint8_t width, uint8_t height, fract8 blur_amount,
            const fl::XYMap &xymap);




void blur2d(CRGB *leds, uint8_t width, uint8_t height, fract8 blur_amount)
    __attribute__((deprecated("Use blur2d(..., const fl::XYMap& xymap) instead")));







void blurRows(CRGB *leds, uint8_t width, uint8_t height, fract8 blur_amount,
              const fl::XYMap &xymap);



void blurColumns(CRGB *leds, uint8_t width, uint8_t height, fract8 blur_amount,
                 const fl::XYMap &xymap);



}
# 11 "../../src/fl/colorutils.h" 2
# 1 "../../src/fl/colorutils_misc.h" 1
       




typedef uint32_t TProgmemRGBPalette16[16];

typedef uint32_t TProgmemHSVPalette16[16];



typedef uint32_t TProgmemRGBPalette32[32];

typedef uint32_t TProgmemHSVPalette32[32];





typedef const uint8_t TProgmemRGBGradientPalette_byte;



typedef const TProgmemRGBGradientPalette_byte *TProgmemRGBGradientPalette_bytes;

typedef TProgmemRGBGradientPalette_bytes TProgmemRGBGradientPaletteRef;

namespace fl {




typedef enum {
    FORWARD_HUES,
    BACKWARD_HUES,
    SHORTEST_HUES,
    LONGEST_HUES
} TGradientDirectionCode;

}
# 12 "../../src/fl/colorutils.h" 2

# 1 "../../src/fl/fill.h" 1
       
# 11 "../../src/fl/fill.h"
namespace fl {
# 25 "../../src/fl/fill.h"
void fill_solid(struct CRGB *targetArray, int numToFill,
                const struct CRGB &color);


void fill_solid(struct CHSV *targetArray, int numToFill,
                const struct CHSV &color);
# 39 "../../src/fl/fill.h"
void fill_rainbow(struct CRGB *targetArray, int numToFill, uint8_t initialhue,
                  uint8_t deltahue = 5);


void fill_rainbow(struct CHSV *targetArray, int numToFill, uint8_t initialhue,
                  uint8_t deltahue = 5);
# 54 "../../src/fl/fill.h"
void fill_rainbow_circular(struct CRGB *targetArray, int numToFill,
                           uint8_t initialhue, bool reversed = false);


void fill_rainbow_circular(struct CHSV *targetArray, int numToFill,
                           uint8_t initialhue, bool reversed = false);
# 76 "../../src/fl/fill.h"
template <typename T>
void fill_gradient(T *targetArray, uint16_t startpos, CHSV startcolor,
                   uint16_t endpos, CHSV endcolor,
                   TGradientDirectionCode directionCode = SHORTEST_HUES) {

    if (endpos < startpos) {
        uint16_t t = endpos;
        CHSV tc = endcolor;
        endcolor = startcolor;
        endpos = startpos;
        startpos = t;
        startcolor = tc;
    }





    if (endcolor.value == 0 || endcolor.saturation == 0) {
        endcolor.hue = startcolor.hue;
    }





    if (startcolor.value == 0 || startcolor.saturation == 0) {
        startcolor.hue = endcolor.hue;
    }

    int16_t huedistance87;
    int16_t satdistance87;
    int16_t valdistance87;

    satdistance87 = (endcolor.sat - startcolor.sat) << 7;
    valdistance87 = (endcolor.val - startcolor.val) << 7;

    uint8_t huedelta8 = endcolor.hue - startcolor.hue;

    if (directionCode == SHORTEST_HUES) {
        directionCode = FORWARD_HUES;
        if (huedelta8 > 127) {
            directionCode = BACKWARD_HUES;
        }
    }

    if (directionCode == LONGEST_HUES) {
        directionCode = FORWARD_HUES;
        if (huedelta8 < 128) {
            directionCode = BACKWARD_HUES;
        }
    }

    if (directionCode == FORWARD_HUES) {
        huedistance87 = huedelta8 << 7;
    } else
    {
        huedistance87 = (uint8_t)(256 - huedelta8) << 7;
        huedistance87 = -huedistance87;
    }

    uint16_t pixeldistance = endpos - startpos;
    int16_t divisor = pixeldistance ? pixeldistance : 1;
# 160 "../../src/fl/fill.h"
    int16_t huedelta87 = huedistance87 / divisor;
    int16_t satdelta87 = satdistance87 / divisor;
    int16_t valdelta87 = valdistance87 / divisor;

    huedelta87 *= 2;
    satdelta87 *= 2;
    valdelta87 *= 2;

    accum88 hue88 = startcolor.hue << 8;
    accum88 sat88 = startcolor.sat << 8;
    accum88 val88 = startcolor.val << 8;
    for (uint16_t i = startpos; i <= endpos; ++i) {
        targetArray[i] = CHSV(hue88 >> 8, sat88 >> 8, val88 >> 8);
        hue88 += huedelta87;
        sat88 += satdelta87;
        val88 += valdelta87;
    }

}
# 187 "../../src/fl/fill.h"
template <typename T>
void fill_gradient(T *targetArray, uint16_t numLeds, const CHSV &c1,
                   const CHSV &c2,
                   TGradientDirectionCode directionCode = SHORTEST_HUES) {
    uint16_t last = numLeds - 1;
    fill_gradient(targetArray, 0, c1, last, c2, directionCode);
}
# 203 "../../src/fl/fill.h"
template <typename T>
void fill_gradient(T *targetArray, uint16_t numLeds, const CHSV &c1,
                   const CHSV &c2, const CHSV &c3,
                   TGradientDirectionCode directionCode = SHORTEST_HUES) {
    uint16_t half = (numLeds / 2);
    uint16_t last = numLeds - 1;
    fill_gradient(targetArray, 0, c1, half, c2, directionCode);
    fill_gradient(targetArray, half, c2, last, c3, directionCode);
}
# 222 "../../src/fl/fill.h"
template <typename T>
void fill_gradient(T *targetArray, uint16_t numLeds, const CHSV &c1,
                   const CHSV &c2, const CHSV &c3, const CHSV &c4,
                   TGradientDirectionCode directionCode = SHORTEST_HUES) {
    uint16_t onethird = (numLeds / 3);
    uint16_t twothirds = ((numLeds * 2) / 3);
    uint16_t last = numLeds - 1;
    fill_gradient(targetArray, 0, c1, onethird, c2, directionCode);
    fill_gradient(targetArray, onethird, c2, twothirds, c3, directionCode);
    fill_gradient(targetArray, twothirds, c3, last, c4, directionCode);
}
# 246 "../../src/fl/fill.h"
void fill_gradient_RGB(CRGB *leds, uint16_t startpos, CRGB startcolor,
                       uint16_t endpos, CRGB endcolor);







void fill_gradient_RGB(CRGB *leds, uint16_t numLeds, const CRGB &c1,
                       const CRGB &c2);
# 265 "../../src/fl/fill.h"
void fill_gradient_RGB(CRGB *leds, uint16_t numLeds, const CRGB &c1,
                       const CRGB &c2, const CRGB &c3);
# 276 "../../src/fl/fill.h"
void fill_gradient_RGB(CRGB *leds, uint16_t numLeds, const CRGB &c1,
                       const CRGB &c2, const CRGB &c3, const CRGB &c4);

}
# 14 "../../src/fl/colorutils.h" 2
# 27 "../../src/fl/colorutils.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-align"

namespace fl {
# 43 "../../src/fl/colorutils.h"
void fadeLightBy(CRGB *leds, uint16_t num_leds, uint8_t fadeBy);


void fade_video(CRGB *leds, uint16_t num_leds, uint8_t fadeBy);






void nscale8_video(CRGB *leds, uint16_t num_leds, uint8_t scale);






void fadeToBlackBy(CRGB *leds, uint16_t num_leds, uint8_t fadeBy);


void fade_raw(CRGB *leds, uint16_t num_leds, uint8_t fadeBy);







void nscale8(CRGB *leds, uint16_t num_leds, uint8_t scale);
# 84 "../../src/fl/colorutils.h"
void fadeUsingColor(CRGB *leds, uint16_t numLeds, const CRGB &colormask);
# 97 "../../src/fl/colorutils.h"
CRGB blend(const CRGB &p1, const CRGB &p2, fract8 amountOfP2);



CHSV blend(const CHSV &p1, const CHSV &p2, fract8 amountOfP2,
           TGradientDirectionCode directionCode = SHORTEST_HUES);
# 112 "../../src/fl/colorutils.h"
CRGB *blend(const CRGB *src1, const CRGB *src2, CRGB *dest, uint16_t count,
            fract8 amountOfsrc2);



CHSV *blend(const CHSV *src1, const CHSV *src2, CHSV *dest, uint16_t count,
            fract8 amountOfsrc2,
            TGradientDirectionCode directionCode = SHORTEST_HUES);






CRGB &nblend(CRGB &existing, const CRGB &overlay, fract8 amountOfOverlay);



CHSV &nblend(CHSV &existing, const CHSV &overlay, fract8 amountOfOverlay,
             TGradientDirectionCode directionCode = SHORTEST_HUES);







void nblend(CRGB *existing, const CRGB *overlay, uint16_t count,
            fract8 amountOfOverlay);



void nblend(CHSV *existing, const CHSV *overlay, uint16_t count,
            fract8 amountOfOverlay,
            TGradientDirectionCode directionCode = SHORTEST_HUES);
# 158 "../../src/fl/colorutils.h"
CRGB HeatColor(uint8_t temperature);
# 238 "../../src/fl/colorutils.h"
class CRGBPalette16;
class CRGBPalette32;
class CRGBPalette256;
class CHSVPalette16;
class CHSVPalette32;
class CHSVPalette256;





typedef union {
    struct {
        uint8_t index;
        uint8_t r;
        uint8_t g;
        uint8_t b;
    };
    uint32_t dword;
    uint8_t bytes[4];
} TRGBGradientPaletteEntryUnion;

typedef uint8_t
    TDynamicRGBGradientPalette_byte;

typedef const TDynamicRGBGradientPalette_byte
    *TDynamicRGBGradientPalette_bytes;

typedef TDynamicRGBGradientPalette_bytes
    TDynamicRGBGradientPaletteRef;
# 279 "../../src/fl/colorutils.h"
void UpscalePalette(const class CRGBPalette16 &srcpal16,
                    class CRGBPalette256 &destpal256);

void UpscalePalette(const class CHSVPalette16 &srcpal16,
                    class CHSVPalette256 &destpal256);




void UpscalePalette(const class CRGBPalette16 &srcpal16,
                    class CRGBPalette32 &destpal32);

void UpscalePalette(const class CHSVPalette16 &srcpal16,
                    class CHSVPalette32 &destpal32);




void UpscalePalette(const class CRGBPalette32 &srcpal32,
                    class CRGBPalette256 &destpal256);

void UpscalePalette(const class CHSVPalette32 &srcpal32,
                    class CHSVPalette256 &destpal256);







class CHSVPalette16 {
  public:
    CHSV entries[16];


    CHSVPalette16() {};


    CHSVPalette16(const CHSV &c00, const CHSV &c01, const CHSV &c02,
                  const CHSV &c03, const CHSV &c04, const CHSV &c05,
                  const CHSV &c06, const CHSV &c07, const CHSV &c08,
                  const CHSV &c09, const CHSV &c10, const CHSV &c11,
                  const CHSV &c12, const CHSV &c13, const CHSV &c14,
                  const CHSV &c15) {
        entries[0] = c00;
        entries[1] = c01;
        entries[2] = c02;
        entries[3] = c03;
        entries[4] = c04;
        entries[5] = c05;
        entries[6] = c06;
        entries[7] = c07;
        entries[8] = c08;
        entries[9] = c09;
        entries[10] = c10;
        entries[11] = c11;
        entries[12] = c12;
        entries[13] = c13;
        entries[14] = c14;
        entries[15] = c15;
    };


    CHSVPalette16(const CHSVPalette16 &rhs) {
        memmove((void *)&(entries[0]), &(rhs.entries[0]), sizeof(entries));
    }


    CHSVPalette16 &operator=(const CHSVPalette16 &rhs) {
        memmove((void *)&(entries[0]), &(rhs.entries[0]), sizeof(entries));
        return *this;
    }


    CHSVPalette16(const TProgmemHSVPalette16 &rhs) {
        for (uint8_t i = 0; i < 16; ++i) {
            CRGB xyz((*((const uint32_t *)(rhs + i))));
            entries[i].hue = xyz.red;
            entries[i].sat = xyz.green;
            entries[i].val = xyz.blue;
        }
    }


    CHSVPalette16 &operator=(const TProgmemHSVPalette16 &rhs) {
        for (uint8_t i = 0; i < 16; ++i) {
            CRGB xyz((*((const uint32_t *)(rhs + i))));
            entries[i].hue = xyz.red;
            entries[i].sat = xyz.green;
            entries[i].val = xyz.blue;
        }
        return *this;
    }







    inline CHSV &operator[](uint8_t x) __attribute__((always_inline)) {
        return entries[x];
    }


    inline const CHSV &operator[](uint8_t x) const
        __attribute__((always_inline)) {
        return entries[x];
    }


    inline CHSV &operator[](int x) __attribute__((always_inline)) {
        return entries[(uint8_t)x];
    }


    inline const CHSV &operator[](int x) const __attribute__((always_inline)) {
        return entries[(uint8_t)x];
    }


    operator CHSV *() { return &(entries[0]); }


    bool operator==(const CHSVPalette16 &rhs) const {
        const uint8_t *p = (const uint8_t *)(&(this->entries[0]));
        const uint8_t *q = (const uint8_t *)(&(rhs.entries[0]));
        if (p == q)
            return true;
        for (uint8_t i = 0; i < (sizeof(entries)); ++i) {
            if (*p != *q)
                return false;
            ++p;
            ++q;
        }
        return true;
    }


    bool operator!=(const CHSVPalette16 &rhs) const { return !(*this == rhs); }



    CHSVPalette16(const CHSV &c1) { fill_solid(&(entries[0]), 16, c1); }




    CHSVPalette16(const CHSV &c1, const CHSV &c2) {
        fill_gradient(&(entries[0]), 16, c1, c2);
    }





    CHSVPalette16(const CHSV &c1, const CHSV &c2, const CHSV &c3) {
        fill_gradient(&(entries[0]), 16, c1, c2, c3);
    }






    CHSVPalette16(const CHSV &c1, const CHSV &c2, const CHSV &c3,
                  const CHSV &c4) {
        fill_gradient(&(entries[0]), 16, c1, c2, c3, c4);
    }
};


class CHSVPalette256 {
  public:
    CHSV entries[256];


    CHSVPalette256() {};





    CHSVPalette256(const CHSV &c00, const CHSV &c01, const CHSV &c02,
                   const CHSV &c03, const CHSV &c04, const CHSV &c05,
                   const CHSV &c06, const CHSV &c07, const CHSV &c08,
                   const CHSV &c09, const CHSV &c10, const CHSV &c11,
                   const CHSV &c12, const CHSV &c13, const CHSV &c14,
                   const CHSV &c15) {
        CHSVPalette16 p16(c00, c01, c02, c03, c04, c05, c06, c07, c08, c09, c10,
                          c11, c12, c13, c14, c15);
        *this = p16;
    };


    CHSVPalette256(const CHSVPalette256 &rhs) {
        memmove((void *)&(entries[0]), &(rhs.entries[0]), sizeof(entries));
    }

    CHSVPalette256 &operator=(const CHSVPalette256 &rhs) {
        memmove((void *)&(entries[0]), &(rhs.entries[0]), sizeof(entries));
        return *this;
    }


    CHSVPalette256(const CHSVPalette16 &rhs16) { UpscalePalette(rhs16, *this); }

    CHSVPalette256 &operator=(const CHSVPalette16 &rhs16) {
        UpscalePalette(rhs16, *this);
        return *this;
    }


    CHSVPalette256(const TProgmemRGBPalette16 &rhs) {
        CHSVPalette16 p16(rhs);
        *this = p16;
    }

    CHSVPalette256 &operator=(const TProgmemRGBPalette16 &rhs) {
        CHSVPalette16 p16(rhs);
        *this = p16;
        return *this;
    }


    inline CHSV &operator[](uint8_t x) __attribute__((always_inline)) {
        return entries[x];
    }

    inline const CHSV &operator[](uint8_t x) const
        __attribute__((always_inline)) {
        return entries[x];
    }


    inline CHSV &operator[](int x) __attribute__((always_inline)) {
        return entries[(uint8_t)x];
    }

    inline const CHSV &operator[](int x) const __attribute__((always_inline)) {
        return entries[(uint8_t)x];
    }


    operator CHSV *() { return &(entries[0]); }


    bool operator==(const CHSVPalette256 &rhs) const {
        const uint8_t *p = (const uint8_t *)(&(this->entries[0]));
        const uint8_t *q = (const uint8_t *)(&(rhs.entries[0]));
        if (p == q)
            return true;
        for (uint16_t i = 0; i < (sizeof(entries)); ++i) {
            if (*p != *q)
                return false;
            ++p;
            ++q;
        }
        return true;
    }


    bool operator!=(const CHSVPalette256 &rhs) const { return !(*this == rhs); }


    CHSVPalette256(const CHSV &c1) { fill_solid(&(entries[0]), 256, c1); }

    CHSVPalette256(const CHSV &c1, const CHSV &c2) {
        fill_gradient(&(entries[0]), 256, c1, c2);
    }


    CHSVPalette256(const CHSV &c1, const CHSV &c2, const CHSV &c3) {
        fill_gradient(&(entries[0]), 256, c1, c2, c3);
    }


    CHSVPalette256(const CHSV &c1, const CHSV &c2, const CHSV &c3,
                   const CHSV &c4) {
        fill_gradient(&(entries[0]), 256, c1, c2, c3, c4);
    }
};


class CRGBPalette16 {
  public:
    CRGB entries[16];


    CRGBPalette16() {};


    CRGBPalette16(const CRGB &c00, const CRGB &c01, const CRGB &c02,
                  const CRGB &c03, const CRGB &c04, const CRGB &c05,
                  const CRGB &c06, const CRGB &c07, const CRGB &c08,
                  const CRGB &c09, const CRGB &c10, const CRGB &c11,
                  const CRGB &c12, const CRGB &c13, const CRGB &c14,
                  const CRGB &c15) {
        entries[0] = c00;
        entries[1] = c01;
        entries[2] = c02;
        entries[3] = c03;
        entries[4] = c04;
        entries[5] = c05;
        entries[6] = c06;
        entries[7] = c07;
        entries[8] = c08;
        entries[9] = c09;
        entries[10] = c10;
        entries[11] = c11;
        entries[12] = c12;
        entries[13] = c13;
        entries[14] = c14;
        entries[15] = c15;
    };


    CRGBPalette16(const CRGBPalette16 &rhs) {
        memmove((void *)&(entries[0]), &(rhs.entries[0]), sizeof(entries));
    }

    CRGBPalette16(const CRGB rhs[16]) {
        memmove((void *)&(entries[0]), &(rhs[0]), sizeof(entries));
    }

    CRGBPalette16 &operator=(const CRGBPalette16 &rhs) {
        memmove((void *)&(entries[0]), &(rhs.entries[0]), sizeof(entries));
        return *this;
    }

    CRGBPalette16 &operator=(const CRGB rhs[16]) {
        memmove((void *)&(entries[0]), &(rhs[0]), sizeof(entries));
        return *this;
    }


    CRGBPalette16(const CHSVPalette16 &rhs) {
        for (uint8_t i = 0; i < 16; ++i) {
            entries[i] = rhs.entries[i];
        }
    }

    CRGBPalette16(const CHSV rhs[16]) {
        for (uint8_t i = 0; i < 16; ++i) {
            entries[i] = rhs[i];
        }
    }

    CRGBPalette16 &operator=(const CHSVPalette16 &rhs) {
        for (uint8_t i = 0; i < 16; ++i) {
            entries[i] = rhs.entries[i];
        }
        return *this;
    }

    CRGBPalette16 &operator=(const CHSV rhs[16]) {
        for (uint8_t i = 0; i < 16; ++i) {
            entries[i] = rhs[i];
        }
        return *this;
    }


    CRGBPalette16(const TProgmemRGBPalette16 &rhs) {
        for (uint8_t i = 0; i < 16; ++i) {
            entries[i] = (*((const uint32_t *)(rhs + i)));
        }
    }

    CRGBPalette16 &operator=(const TProgmemRGBPalette16 &rhs) {
        for (uint8_t i = 0; i < 16; ++i) {
            entries[i] = (*((const uint32_t *)(rhs + i)));
        }
        return *this;
    }


    bool operator==(const CRGBPalette16 &rhs) const {
        const uint8_t *p = (const uint8_t *)(&(this->entries[0]));
        const uint8_t *q = (const uint8_t *)(&(rhs.entries[0]));
        if (p == q)
            return true;
        for (uint8_t i = 0; i < (sizeof(entries)); ++i) {
            if (*p != *q)
                return false;
            ++p;
            ++q;
        }
        return true;
    }

    bool operator!=(const CRGBPalette16 &rhs) const { return !(*this == rhs); }

    inline CRGB &operator[](uint8_t x) __attribute__((always_inline)) {
        return entries[x];
    }

    inline const CRGB &operator[](uint8_t x) const
        __attribute__((always_inline)) {
        return entries[x];
    }


    inline CRGB &operator[](int x) __attribute__((always_inline)) {
        return entries[(uint8_t)x];
    }

    inline const CRGB &operator[](int x) const __attribute__((always_inline)) {
        return entries[(uint8_t)x];
    }


    operator CRGB *() { return &(entries[0]); }


    CRGBPalette16(const CHSV &c1) { fill_solid(&(entries[0]), 16, c1); }

    CRGBPalette16(const CHSV &c1, const CHSV &c2) {
        fill_gradient(&(entries[0]), 16, c1, c2);
    }


    CRGBPalette16(const CHSV &c1, const CHSV &c2, const CHSV &c3) {
        fill_gradient(&(entries[0]), 16, c1, c2, c3);
    }


    CRGBPalette16(const CHSV &c1, const CHSV &c2, const CHSV &c3,
                  const CHSV &c4) {
        fill_gradient(&(entries[0]), 16, c1, c2, c3, c4);
    }


    CRGBPalette16(const CRGB &c1) { fill_solid(&(entries[0]), 16, c1); }

    CRGBPalette16(const CRGB &c1, const CRGB &c2) {
        fill_gradient_RGB(&(entries[0]), 16, c1, c2);
    }


    CRGBPalette16(const CRGB &c1, const CRGB &c2, const CRGB &c3) {
        fill_gradient_RGB(&(entries[0]), 16, c1, c2, c3);
    }


    CRGBPalette16(const CRGB &c1, const CRGB &c2, const CRGB &c3,
                  const CRGB &c4) {
        fill_gradient_RGB(&(entries[0]), 16, c1, c2, c3, c4);
    }
# 758 "../../src/fl/colorutils.h"
    CRGBPalette16(TProgmemRGBGradientPalette_bytes progpal) { *this = progpal; }

    CRGBPalette16 &operator=(TProgmemRGBGradientPalette_bytes progpal) {
        TRGBGradientPaletteEntryUnion *progent =
            (TRGBGradientPaletteEntryUnion *)(progpal);
        TRGBGradientPaletteEntryUnion u;


        uint16_t count = 0;
        do {
            u.dword = (*((const uint32_t *)(progent + count)));
            ++count;
        } while (u.index != 255);

        int8_t lastSlotUsed = -1;

        u.dword = (*((const uint32_t *)(progent)));
        CRGB rgbstart(u.r, u.g, u.b);

        int indexstart = 0;
        uint8_t istart8 = 0;
        uint8_t iend8 = 0;
        while (indexstart < 255) {
            ++progent;
            u.dword = (*((const uint32_t *)(progent)));
            int indexend = u.index;
            CRGB rgbend(u.r, u.g, u.b);
            istart8 = indexstart / 16;
            iend8 = indexend / 16;
            if (count < 16) {
                if ((istart8 <= lastSlotUsed) && (lastSlotUsed < 15)) {
                    istart8 = lastSlotUsed + 1;
                    if (iend8 < istart8) {
                        iend8 = istart8;
                    }
                }
                lastSlotUsed = iend8;
            }
            fill_gradient_RGB(&(entries[0]), istart8, rgbstart, iend8, rgbend);
            indexstart = indexend;
            rgbstart = rgbend;
        }
        return *this;
    }



    CRGBPalette16 &
    loadDynamicGradientPalette(TDynamicRGBGradientPalette_bytes gpal) {
        TRGBGradientPaletteEntryUnion *ent =
            (TRGBGradientPaletteEntryUnion *)(gpal);
        TRGBGradientPaletteEntryUnion u;


        uint16_t count = 0;
        do {
            u = *(ent + count);
            ++count;
        } while (u.index != 255);

        int8_t lastSlotUsed = -1;

        u = *ent;
        CRGB rgbstart(u.r, u.g, u.b);

        int indexstart = 0;
        uint8_t istart8 = 0;
        uint8_t iend8 = 0;
        while (indexstart < 255) {
            ++ent;
            u = *ent;
            int indexend = u.index;
            CRGB rgbend(u.r, u.g, u.b);
            istart8 = indexstart / 16;
            iend8 = indexend / 16;
            if (count < 16) {
                if ((istart8 <= lastSlotUsed) && (lastSlotUsed < 15)) {
                    istart8 = lastSlotUsed + 1;
                    if (iend8 < istart8) {
                        iend8 = istart8;
                    }
                }
                lastSlotUsed = iend8;
            }
            fill_gradient_RGB(&(entries[0]), istart8, rgbstart, iend8, rgbend);
            indexstart = indexend;
            rgbstart = rgbend;
        }
        return *this;
    }
};


class CHSVPalette32 {
  public:
    CHSV entries[32];


    CHSVPalette32() {};





    CHSVPalette32(const CHSV &c00, const CHSV &c01, const CHSV &c02,
                  const CHSV &c03, const CHSV &c04, const CHSV &c05,
                  const CHSV &c06, const CHSV &c07, const CHSV &c08,
                  const CHSV &c09, const CHSV &c10, const CHSV &c11,
                  const CHSV &c12, const CHSV &c13, const CHSV &c14,
                  const CHSV &c15) {
        for (uint8_t i = 0; i < 2; ++i) {
            entries[0 + i] = c00;
            entries[2 + i] = c01;
            entries[4 + i] = c02;
            entries[6 + i] = c03;
            entries[8 + i] = c04;
            entries[10 + i] = c05;
            entries[12 + i] = c06;
            entries[14 + i] = c07;
            entries[16 + i] = c08;
            entries[18 + i] = c09;
            entries[20 + i] = c10;
            entries[22 + i] = c11;
            entries[24 + i] = c12;
            entries[26 + i] = c13;
            entries[28 + i] = c14;
            entries[30 + i] = c15;
        }
    };


    CHSVPalette32(const CHSVPalette32 &rhs) {
        memmove((void *)&(entries[0]), &(rhs.entries[0]), sizeof(entries));
    }

    CHSVPalette32 &operator=(const CHSVPalette32 &rhs) {
        memmove((void *)&(entries[0]), &(rhs.entries[0]), sizeof(entries));
        return *this;
    }


    CHSVPalette32(const TProgmemHSVPalette32 &rhs) {
        for (uint8_t i = 0; i < 32; ++i) {
            CRGB xyz((*((const uint32_t *)(rhs + i))));
            entries[i].hue = xyz.red;
            entries[i].sat = xyz.green;
            entries[i].val = xyz.blue;
        }
    }

    CHSVPalette32 &operator=(const TProgmemHSVPalette32 &rhs) {
        for (uint8_t i = 0; i < 32; ++i) {
            CRGB xyz((*((const uint32_t *)(rhs + i))));
            entries[i].hue = xyz.red;
            entries[i].sat = xyz.green;
            entries[i].val = xyz.blue;
        }
        return *this;
    }


    inline CHSV &operator[](uint8_t x) __attribute__((always_inline)) {
        return entries[x];
    }

    inline const CHSV &operator[](uint8_t x) const
        __attribute__((always_inline)) {
        return entries[x];
    }


    inline CHSV &operator[](int x) __attribute__((always_inline)) {
        return entries[(uint8_t)x];
    }

    inline const CHSV &operator[](int x) const __attribute__((always_inline)) {
        return entries[(uint8_t)x];
    }


    operator CHSV *() { return &(entries[0]); }


    bool operator==(const CHSVPalette32 &rhs) const {
        const uint8_t *p = (const uint8_t *)(&(this->entries[0]));
        const uint8_t *q = (const uint8_t *)(&(rhs.entries[0]));
        if (p == q)
            return true;
        for (uint8_t i = 0; i < (sizeof(entries)); ++i) {
            if (*p != *q)
                return false;
            ++p;
            ++q;
        }
        return true;
    }

    bool operator!=(const CHSVPalette32 &rhs) const { return !(*this == rhs); }


    CHSVPalette32(const CHSV &c1) { fill_solid(&(entries[0]), 32, c1); }

    CHSVPalette32(const CHSV &c1, const CHSV &c2) {
        fill_gradient(&(entries[0]), 32, c1, c2);
    }


    CHSVPalette32(const CHSV &c1, const CHSV &c2, const CHSV &c3) {
        fill_gradient(&(entries[0]), 32, c1, c2, c3);
    }


    CHSVPalette32(const CHSV &c1, const CHSV &c2, const CHSV &c3,
                  const CHSV &c4) {
        fill_gradient(&(entries[0]), 32, c1, c2, c3, c4);
    }
};


class CRGBPalette32 {
  public:
    CRGB entries[32];


    CRGBPalette32() {};






    CRGBPalette32(const CRGB &c00, const CRGB &c01, const CRGB &c02,
                  const CRGB &c03, const CRGB &c04, const CRGB &c05,
                  const CRGB &c06, const CRGB &c07, const CRGB &c08,
                  const CRGB &c09, const CRGB &c10, const CRGB &c11,
                  const CRGB &c12, const CRGB &c13, const CRGB &c14,
                  const CRGB &c15) {
        for (uint8_t i = 0; i < 2; ++i) {
            entries[0 + i] = c00;
            entries[2 + i] = c01;
            entries[4 + i] = c02;
            entries[6 + i] = c03;
            entries[8 + i] = c04;
            entries[10 + i] = c05;
            entries[12 + i] = c06;
            entries[14 + i] = c07;
            entries[16 + i] = c08;
            entries[18 + i] = c09;
            entries[20 + i] = c10;
            entries[22 + i] = c11;
            entries[24 + i] = c12;
            entries[26 + i] = c13;
            entries[28 + i] = c14;
            entries[30 + i] = c15;
        }
    };


    CRGBPalette32(const CRGBPalette32 &rhs) {
        memmove((void *)&(entries[0]), &(rhs.entries[0]), sizeof(entries));
    }

    CRGBPalette32(const CRGB rhs[32]) {
        memmove((void *)&(entries[0]), &(rhs[0]), sizeof(entries));
    }

    CRGBPalette32 &operator=(const CRGBPalette32 &rhs) {
        memmove((void *)&(entries[0]), &(rhs.entries[0]), sizeof(entries));
        return *this;
    }

    CRGBPalette32 &operator=(const CRGB rhs[32]) {
        memmove((void *)&(entries[0]), &(rhs[0]), sizeof(entries));
        return *this;
    }


    CRGBPalette32(const CHSVPalette32 &rhs) {
        for (uint8_t i = 0; i < 32; ++i) {
            entries[i] = rhs.entries[i];
        }
    }

    CRGBPalette32(const CHSV rhs[32]) {
        for (uint8_t i = 0; i < 32; ++i) {
            entries[i] = rhs[i];
        }
    }

    CRGBPalette32 &operator=(const CHSVPalette32 &rhs) {
        for (uint8_t i = 0; i < 32; ++i) {
            entries[i] = rhs.entries[i];
        }
        return *this;
    }

    CRGBPalette32 &operator=(const CHSV rhs[32]) {
        for (uint8_t i = 0; i < 32; ++i) {
            entries[i] = rhs[i];
        }
        return *this;
    }


    CRGBPalette32(const TProgmemRGBPalette32 &rhs) {
        for (uint8_t i = 0; i < 32; ++i) {
            entries[i] = (*((const uint32_t *)(rhs + i)));
        }
    }

    CRGBPalette32 &operator=(const TProgmemRGBPalette32 &rhs) {
        for (uint8_t i = 0; i < 32; ++i) {
            entries[i] = (*((const uint32_t *)(rhs + i)));
        }
        return *this;
    }


    bool operator==(const CRGBPalette32 &rhs) const {
        const uint8_t *p = (const uint8_t *)(&(this->entries[0]));
        const uint8_t *q = (const uint8_t *)(&(rhs.entries[0]));
        if (p == q)
            return true;
        for (uint8_t i = 0; i < (sizeof(entries)); ++i) {
            if (*p != *q)
                return false;
            ++p;
            ++q;
        }
        return true;
    }

    bool operator!=(const CRGBPalette32 &rhs) const { return !(*this == rhs); }


    inline CRGB &operator[](uint8_t x) __attribute__((always_inline)) {
        return entries[x];
    }

    inline const CRGB &operator[](uint8_t x) const
        __attribute__((always_inline)) {
        return entries[x];
    }


    inline CRGB &operator[](int x) __attribute__((always_inline)) {
        return entries[(uint8_t)x];
    }

    inline const CRGB &operator[](int x) const __attribute__((always_inline)) {
        return entries[(uint8_t)x];
    }


    operator CRGB *() { return &(entries[0]); }


    CRGBPalette32(const CHSV &c1) { fill_solid(&(entries[0]), 32, c1); }

    CRGBPalette32(const CHSV &c1, const CHSV &c2) {
        fill_gradient(&(entries[0]), 32, c1, c2);
    }


    CRGBPalette32(const CHSV &c1, const CHSV &c2, const CHSV &c3) {
        fill_gradient(&(entries[0]), 32, c1, c2, c3);
    }


    CRGBPalette32(const CHSV &c1, const CHSV &c2, const CHSV &c3,
                  const CHSV &c4) {
        fill_gradient(&(entries[0]), 32, c1, c2, c3, c4);
    }


    CRGBPalette32(const CRGB &c1) { fill_solid(&(entries[0]), 32, c1); }

    CRGBPalette32(const CRGB &c1, const CRGB &c2) {
        fill_gradient_RGB(&(entries[0]), 32, c1, c2);
    }


    CRGBPalette32(const CRGB &c1, const CRGB &c2, const CRGB &c3) {
        fill_gradient_RGB(&(entries[0]), 32, c1, c2, c3);
    }


    CRGBPalette32(const CRGB &c1, const CRGB &c2, const CRGB &c3,
                  const CRGB &c4) {
        fill_gradient_RGB(&(entries[0]), 32, c1, c2, c3, c4);
    }


    CRGBPalette32(const CRGBPalette16 &rhs16) { UpscalePalette(rhs16, *this); }

    CRGBPalette32 &operator=(const CRGBPalette16 &rhs16) {
        UpscalePalette(rhs16, *this);
        return *this;
    }


    CRGBPalette32(const TProgmemRGBPalette16 &rhs) {
        CRGBPalette16 p16(rhs);
        *this = p16;
    }

    CRGBPalette32 &operator=(const TProgmemRGBPalette16 &rhs) {
        CRGBPalette16 p16(rhs);
        *this = p16;
        return *this;
    }


    CRGBPalette32(TProgmemRGBGradientPalette_bytes progpal) { *this = progpal; }

    CRGBPalette32 &operator=(TProgmemRGBGradientPalette_bytes progpal) {
        TRGBGradientPaletteEntryUnion *progent =
            (TRGBGradientPaletteEntryUnion *)(progpal);
        TRGBGradientPaletteEntryUnion u;


        uint16_t count = 0;
        do {
            u.dword = (*((const uint32_t *)(progent + count)));
            ++count;
        } while (u.index != 255);

        int8_t lastSlotUsed = -1;

        u.dword = (*((const uint32_t *)(progent)));
        CRGB rgbstart(u.r, u.g, u.b);

        int indexstart = 0;
        uint8_t istart8 = 0;
        uint8_t iend8 = 0;
        while (indexstart < 255) {
            ++progent;
            u.dword = (*((const uint32_t *)(progent)));
            int indexend = u.index;
            CRGB rgbend(u.r, u.g, u.b);
            istart8 = indexstart / 8;
            iend8 = indexend / 8;
            if (count < 16) {
                if ((istart8 <= lastSlotUsed) && (lastSlotUsed < 31)) {
                    istart8 = lastSlotUsed + 1;
                    if (iend8 < istart8) {
                        iend8 = istart8;
                    }
                }
                lastSlotUsed = iend8;
            }
            fill_gradient_RGB(&(entries[0]), istart8, rgbstart, iend8, rgbend);
            indexstart = indexend;
            rgbstart = rgbend;
        }
        return *this;
    }


    CRGBPalette32 &
    loadDynamicGradientPalette(TDynamicRGBGradientPalette_bytes gpal) {
        TRGBGradientPaletteEntryUnion *ent =
            (TRGBGradientPaletteEntryUnion *)(gpal);
        TRGBGradientPaletteEntryUnion u;


        uint16_t count = 0;
        do {
            u = *(ent + count);
            ++count;
        } while (u.index != 255);

        int8_t lastSlotUsed = -1;

        u = *ent;
        CRGB rgbstart(u.r, u.g, u.b);

        int indexstart = 0;
        uint8_t istart8 = 0;
        uint8_t iend8 = 0;
        while (indexstart < 255) {
            ++ent;
            u = *ent;
            int indexend = u.index;
            CRGB rgbend(u.r, u.g, u.b);
            istart8 = indexstart / 8;
            iend8 = indexend / 8;
            if (count < 16) {
                if ((istart8 <= lastSlotUsed) && (lastSlotUsed < 31)) {
                    istart8 = lastSlotUsed + 1;
                    if (iend8 < istart8) {
                        iend8 = istart8;
                    }
                }
                lastSlotUsed = iend8;
            }
            fill_gradient_RGB(&(entries[0]), istart8, rgbstart, iend8, rgbend);
            indexstart = indexend;
            rgbstart = rgbend;
        }
        return *this;
    }
};


class CRGBPalette256 {
  public:
    CRGB entries[256];


    CRGBPalette256() {};






    CRGBPalette256(const CRGB &c00, const CRGB &c01, const CRGB &c02,
                   const CRGB &c03, const CRGB &c04, const CRGB &c05,
                   const CRGB &c06, const CRGB &c07, const CRGB &c08,
                   const CRGB &c09, const CRGB &c10, const CRGB &c11,
                   const CRGB &c12, const CRGB &c13, const CRGB &c14,
                   const CRGB &c15) {
        CRGBPalette16 p16(c00, c01, c02, c03, c04, c05, c06, c07, c08, c09, c10,
                          c11, c12, c13, c14, c15);
        *this = p16;
    };


    CRGBPalette256(const CRGBPalette256 &rhs) {
        memmove((void *)&(entries[0]), &(rhs.entries[0]), sizeof(entries));
    }

    CRGBPalette256(const CRGB rhs[256]) {
        memmove((void *)&(entries[0]), &(rhs[0]), sizeof(entries));
    }

    CRGBPalette256 &operator=(const CRGBPalette256 &rhs) {
        memmove((void *)&(entries[0]), &(rhs.entries[0]), sizeof(entries));
        return *this;
    }

    CRGBPalette256 &operator=(const CRGB rhs[256]) {
        memmove((void *)&(entries[0]), &(rhs[0]), sizeof(entries));
        return *this;
    }


    CRGBPalette256(const CHSVPalette256 &rhs) {
        for (int i = 0; i < 256; ++i) {
            entries[i] = rhs.entries[i];
        }
    }

    CRGBPalette256(const CHSV rhs[256]) {
        for (int i = 0; i < 256; ++i) {
            entries[i] = rhs[i];
        }
    }

    CRGBPalette256 &operator=(const CHSVPalette256 &rhs) {
        for (int i = 0; i < 256; ++i) {
            entries[i] = rhs.entries[i];
        }
        return *this;
    }

    CRGBPalette256 &operator=(const CHSV rhs[256]) {
        for (int i = 0; i < 256; ++i) {
            entries[i] = rhs[i];
        }
        return *this;
    }


    CRGBPalette256(const CRGBPalette16 &rhs16) { UpscalePalette(rhs16, *this); }

    CRGBPalette256 &operator=(const CRGBPalette16 &rhs16) {
        UpscalePalette(rhs16, *this);
        return *this;
    }


    CRGBPalette256(const TProgmemRGBPalette16 &rhs) {
        CRGBPalette16 p16(rhs);
        *this = p16;
    }

    CRGBPalette256 &operator=(const TProgmemRGBPalette16 &rhs) {
        CRGBPalette16 p16(rhs);
        *this = p16;
        return *this;
    }


    bool operator==(const CRGBPalette256 &rhs) const {
        const uint8_t *p = (const uint8_t *)(&(this->entries[0]));
        const uint8_t *q = (const uint8_t *)(&(rhs.entries[0]));
        if (p == q)
            return true;
        for (uint16_t i = 0; i < (sizeof(entries)); ++i) {
            if (*p != *q)
                return false;
            ++p;
            ++q;
        }
        return true;
    }

    bool operator!=(const CRGBPalette256 &rhs) const { return !(*this == rhs); }


    inline CRGB &operator[](uint8_t x) __attribute__((always_inline)) {
        return entries[x];
    }

    inline const CRGB &operator[](uint8_t x) const
        __attribute__((always_inline)) {
        return entries[x];
    }


    inline CRGB &operator[](int x) __attribute__((always_inline)) {
        return entries[(uint8_t)x];
    }

    inline const CRGB &operator[](int x) const __attribute__((always_inline)) {
        return entries[(uint8_t)x];
    }


    operator CRGB *() { return &(entries[0]); }


    CRGBPalette256(const CHSV &c1) { fill_solid(&(entries[0]), 256, c1); }

    CRGBPalette256(const CHSV &c1, const CHSV &c2) {
        fill_gradient(&(entries[0]), 256, c1, c2);
    }


    CRGBPalette256(const CHSV &c1, const CHSV &c2, const CHSV &c3) {
        fill_gradient(&(entries[0]), 256, c1, c2, c3);
    }


    CRGBPalette256(const CHSV &c1, const CHSV &c2, const CHSV &c3,
                   const CHSV &c4) {
        fill_gradient(&(entries[0]), 256, c1, c2, c3, c4);
    }


    CRGBPalette256(const CRGB &c1) { fill_solid(&(entries[0]), 256, c1); }

    CRGBPalette256(const CRGB &c1, const CRGB &c2) {
        fill_gradient_RGB(&(entries[0]), 256, c1, c2);
    }


    CRGBPalette256(const CRGB &c1, const CRGB &c2, const CRGB &c3) {
        fill_gradient_RGB(&(entries[0]), 256, c1, c2, c3);
    }


    CRGBPalette256(const CRGB &c1, const CRGB &c2, const CRGB &c3,
                   const CRGB &c4) {
        fill_gradient_RGB(&(entries[0]), 256, c1, c2, c3, c4);
    }


    CRGBPalette256(TProgmemRGBGradientPalette_bytes progpal) {
        *this = progpal;
    }

    CRGBPalette256 &operator=(TProgmemRGBGradientPalette_bytes progpal) {
        TRGBGradientPaletteEntryUnion *progent =
            (TRGBGradientPaletteEntryUnion *)(progpal);
        TRGBGradientPaletteEntryUnion u;
        u.dword = (*((const uint32_t *)(progent)));
        CRGB rgbstart(u.r, u.g, u.b);

        int indexstart = 0;
        while (indexstart < 255) {
            ++progent;
            u.dword = (*((const uint32_t *)(progent)));
            int indexend = u.index;
            CRGB rgbend(u.r, u.g, u.b);
            fill_gradient_RGB(&(entries[0]), indexstart, rgbstart, indexend,
                              rgbend);
            indexstart = indexend;
            rgbstart = rgbend;
        }
        return *this;
    }


    CRGBPalette256 &
    loadDynamicGradientPalette(TDynamicRGBGradientPalette_bytes gpal) {
        TRGBGradientPaletteEntryUnion *ent =
            (TRGBGradientPaletteEntryUnion *)(gpal);
        TRGBGradientPaletteEntryUnion u;
        u = *ent;
        CRGB rgbstart(u.r, u.g, u.b);

        int indexstart = 0;
        while (indexstart < 255) {
            ++ent;
            u = *ent;
            int indexend = u.index;
            CRGB rgbend(u.r, u.g, u.b);
            fill_gradient_RGB(&(entries[0]), indexstart, rgbstart, indexend,
                              rgbend);
            indexstart = indexend;
            rgbstart = rgbend;
        }
        return *this;
    }
};
# 1484 "../../src/fl/colorutils.h"
typedef enum {
    NOBLEND = 0,
    BLEND = 1,
    LINEARBLEND = 1,

    LINEARBLEND_NOWRAP =
        2
} TBlendType;
# 1503 "../../src/fl/colorutils.h"
CRGB ColorFromPalette(const CRGBPalette16 &pal, uint8_t index,
                      uint8_t brightness = 255,
                      TBlendType blendType = LINEARBLEND);







CRGB ColorFromPaletteExtended(const CRGBPalette16 &pal, uint16_t index,
                              uint8_t brightness, TBlendType blendType);






CRGB ColorFromPaletteExtended(const CRGBPalette32 &pal, uint16_t index,
                              uint8_t brightness, TBlendType blendType);



CRGB ColorFromPalette(const TProgmemRGBPalette16 &pal, uint8_t index,
                      uint8_t brightness = 255,
                      TBlendType blendType = LINEARBLEND);



CRGB ColorFromPalette(const CRGBPalette256 &pal, uint8_t index,
                      uint8_t brightness = 255, TBlendType blendType = NOBLEND);


CRGB ColorFromPaletteExtended(const CRGBPalette256 &pal, uint16_t index,
                              uint8_t brightness = 255,
                              TBlendType blendType = LINEARBLEND);



CHSV ColorFromPalette(const CHSVPalette16 &pal, uint8_t index,
                      uint8_t brightness = 255,
                      TBlendType blendType = LINEARBLEND);



CHSV ColorFromPalette(const CHSVPalette256 &pal, uint8_t index,
                      uint8_t brightness = 255, TBlendType blendType = NOBLEND);



CRGB ColorFromPalette(const CRGBPalette32 &pal, uint8_t index,
                      uint8_t brightness = 255,
                      TBlendType blendType = LINEARBLEND);



CRGB ColorFromPalette(const TProgmemRGBPalette32 &pal, uint8_t index,
                      uint8_t brightness = 255,
                      TBlendType blendType = LINEARBLEND);



CHSV ColorFromPalette(const CHSVPalette32 &pal, uint8_t index,
                      uint8_t brightness = 255,
                      TBlendType blendType = LINEARBLEND);
# 1579 "../../src/fl/colorutils.h"
template <typename PALETTE>
void fill_palette(CRGB *L, uint16_t N, uint8_t startIndex, uint8_t incIndex,
                  const PALETTE &pal, uint8_t brightness = 255,
                  TBlendType blendType = LINEARBLEND) {
    uint8_t colorIndex = startIndex;
    for (uint16_t i = 0; i < N; ++i) {
        L[i] = ColorFromPalette(pal, colorIndex, brightness, blendType);
        colorIndex += incIndex;
    }
}
# 1601 "../../src/fl/colorutils.h"
template <typename PALETTE>
void fill_palette_circular(CRGB *L, uint16_t N, uint8_t startIndex,
                           const PALETTE &pal, uint8_t brightness = 255,
                           TBlendType blendType = LINEARBLEND,
                           bool reversed = false) {
    if (N == 0)
        return;

    const uint16_t colorChange =
        65535 / N;
    uint16_t colorIndex = ((uint16_t)startIndex)
                          << 8;

    for (uint16_t i = 0; i < N; ++i) {
        L[i] = ColorFromPalette(pal, (colorIndex >> 8), brightness, blendType);
        if (reversed)
            colorIndex -= colorChange;
        else
            colorIndex += colorChange;
    }
}
# 1642 "../../src/fl/colorutils.h"
template <typename PALETTE>
void map_data_into_colors_through_palette(
    uint8_t *dataArray, uint16_t dataCount, CRGB *targetColorArray,
    const PALETTE &pal, uint8_t brightness = 255, uint8_t opacity = 255,
    TBlendType blendType = LINEARBLEND) {
    for (uint16_t i = 0; i < dataCount; ++i) {
        uint8_t d = dataArray[i];
        CRGB rgb = ColorFromPalette(pal, d, brightness, blendType);
        if (opacity == 255) {
            targetColorArray[i] = rgb;
        } else {
            targetColorArray[i].nscale8(256 - opacity);
            rgb.nscale8_video(opacity);
            targetColorArray[i] += rgb;
        }
    }
}
# 1698 "../../src/fl/colorutils.h"
void nblendPaletteTowardPalette(CRGBPalette16 &currentPalette,
                                CRGBPalette16 &targetPalette,
                                uint8_t maxChanges = 24);
# 1742 "../../src/fl/colorutils.h"
uint8_t applyGamma_video(uint8_t brightness, float gamma);





CRGB applyGamma_video(const CRGB &orig, float gamma);







CRGB applyGamma_video(const CRGB &orig, float gammaR, float gammaG,
                      float gammaB);




CRGB &napplyGamma_video(CRGB &rgb, float gamma);






CRGB &napplyGamma_video(CRGB &rgb, float gammaR, float gammaG, float gammaB);






void napplyGamma_video(CRGB *rgbarray, uint16_t count, float gamma);
# 1785 "../../src/fl/colorutils.h"
void napplyGamma_video(CRGB *rgbarray, uint16_t count, float gammaR,
                       float gammaG, float gammaB);



}

#pragma GCC diagnostic pop
# 7 "../../src/colorutils.h" 2

using fl::fadeLightBy;
using fl::fade_video;
using fl::fadeToBlackBy;
using fl::nscale8_video;
using fl::fade_raw;
using fl::nscale8;
using fl::fadeUsingColor;
using fl::blend;
using fl::CRGBPalette16;
using fl::CRGBPalette32;
using fl::CRGBPalette256;
using fl::CHSVPalette16;
using fl::CHSVPalette32;
using fl::CHSVPalette256;


using fl::HeatColor;
using fl::TRGBGradientPaletteEntryUnion;
using fl::TDynamicRGBGradientPalette_byte;
using fl::TDynamicRGBGradientPalette_bytes;





using fl::UpscalePalette;


using fl::TDynamicRGBGradientPaletteRef;
using fl::TGradientDirectionCode;
using fl::TBlendType;
using fl::ColorFromPalette;
using fl::ColorFromPaletteExtended;
using fl::fill_palette;
using fl::fill_gradient;
using fl::fill_rainbow;
using fl::fill_solid;
using fl::fill_palette_circular;
using fl::map_data_into_colors_through_palette;
using fl::nblendPaletteTowardPalette;
using fl::napplyGamma_video;
using fl::blurColumns;
using fl::blurRows;
using fl::blur1d;
using fl::blur2d;
using fl::nblend;
using fl::applyGamma_video;



using fl::NOBLEND;
using fl::BLEND;
using fl::LINEARBLEND;
using fl::LINEARBLEND_NOWRAP;
# 109 "../../src/colorutils.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 121 "../../src/colorutils.h"
#pragma GCC diagnostic pop
# 92 "../../src/FastLED.h" 2
# 1 "../../src/pixelset.h" 1
       
# 27 "../../src/pixelset.h"
# 1 "/usr/include/c++/14/stdlib.h" 1 3
# 28 "../../src/pixelset.h" 2







template<class PIXEL_TYPE>
class CPixelView;


typedef CPixelView<CRGB> CRGBSet;


__attribute__((always_inline)) inline
CRGB *operator+(const CRGBSet & pixels, int offset);
# 58 "../../src/pixelset.h"
template<class PIXEL_TYPE>
class CPixelView {
public:
    const int8_t dir;
    const int len;

    PIXEL_TYPE * const leds;
    PIXEL_TYPE * const end_pos;

public:

    inline CPixelView(const CPixelView & other) : dir(other.dir), len(other.len), leds(other.leds), end_pos(other.end_pos) {}





    inline CPixelView(PIXEL_TYPE *_leds, int _len) : dir(_len < 0 ? -1 : 1), len(_len), leds(_leds), end_pos(_leds + _len) {}






    inline CPixelView(PIXEL_TYPE *_leds, int _start, int _end) : dir(((_end-_start)<0) ? -1 : 1), len((_end - _start) + dir), leds(_leds + _start), end_pos(_leds + _start + len) {}



    int size() { return abs(len); }



    bool reversed() { return len < 0; }


    bool operator==(const CPixelView & rhs) const { return leds == rhs.leds && len == rhs.len && dir == rhs.dir; }


    bool operator!=(const CPixelView & rhs) const { return leds != rhs.leds || len != rhs.len || dir != rhs.dir; }


    inline PIXEL_TYPE & operator[](int x) const { if(dir & 0x80) { return leds[-x]; } else { return leds[x]; } }






    inline CPixelView operator()(int start, int end) { if(dir & 0x80) { return CPixelView(leds+len+1, -len-start-1, -len-end-1); } else { return CPixelView(leds, start, end); } }






    inline CPixelView operator-() { return CPixelView(leds, len - dir, 0); }


    inline operator PIXEL_TYPE* () const { return leds; }



    inline CPixelView & operator=(const PIXEL_TYPE & color) {
        for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel) = color; }
        return *this;
    }



    void dump() const {






    }




    inline CPixelView & operator=(const CPixelView & rhs) {
        for(iterator pixel = begin(), rhspixel = rhs.begin(), _end = end(), rhs_end = rhs.end(); (pixel != _end) && (rhspixel != rhs_end); ++pixel, ++rhspixel) {
            (*pixel) = (*rhspixel);
        }
        return *this;
    }





    inline CPixelView & addToRGB(uint8_t inc) { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel) += inc; } return *this; }

    inline CPixelView & operator+=(CPixelView & rhs) { for(iterator pixel = begin(), rhspixel = rhs.begin(), _end = end(), rhs_end = rhs.end(); (pixel != _end) && (rhspixel != rhs_end); ++pixel, ++rhspixel) { (*pixel) += (*rhspixel); } return *this; }


    inline CPixelView & subFromRGB(uint8_t inc) { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel) -= inc; } return *this; }

    inline CPixelView & operator-=(CPixelView & rhs) { for(iterator pixel = begin(), rhspixel = rhs.begin(), _end = end(), rhs_end = rhs.end(); (pixel != _end) && (rhspixel != rhs_end); ++pixel, ++rhspixel) { (*pixel) -= (*rhspixel); } return *this; }


    inline CPixelView & operator++() { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel)++; } return *this; }

    inline CPixelView & operator++(int DUMMY_ARG) {
        (void)(DUMMY_ARG);
        for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) {
            (*pixel)++;
        }
        return *this;
    }


    inline CPixelView & operator--() { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel)--; } return *this; }

    inline CPixelView & operator--(int DUMMY_ARG) {
        (void)(DUMMY_ARG);
        for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) {
            (*pixel)--;
        }
        return *this;
    }


    inline CPixelView & operator/=(uint8_t d) { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel) /= d; } return *this; }

    inline CPixelView & operator>>=(uint8_t d) { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel) >>= d; } return *this; }

    inline CPixelView & operator*=(uint8_t d) { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel) *= d; } return *this; }


    inline CPixelView & nscale8_video(uint8_t scaledown) { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel).nscale8_video(scaledown); } return *this;}

    inline CPixelView & operator%=(uint8_t scaledown) { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel).nscale8_video(scaledown); } return *this; }

    inline CPixelView & fadeLightBy(uint8_t fadefactor) { return nscale8_video(255 - fadefactor); }


    inline CPixelView & nscale8(uint8_t scaledown) { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel).nscale8(scaledown); } return *this; }

    inline CPixelView & nscale8(PIXEL_TYPE & scaledown) { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel).nscale8(scaledown); } return *this; }

    inline CPixelView & nscale8(CPixelView & rhs) { for(iterator pixel = begin(), rhspixel = rhs.begin(), _end = end(), rhs_end = rhs.end(); (pixel != _end) && (rhspixel != rhs_end); ++pixel, ++rhspixel) { (*pixel).nscale8((*rhspixel)); } return *this; }


    inline CPixelView & fadeToBlackBy(uint8_t fade) { return nscale8(255 - fade); }




    inline CPixelView & operator|=(const PIXEL_TYPE & rhs) { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel) |= rhs; } return *this; }


    inline CPixelView & operator|=(const CPixelView & rhs) { for(iterator pixel = begin(), rhspixel = rhs.begin(), _end = end(), rhs_end = rhs.end(); (pixel != _end) && (rhspixel != rhs_end); ++pixel, ++rhspixel) { (*pixel) |= (*rhspixel); } return *this; }


    inline CPixelView & operator|=(uint8_t d) { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel) |= d; } return *this; }




    inline CPixelView & operator&=(const PIXEL_TYPE & rhs) { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel) &= rhs; } return *this; }


    inline CPixelView & operator&=(const CPixelView & rhs) { for(iterator pixel = begin(), rhspixel = rhs.begin(), _end = end(), rhs_end = rhs.end(); (pixel != _end) && (rhspixel != rhs_end); ++pixel, ++rhspixel) { (*pixel) &= (*rhspixel); } return *this; }


    inline CPixelView & operator&=(uint8_t d) { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { (*pixel) &= d; } return *this; }





    inline operator bool() { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { if((*pixel)) return true; } return false; }







    inline CPixelView & fill_solid(const PIXEL_TYPE & color) { *this = color; return *this; }

    inline CPixelView & fill_solid(const CHSV & color) { *this = color; return *this; }





    inline CPixelView & fill_rainbow(uint8_t initialhue, uint8_t deltahue=5) {
        if(dir >= 0) {
            fl::fill_rainbow(leds,len,initialhue,deltahue);
        } else {
            fl::fill_rainbow(leds + len + 1,-len,initialhue - deltahue * (len+1),-deltahue);
        }
        return *this;
    }






    inline CPixelView & fill_gradient(const CHSV & startcolor, const CHSV & endcolor, TGradientDirectionCode directionCode = fl::SHORTEST_HUES) {
        if(dir >= 0) {
            fl::fill_gradient(leds,len,startcolor,endcolor,directionCode);
        } else {
            fl::fill_gradient(leds + len + 1,(-len),endcolor,startcolor,directionCode);
        }
        return *this;
    }







    inline CPixelView & fill_gradient(const CHSV & c1, const CHSV & c2, const CHSV & c3, TGradientDirectionCode directionCode = fl::SHORTEST_HUES) {
        if(dir >= 0) {
            fl::fill_gradient(leds,len,c1,c2,c3,directionCode);
        } else {
            fl::fill_gradient(leds + len + 1,-len,c3,c2,c1,directionCode);
        }
        return *this;
    }
# 292 "../../src/pixelset.h"
    inline CPixelView & fill_gradient(const CHSV & c1, const CHSV & c2, const CHSV & c3, const CHSV & c4, TGradientDirectionCode directionCode = fl::SHORTEST_HUES) {
        if(dir >= 0) {
            fl::fill_gradient(leds,len,c1,c2,c3,c4,directionCode);
        } else {
            fl::fill_gradient(leds + len + 1,-len,c4,c3,c2,c1,directionCode);
        }
        return *this;
    }






    inline CPixelView & fill_gradient_RGB(const PIXEL_TYPE & startcolor, const PIXEL_TYPE & endcolor, TGradientDirectionCode directionCode = fl::SHORTEST_HUES) {
        (void)(directionCode);
        if(dir >= 0) {
            fl::fill_gradient_RGB(leds,len,startcolor,endcolor);
        } else {
            fl::fill_gradient_RGB(leds + len + 1,(-len),endcolor,startcolor);
        }
        return *this;
    }






    inline CPixelView & fill_gradient_RGB(const PIXEL_TYPE & c1, const PIXEL_TYPE & c2, const PIXEL_TYPE & c3) {
        if(dir >= 0) {
            fl::fill_gradient_RGB(leds,len,c1,c2,c3);
        } else {
            fl::fill_gradient_RGB(leds + len + 1,-len,c3,c2,c1);
        }
        return *this;
    }







    inline CPixelView & fill_gradient_RGB(const PIXEL_TYPE & c1, const PIXEL_TYPE & c2, const PIXEL_TYPE & c3, const PIXEL_TYPE & c4) {
        if(dir >= 0) {
            fl::fill_gradient_RGB(leds,len,c1,c2,c3,c4);
        } else {
            fl::fill_gradient_RGB(leds + len + 1,-len,c4,c3,c2,c1);
        }
        return *this;
    }





    inline CPixelView & nblend(const PIXEL_TYPE & overlay, fract8 amountOfOverlay) { for(iterator pixel = begin(), _end = end(); pixel != _end; ++pixel) { fl::nblend((*pixel),overlay,amountOfOverlay); } return *this; }





    inline CPixelView & nblend(const CPixelView & rhs, fract8 amountOfOverlay) { for(iterator pixel = begin(), rhspixel = rhs.begin(), _end = end(), rhs_end = rhs.end(); (pixel != _end) && (rhspixel != rhs_end); ++pixel, ++rhspixel) { fl::nblend((*pixel),(*rhspixel),amountOfOverlay); } return *this; }





    inline CPixelView & blur1d(fract8 blur_amount) {
        if(dir >= 0) {
            fl::blur1d(leds,len,blur_amount);
        } else {
            fl::blur1d(leds + len + 1,-len,blur_amount);
        }
        return *this;
    }




    inline CPixelView & napplyGamma_video(float gamma) {
        if(dir >= 0) {
            fl::napplyGamma_video(leds,len,gamma);
        } else {
            fl::napplyGamma_video(leds + len + 1,-len,gamma);
        }
        return *this;
    }






    inline CPixelView & napplyGamma_video(float gammaR, float gammaG, float gammaB) {
        if(dir >= 0) {
            fl::napplyGamma_video(leds,len,gammaR,gammaG,gammaB);
        } else {
            fl::napplyGamma_video(leds + len + 1,-len,gammaR,gammaG,gammaB);
        }
        return *this;
    }
# 405 "../../src/pixelset.h"
    template <class T>
    class pixelset_iterator_base {
        T * leds;
        const int8_t dir;

    public:

        __attribute__((always_inline)) inline pixelset_iterator_base(const pixelset_iterator_base & rhs) : leds(rhs.leds), dir(rhs.dir) {}





        __attribute__((always_inline)) inline pixelset_iterator_base(T * _leds, const char _dir) : leds(_leds), dir(_dir) {}

        __attribute__((always_inline)) inline pixelset_iterator_base& operator++() { leds += dir; return *this; }
        __attribute__((always_inline)) inline pixelset_iterator_base operator++(int) { pixelset_iterator_base tmp(*this); leds += dir; return tmp; }

        __attribute__((always_inline)) inline bool operator==(pixelset_iterator_base & other) const { return leds == other.leds; }
        __attribute__((always_inline)) inline bool operator!=(pixelset_iterator_base & other) const { return leds != other.leds; }

        __attribute__((always_inline)) inline PIXEL_TYPE& operator*() const { return *leds; }
    };

    typedef pixelset_iterator_base<PIXEL_TYPE> iterator;
    typedef pixelset_iterator_base<const PIXEL_TYPE> const_iterator;

    iterator begin() { return iterator(leds, dir); }
    iterator end() { return iterator(end_pos, dir); }

    iterator begin() const { return iterator(leds, dir); }
    iterator end() const { return iterator(end_pos, dir); }

    const_iterator cbegin() const { return const_iterator(leds, dir); }
    const_iterator cend() const { return const_iterator(end_pos, dir); }


};

__attribute__((always_inline)) inline
CRGB *operator+(const CRGBSet & pixels, int offset) {
    return (CRGB*)pixels + offset;
}




template<int SIZE>
class CRGBArray : public CPixelView<CRGB> {
    CRGB rawleds[SIZE] = {0};

public:
    CRGBArray() : CPixelView<CRGB>(rawleds, SIZE) {}
    using CPixelView::operator=;
    CRGB* get() { return &rawleds[0]; }
    const CRGB* get() const { return &rawleds[0]; }
    size_t size() const { return SIZE; }
};




# 93 "../../src/FastLED.h" 2
# 1 "../../src/colorpalettes.h" 1
       
# 19 "../../src/colorpalettes.h"
extern const TProgmemRGBPalette16 CloudColors_p ;
extern const TProgmemRGBPalette16 LavaColors_p ;
extern const TProgmemRGBPalette16 OceanColors_p ;
extern const TProgmemRGBPalette16 ForestColors_p ;

extern const TProgmemRGBPalette16 RainbowColors_p ;



extern const TProgmemRGBPalette16 RainbowStripeColors_p ;

extern const TProgmemRGBPalette16 PartyColors_p ;

extern const TProgmemRGBPalette16 HeatColors_p ;


 extern const TProgmemRGBGradientPalette_byte Rainbow_gp[] ;
# 94 "../../src/FastLED.h" 2

# 1 "../../src/noise.h" 1
       
# 12 "../../src/noise.h"

# 31 "../../src/noise.h"
extern uint16_t inoise16(uint32_t x, uint32_t y, uint32_t z, uint32_t t);



extern uint16_t inoise16(uint32_t x, uint32_t y, uint32_t z);



extern uint16_t inoise16(uint32_t x, uint32_t y);





extern uint16_t inoise16(uint32_t x);
# 55 "../../src/noise.h"
extern int16_t inoise16_raw(uint32_t x, uint32_t y, uint32_t z);

extern int16_t inoise16_raw(uint32_t x, uint32_t y, uint32_t z, uint32_t w);



extern int16_t inoise16_raw(uint32_t x, uint32_t y);






extern int16_t inoise16_raw(uint32_t x);
# 78 "../../src/noise.h"
extern uint8_t inoise8(uint16_t x, uint16_t y, uint16_t z);



extern uint8_t inoise8(uint16_t x, uint16_t y);





extern uint8_t inoise8(uint16_t x);
# 98 "../../src/noise.h"
extern int8_t inoise8_raw(uint16_t x, uint16_t y, uint16_t z);



extern int8_t inoise8_raw(uint16_t x, uint16_t y);






extern int8_t inoise8_raw(uint16_t x);
# 120 "../../src/noise.h"
uint16_t snoise16(uint32_t x);
uint16_t snoise16(uint32_t x, uint32_t y);
uint16_t snoise16(uint32_t x, uint32_t y, uint32_t z);
uint16_t snoise16(uint32_t x, uint32_t y, uint32_t z, uint32_t w);
# 145 "../../src/noise.h"
void fill_raw_noise8(uint8_t *pData, uint8_t num_points, uint8_t octaves, uint16_t x, int scalex, uint16_t time);



void fill_raw_noise16into8(uint8_t *pData, uint8_t num_points, uint8_t octaves, uint32_t x, int scalex, uint32_t time);
# 164 "../../src/noise.h"
void fill_raw_2dnoise8(uint8_t *pData, int width, int height, uint8_t octaves, q44 freq44, fract8 amplitude, int skip, uint16_t x, int16_t scalex, uint16_t y, int16_t scaley, uint16_t time);
void fill_raw_2dnoise8(uint8_t *pData, int width, int height, uint8_t octaves, uint16_t x, int scalex, uint16_t y, int scaley, uint16_t time);
# 178 "../../src/noise.h"
void fill_raw_2dnoise8(uint8_t *pData, int width, int height, uint8_t octaves, uint16_t x, int16_t scalex, uint16_t y, int16_t scaley, uint16_t time);



void fill_raw_2dnoise16into8(uint8_t *pData, int width, int height, uint8_t octaves, uint32_t x, int32_t scalex, uint32_t y, int32_t scaley, uint32_t time);






void fill_raw_2dnoise16(uint16_t *pData, int width, int height, uint8_t octaves, q88 freq88, fract16 amplitude, int skip, uint32_t x, int32_t scalex, uint32_t y, int32_t scaley, uint32_t time);






void fill_raw_2dnoise16into8(uint8_t *pData, int width, int height, uint8_t octaves, q44 freq44, fract8 amplitude, int skip, uint32_t x, int32_t scalex, uint32_t y, int32_t scaley, uint32_t time);
# 217 "../../src/noise.h"
void fill_noise8(CRGB *leds, int num_leds,
            uint8_t octaves, uint16_t x, int scale,
            uint8_t hue_octaves, uint16_t hue_x, int hue_scale,
            uint16_t time);




void fill_noise16(CRGB *leds, int num_leds,
            uint8_t octaves, uint16_t x, int scale,
            uint8_t hue_octaves, uint16_t hue_x, int hue_scale,
            uint16_t time, uint8_t hue_shift=0);
# 251 "../../src/noise.h"
void fill_2dnoise8(CRGB *leds, int width, int height, bool serpentine,
            uint8_t octaves, uint16_t x, int xscale, uint16_t y, int yscale, uint16_t time,
            uint8_t hue_octaves, uint16_t hue_x, int hue_xscale, uint16_t hue_y, uint16_t hue_yscale,uint16_t hue_time,bool blend);




void fill_2dnoise16(CRGB *leds, int width, int height, bool serpentine,
            uint8_t octaves, uint32_t x, int xscale, uint32_t y, int yscale, uint32_t time,
            uint8_t hue_octaves, uint16_t hue_x, int hue_xscale, uint16_t hue_y, uint16_t hue_yscale,uint16_t hue_time, bool blend, uint16_t hue_shift=0);







# 96 "../../src/FastLED.h" 2
# 1 "../../src/power_mgt.h" 1
       
# 10 "../../src/power_mgt.h"

# 23 "../../src/power_mgt.h"
void set_max_power_in_volts_and_milliamps( uint8_t volts, uint32_t milliamps);



void set_max_power_in_milliwatts( uint32_t powerInmW);




void set_max_power_indicator_LED( uint8_t pinNumber);
# 50 "../../src/power_mgt.h"
void show_at_max_brightness_for_power();



void delay_at_max_brightness_for_power( uint16_t ms);
# 68 "../../src/power_mgt.h"
uint32_t calculate_unscaled_power_mW( const CRGB* ledbuffer, uint16_t numLeds);
# 78 "../../src/power_mgt.h"
uint8_t calculate_max_brightness_for_power_mW(const CRGB* ledbuffer, uint16_t numLeds, uint8_t target_brightness, uint32_t max_power_mW);
# 88 "../../src/power_mgt.h"
uint8_t calculate_max_brightness_for_power_vmA(const CRGB* ledbuffer, uint16_t numLeds, uint8_t target_brightness, uint32_t max_power_V, uint32_t max_power_mA);
# 99 "../../src/power_mgt.h"
uint8_t calculate_max_brightness_for_power_mW( uint8_t target_brightness, uint32_t max_power_mW);







# 97 "../../src/FastLED.h" 2

# 1 "../../src/fastspi.h" 1
       
# 14 "../../src/fastspi.h"
# 1 "../../src/fastspi_bitbang.h" 1
       
# 14 "../../src/fastspi_bitbang.h"

# 25 "../../src/fastspi_bitbang.h"
template <uint8_t DATA_PIN, uint8_t CLOCK_PIN, uint32_t SPI_SPEED>
class AVRSoftwareSPIOutput {


 typedef typename FastPin<DATA_PIN>::port_ptr_t data_ptr_t;
 typedef typename FastPin<CLOCK_PIN>::port_ptr_t clock_ptr_t;



 typedef typename FastPin<DATA_PIN>::port_t data_t;
 typedef typename FastPin<CLOCK_PIN>::port_t clock_t;
 Selectable *m_pSelect;

public:

 AVRSoftwareSPIOutput() { m_pSelect = 
# 40 "../../src/fastspi_bitbang.h" 3 4
                                     __null
# 40 "../../src/fastspi_bitbang.h"
                                         ; }

 AVRSoftwareSPIOutput(Selectable *pSelect) { m_pSelect = pSelect; }



 void setSelect(Selectable *pSelect) { m_pSelect = pSelect; }


 void init() {


  FastPin<DATA_PIN>::setOutput();
  FastPin<CLOCK_PIN>::setOutput();
  release();
 }



 static void stop() { }



 static void wait() __attribute__((always_inline)) { }

 static void waitFully() __attribute__((always_inline)) { wait(); }


 static void writeByteNoWait(uint8_t b) __attribute__((always_inline)) { writeByte(b); }

 static void writeBytePostWait(uint8_t b) __attribute__((always_inline)) { writeByte(b); wait(); }


 static void writeWord(uint16_t w) __attribute__((always_inline)) { writeByte(w>>8); writeByte(w&0xFF); }



 static void writeByte(uint8_t b) {
  writeBit<7>(b);
  writeBit<6>(b);
  writeBit<5>(b);
  writeBit<4>(b);
  writeBit<3>(b);
  writeBit<2>(b);
  writeBit<1>(b);
  writeBit<0>(b);
 }

private:

 static void writeByte(uint8_t b, clock_ptr_t clockpin, data_ptr_t datapin) {
  writeBit<7>(b, clockpin, datapin);
  writeBit<6>(b, clockpin, datapin);
  writeBit<5>(b, clockpin, datapin);
  writeBit<4>(b, clockpin, datapin);
  writeBit<3>(b, clockpin, datapin);
  writeBit<2>(b, clockpin, datapin);
  writeBit<1>(b, clockpin, datapin);
  writeBit<0>(b, clockpin, datapin);
 }




 static void writeByte(uint8_t b, data_ptr_t datapin,
        data_t hival, data_t loval,
        clock_t hiclock, clock_t loclock) {
  writeBit<7>(b, datapin, hival, loval, hiclock, loclock);
  writeBit<6>(b, datapin, hival, loval, hiclock, loclock);
  writeBit<5>(b, datapin, hival, loval, hiclock, loclock);
  writeBit<4>(b, datapin, hival, loval, hiclock, loclock);
  writeBit<3>(b, datapin, hival, loval, hiclock, loclock);
  writeBit<2>(b, datapin, hival, loval, hiclock, loclock);
  writeBit<1>(b, datapin, hival, loval, hiclock, loclock);
  writeBit<0>(b, datapin, hival, loval, hiclock, loclock);
 }





 static void writeByte(uint8_t b, clock_ptr_t clockpin, data_ptr_t datapin,
        data_t hival, data_t loval,
        clock_t hiclock, clock_t loclock) {
  writeBit<7>(b, clockpin, datapin, hival, loval, hiclock, loclock);
  writeBit<6>(b, clockpin, datapin, hival, loval, hiclock, loclock);
  writeBit<5>(b, clockpin, datapin, hival, loval, hiclock, loclock);
  writeBit<4>(b, clockpin, datapin, hival, loval, hiclock, loclock);
  writeBit<3>(b, clockpin, datapin, hival, loval, hiclock, loclock);
  writeBit<2>(b, clockpin, datapin, hival, loval, hiclock, loclock);
  writeBit<1>(b, clockpin, datapin, hival, loval, hiclock, loclock);
  writeBit<0>(b, clockpin, datapin, hival, loval, hiclock, loclock);
 }

public:
# 153 "../../src/fastspi_bitbang.h"
 template <uint8_t BIT> __attribute__((always_inline, hot)) inline static void writeBit(uint8_t b) {

  if(b & (1 << BIT)) {
   FastPin<DATA_PIN>::hi();






   FastPin<CLOCK_PIN>::hi(); do { delaycycles<(((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)>(); delaycycles<((SPI_SPEED > 10) ? (((SPI_SPEED-6) / 2) - (((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)) : (SPI_SPEED))>(); } while(0);;
   FastPin<CLOCK_PIN>::lo(); do { delaycycles<((SPI_SPEED > 10) ? ((SPI_SPEED-6) / 2) : (SPI_SPEED))>(); } while(0);;

  } else {
   FastPin<DATA_PIN>::lo();
   FastPin<CLOCK_PIN>::hi(); do { delaycycles<(((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)>(); delaycycles<((SPI_SPEED > 10) ? (((SPI_SPEED-6) / 2) - (((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)) : (SPI_SPEED))>(); } while(0);;




   FastPin<CLOCK_PIN>::lo(); do { delaycycles<((SPI_SPEED > 10) ? ((SPI_SPEED-6) / 2) : (SPI_SPEED))>(); } while(0);;

  }

 }

private:

 template <uint8_t BIT> __attribute__((always_inline)) inline static void writeBit(uint8_t b, clock_ptr_t clockpin, data_ptr_t datapin) {
  if(b & (1 << BIT)) {
   FastPin<DATA_PIN>::hi(datapin);
   FastPin<CLOCK_PIN>::hi(clockpin); do { delaycycles<(((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)>(); delaycycles<((SPI_SPEED > 10) ? (((SPI_SPEED-6) / 2) - (((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)) : (SPI_SPEED))>(); } while(0);;
   FastPin<CLOCK_PIN>::lo(clockpin); do { delaycycles<((SPI_SPEED > 10) ? ((SPI_SPEED-6) / 2) : (SPI_SPEED))>(); } while(0);;
  } else {
   FastPin<DATA_PIN>::lo(datapin);
   FastPin<CLOCK_PIN>::hi(clockpin); do { delaycycles<(((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)>(); delaycycles<((SPI_SPEED > 10) ? (((SPI_SPEED-6) / 2) - (((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)) : (SPI_SPEED))>(); } while(0);;
   FastPin<CLOCK_PIN>::lo(clockpin); do { delaycycles<((SPI_SPEED > 10) ? ((SPI_SPEED-6) / 2) : (SPI_SPEED))>(); } while(0);;
  }

 }



 template <uint8_t BIT> __attribute__((always_inline)) inline static void writeBit(uint8_t b, clock_ptr_t clockpin, data_ptr_t datapin,
             data_t hival, data_t loval, clock_t hiclock, clock_t loclock) {

  if(b & (1 << BIT)) {
   FastPin<DATA_PIN>::fastset(datapin, hival);
   FastPin<CLOCK_PIN>::fastset(clockpin, hiclock); do { delaycycles<(((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)>(); delaycycles<((SPI_SPEED > 10) ? (((SPI_SPEED-6) / 2) - (((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)) : (SPI_SPEED))>(); } while(0);;
   FastPin<CLOCK_PIN>::fastset(clockpin, loclock); do { delaycycles<((SPI_SPEED > 10) ? ((SPI_SPEED-6) / 2) : (SPI_SPEED))>(); } while(0);;
  } else {

   FastPin<DATA_PIN>::fastset(datapin, loval);
   FastPin<CLOCK_PIN>::fastset(clockpin, hiclock); do { delaycycles<(((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)>(); delaycycles<((SPI_SPEED > 10) ? (((SPI_SPEED-6) / 2) - (((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)) : (SPI_SPEED))>(); } while(0);;
   FastPin<CLOCK_PIN>::fastset(clockpin, loclock); do { delaycycles<((SPI_SPEED > 10) ? ((SPI_SPEED-6) / 2) : (SPI_SPEED))>(); } while(0);;
  }
 }



 template <uint8_t BIT> __attribute__((always_inline)) inline static void writeBit(uint8_t b, data_ptr_t clockdatapin,
             data_t datahiclockhi, data_t dataloclockhi,
             data_t datahiclocklo, data_t dataloclocklo) {



  if(b & (1 << BIT)) {
   FastPin<DATA_PIN>::fastset(clockdatapin, datahiclocklo);
   FastPin<DATA_PIN>::fastset(clockdatapin, datahiclockhi); do { delaycycles<(((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)>(); delaycycles<((SPI_SPEED > 10) ? (((SPI_SPEED-6) / 2) - (((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)) : (SPI_SPEED))>(); } while(0);;
   FastPin<DATA_PIN>::fastset(clockdatapin, datahiclocklo); do { delaycycles<((SPI_SPEED > 10) ? ((SPI_SPEED-6) / 2) : (SPI_SPEED))>(); } while(0);;
  } else {

   FastPin<DATA_PIN>::fastset(clockdatapin, dataloclocklo);
   FastPin<DATA_PIN>::fastset(clockdatapin, dataloclockhi); do { delaycycles<(((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)>(); delaycycles<((SPI_SPEED > 10) ? (((SPI_SPEED-6) / 2) - (((((35 * (1000000000 / 1000000L)) + 999) / 1000)>3) ? ((((35 * (1000000000 / 1000000L)) + 999) / 1000) - 3) : 1)) : (SPI_SPEED))>(); } while(0);;
   FastPin<DATA_PIN>::fastset(clockdatapin, dataloclocklo); do { delaycycles<((SPI_SPEED > 10) ? ((SPI_SPEED-6) / 2) : (SPI_SPEED))>(); } while(0);;
  }

 }

public:






 void select() { if(m_pSelect != 
# 239 "../../src/fastspi_bitbang.h" 3 4
                                __null
# 239 "../../src/fastspi_bitbang.h"
                                    ) { m_pSelect->select(); } }


 void release() { if(m_pSelect != 
# 242 "../../src/fastspi_bitbang.h" 3 4
                                 __null
# 242 "../../src/fastspi_bitbang.h"
                                     ) { m_pSelect->release(); } }





 void writeBytesValue(uint8_t value, int len) {
  select();
  writeBytesValueRaw(value, len);
  release();
 }



 static void writeBytesValueRaw(uint8_t value, int len) {
# 265 "../../src/fastspi_bitbang.h"
  data_ptr_t datapin = FastPin<DATA_PIN>::port();

  if(FastPin<DATA_PIN>::port() != FastPin<CLOCK_PIN>::port()) {


   clock_ptr_t clockpin = FastPin<CLOCK_PIN>::port();
   data_t datahi = FastPin<DATA_PIN>::hival();
   data_t datalo = FastPin<DATA_PIN>::loval();
   clock_t clockhi = FastPin<CLOCK_PIN>::hival();
   clock_t clocklo = FastPin<CLOCK_PIN>::loval();
   while(len--) {
    writeByte(value, clockpin, datapin, datahi, datalo, clockhi, clocklo);
   }

  } else {

   data_t datahi_clockhi = FastPin<DATA_PIN>::hival() | FastPin<CLOCK_PIN>::mask();
   data_t datalo_clockhi = FastPin<DATA_PIN>::loval() | FastPin<CLOCK_PIN>::mask();
   data_t datahi_clocklo = FastPin<DATA_PIN>::hival() & ~FastPin<CLOCK_PIN>::mask();
   data_t datalo_clocklo = FastPin<DATA_PIN>::loval() & ~FastPin<CLOCK_PIN>::mask();

   while(len--) {
    writeByte(value, datapin, datahi_clockhi, datalo_clockhi, datahi_clocklo, datalo_clocklo);
   }
  }

 }






 template <class D> void writeBytes( uint8_t *data, int len) {
  select();






  clock_ptr_t clockpin = FastPin<CLOCK_PIN>::port();
  data_ptr_t datapin = FastPin<DATA_PIN>::port();

  if(FastPin<DATA_PIN>::port() != FastPin<CLOCK_PIN>::port()) {


   data_t datahi = FastPin<DATA_PIN>::hival();
   data_t datalo = FastPin<DATA_PIN>::loval();
   clock_t clockhi = FastPin<CLOCK_PIN>::hival();
   clock_t clocklo = FastPin<CLOCK_PIN>::loval();
   uint8_t *end = data + len;

   while(data != end) {
    writeByte(D::adjust(*data++), clockpin, datapin, datahi, datalo, clockhi, clocklo);
   }

  } else {


   data_t datahi_clockhi = FastPin<DATA_PIN>::hival() | FastPin<CLOCK_PIN>::mask();
   data_t datalo_clockhi = FastPin<DATA_PIN>::loval() | FastPin<CLOCK_PIN>::mask();
   data_t datahi_clocklo = FastPin<DATA_PIN>::hival() & ~FastPin<CLOCK_PIN>::mask();
   data_t datalo_clocklo = FastPin<DATA_PIN>::loval() & ~FastPin<CLOCK_PIN>::mask();

   uint8_t *end = data + len;

   while(data != end) {
    writeByte(D::adjust(*data++), datapin, datahi_clockhi, datalo_clockhi, datahi_clocklo, datalo_clocklo);
   }

  }

  D::postBlock(len);
  release();
 }




 void writeBytes( uint8_t *data, int len) { writeBytes<DATA_NOP>(data, len); }
# 354 "../../src/fastspi_bitbang.h"
 template <uint8_t FLAGS, class D, EOrder RGB_ORDER> __attribute__((noinline)) void writePixels(PixelController<RGB_ORDER> pixels, void* context = 
# 354 "../../src/fastspi_bitbang.h" 3 4
                                                                                                                                                   __null
# 354 "../../src/fastspi_bitbang.h"
                                                                                                                                                       ) {
  (void)(context);
  select();
  int len = pixels.mLen;
# 375 "../../src/fastspi_bitbang.h"
  data_ptr_t datapin = FastPin<DATA_PIN>::port();

  if(FastPin<DATA_PIN>::port() != FastPin<CLOCK_PIN>::port()) {
   clock_ptr_t clockpin = FastPin<CLOCK_PIN>::port();


   data_t datahi = FastPin<DATA_PIN>::hival();
   data_t datalo = FastPin<DATA_PIN>::loval();
   clock_t clockhi = FastPin<CLOCK_PIN>::hival();
   clock_t clocklo = FastPin<CLOCK_PIN>::loval();

   while(pixels.has(1)) {
    if(FLAGS & 0x80) {
     writeBit<0>(1, clockpin, datapin, datahi, datalo, clockhi, clocklo);
    }
    writeByte(D::adjust(pixels.loadAndScale0()), clockpin, datapin, datahi, datalo, clockhi, clocklo);
    writeByte(D::adjust(pixels.loadAndScale1()), clockpin, datapin, datahi, datalo, clockhi, clocklo);
    writeByte(D::adjust(pixels.loadAndScale2()), clockpin, datapin, datahi, datalo, clockhi, clocklo);
    pixels.advanceData();
    pixels.stepDithering();
   }

  } else {

   data_t datahi_clockhi = FastPin<DATA_PIN>::hival() | FastPin<CLOCK_PIN>::mask();
   data_t datalo_clockhi = FastPin<DATA_PIN>::loval() | FastPin<CLOCK_PIN>::mask();
   data_t datahi_clocklo = FastPin<DATA_PIN>::hival() & ~FastPin<CLOCK_PIN>::mask();
   data_t datalo_clocklo = FastPin<DATA_PIN>::loval() & ~FastPin<CLOCK_PIN>::mask();

   while(pixels.has(1)) {
    if(FLAGS & 0x80) {
     writeBit<0>(1, datapin, datahi_clockhi, datalo_clockhi, datahi_clocklo, datalo_clocklo);
    }
    writeByte(D::adjust(pixels.loadAndScale0()), datapin, datahi_clockhi, datalo_clockhi, datahi_clocklo, datalo_clocklo);
    writeByte(D::adjust(pixels.loadAndScale1()), datapin, datahi_clockhi, datalo_clockhi, datahi_clocklo, datalo_clocklo);
    writeByte(D::adjust(pixels.loadAndScale2()), datapin, datahi_clockhi, datalo_clockhi, datahi_clocklo, datalo_clocklo);
    pixels.advanceData();
    pixels.stepDithering();
   }
  }

  D::postBlock(len);
  release();
 }
};


# 15 "../../src/fastspi.h" 2
# 39 "../../src/fastspi.h"





template<uint8_t _DATA_PIN, uint8_t _CLOCK_PIN, uint32_t _SPI_CLOCK_DIVIDER>
class SPIOutput : public StubSPIOutput {};
# 197 "../../src/fastspi.h"

# 99 "../../src/FastLED.h" 2
# 1 "../../src/chipsets.h" 1
       
# 108 "../../src/chipsets.h"


template <
 typename CONTROLLER,
 EOrder RGB_ORDER = GRB>
class RGBWEmulatedController
    : public CPixelLEDController<RGB_ORDER, CONTROLLER::LANES_VALUE,
                                 CONTROLLER::MASK_VALUE> {
  public:






 typedef CONTROLLER ControllerBaseT;
    class ControllerT : public CONTROLLER {
        friend class RGBWEmulatedController<CONTROLLER, RGB_ORDER>;
        void *callBeginShowLeds(int size) { return ControllerBaseT::beginShowLeds(size); }
        void callShow(CRGB *data, int nLeds, uint8_t brightness) {
            ControllerBaseT::show(data, nLeds, brightness);
        }
        void callEndShowLeds(void *data) { ControllerBaseT::endShowLeds(data); }
    };


    static const int LANES = CONTROLLER::LANES_VALUE;
    static const uint32_t MASK = CONTROLLER::MASK_VALUE;


    static_assert(RGB == CONTROLLER::RGB_ORDER_VALUE, "The delegated controller MUST NOT do reordering");

    RGBWEmulatedController(const Rgbw& rgbw = RgbwDefault()) {
        this->setRgbw(rgbw);
    };
    ~RGBWEmulatedController() { delete[] mRGBWPixels; }

 virtual void *beginShowLeds(int size) override {
  return mController.callBeginShowLeds(Rgbw::size_as_rgb(size));
 }

 virtual void endShowLeds(void *data) override {
  return mController.callEndShowLeds(data);
 }

    virtual void showPixels(PixelController<RGB_ORDER, LANES, MASK> &pixels) override {

        ensureBuffer(pixels.size());
  Rgbw rgbw = this->getRgbw();
        uint8_t *data = reinterpret_cast<uint8_t *>(mRGBWPixels);
        while (pixels.has(1)) {
            pixels.stepDithering();
            pixels.loadAndScaleRGBW(rgbw, data, data + 1, data + 2, data + 3);
            data += 4;
            pixels.advanceData();
        }
# 174 "../../src/chipsets.h"
  mController.setCorrection(CRGB(255, 255, 255));
  mController.setTemperature(CRGB(255, 255, 255));
  mController.setDither(0x00);

  mController.setEnabled(true);
  mController.callShow(mRGBWPixels, Rgbw::size_as_rgb(pixels.size()), 255);
  mController.setEnabled(false);
    }

  private:

    void init() override {
  mController.init();
  mController.setEnabled(false);
 }

    void ensureBuffer(int32_t num_leds) {
        if (num_leds != mNumRGBLeds) {
            mNumRGBLeds = num_leds;




            uint32_t new_size = Rgbw::size_as_rgb(num_leds);
            delete[] mRGBWPixels;
            mRGBWPixels = new CRGB[new_size];

   for (uint32_t i = 0; i < new_size; i++) {
    mRGBWPixels[i] = CRGB(0, 0, 0);
   }

   mController.setLeds(mRGBWPixels, new_size);
        }
    }

    CRGB *mRGBWPixels = nullptr;
    int32_t mNumRGBLeds = 0;
    int32_t mNumRGBWLeds = 0;
    ControllerT mController;
};
# 230 "../../src/chipsets.h"
template <uint8_t DATA_PIN, uint8_t CLOCK_PIN, EOrder RGB_ORDER = RGB, uint32_t SPI_SPEED = (1000000 * (12)) >
class LPD8806Controller : public CPixelLEDController<RGB_ORDER> {
 typedef SPIOutput<DATA_PIN, CLOCK_PIN, SPI_SPEED> SPI;

 class LPD8806_ADJUST {
 public:

  __attribute__((always_inline)) inline static uint8_t adjust( uint8_t data) { return ((data>>1) | 0x80) + ((data && (data<254)) & 0x01); }
  __attribute__((always_inline)) inline static void postBlock(int len, void* context = 
# 238 "../../src/chipsets.h" 3 4
                                                                     __null
# 238 "../../src/chipsets.h"
                                                                         ) {
   SPI* pSPI = static_cast<SPI*>(context);
   pSPI->writeBytesValueRaw(0, ((len*3+63)>>6));
  }

 };

 SPI mSPI;

public:
 LPD8806Controller() {}
 virtual void init() {
  mSPI.init();
 }

protected:


 virtual void showPixels(PixelController<RGB_ORDER> & pixels) {
  mSPI.template writePixels<0, LPD8806_ADJUST, RGB_ORDER>(pixels, &mSPI);
 }
};
# 273 "../../src/chipsets.h"
template <uint8_t DATA_PIN, uint8_t CLOCK_PIN, EOrder RGB_ORDER = RGB, uint32_t SPI_SPEED = (1000000 * (1))>
class WS2801Controller : public CPixelLEDController<RGB_ORDER> {
 typedef SPIOutput<DATA_PIN, CLOCK_PIN, SPI_SPEED> SPI;
 SPI mSPI;
 CMinWait<1000> mWaitDelay;

public:
 WS2801Controller() {}


 virtual void init() {
  mSPI.init();
   mWaitDelay.mark();
 }

protected:


 virtual void showPixels(PixelController<RGB_ORDER> & pixels) {
  mWaitDelay.wait();
  mSPI.template writePixels<0, DATA_NOP, RGB_ORDER>(pixels, 
# 293 "../../src/chipsets.h" 3 4
                                                           __null
# 293 "../../src/chipsets.h"
                                                               );
  mWaitDelay.mark();
 }
};



template <uint8_t DATA_PIN, uint8_t CLOCK_PIN, EOrder RGB_ORDER = RGB, uint32_t SPI_SPEED = (1000000 * (25))>
class WS2803Controller : public WS2801Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER, SPI_SPEED> {};
# 311 "../../src/chipsets.h"
template <uint8_t DATA_PIN, uint8_t CLOCK_PIN, EOrder RGB_ORDER = RGB, uint32_t SPI_SPEED = (1000000 * (12))>
class LPD6803Controller : public CPixelLEDController<RGB_ORDER> {
 typedef SPIOutput<DATA_PIN, CLOCK_PIN, SPI_SPEED> SPI;
 SPI mSPI;

 void startBoundary() { mSPI.writeByte(0); mSPI.writeByte(0); mSPI.writeByte(0); mSPI.writeByte(0); }
 void endBoundary(int nLeds) { int nDWords = (nLeds/32); do { mSPI.writeByte(0xFF); mSPI.writeByte(0x00); mSPI.writeByte(0x00); mSPI.writeByte(0x00); } while(nDWords--); }

public:
 LPD6803Controller() {}

 virtual void init() {
  mSPI.init();
 }

protected:

 virtual void showPixels(PixelController<RGB_ORDER> & pixels) {
  mSPI.select();

  startBoundary();
  while(pixels.has(1)) {
            uint16_t command;
            command = 0x8000;
            command |= (pixels.loadAndScale0() & 0xF8) << 7;
            command |= (pixels.loadAndScale1() & 0xF8) << 2;
   mSPI.writeByte((command >> 8) & 0xFF);
            command |= pixels.loadAndScale2() >> 3 ;
   mSPI.writeByte(command & 0xFF);

   pixels.stepDithering();
   pixels.advanceData();
  }
  endBoundary(pixels.size());
  mSPI.waitFully();
  mSPI.release();
 }

};
# 362 "../../src/chipsets.h"
template <
 uint8_t DATA_PIN, uint8_t CLOCK_PIN,
 EOrder RGB_ORDER = RGB,





 uint32_t SPI_SPEED = (1000000 * (6)),
 fl::FiveBitGammaCorrectionMode GAMMA_CORRECTION_MODE = fl::kFiveBitGammaCorrectionMode_Null,
 uint32_t START_FRAME = 0x00000000,
 uint32_t END_FRAME = 0xFF000000
>
class APA102Controller : public CPixelLEDController<RGB_ORDER> {
 typedef SPIOutput<DATA_PIN, CLOCK_PIN, SPI_SPEED> SPI;
 SPI mSPI;

 void startBoundary() {
  mSPI.writeWord(START_FRAME >> 16);
  mSPI.writeWord(START_FRAME & 0xFFFF);
 }
 void endBoundary(int nLeds) {
  int nDWords = (nLeds/32);
  const uint8_t b0 = uint8_t(END_FRAME >> 24 & 0x000000ff);
  const uint8_t b1 = uint8_t(END_FRAME >> 16 & 0x000000ff);
  const uint8_t b2 = uint8_t(END_FRAME >> 8 & 0x000000ff);
  const uint8_t b3 = uint8_t(END_FRAME >> 0 & 0x000000ff);
  do {
   mSPI.writeByte(b0);
   mSPI.writeByte(b1);
   mSPI.writeByte(b2);
   mSPI.writeByte(b3);
  } while(nDWords--);
 }

 __attribute__((always_inline)) inline void writeLed(uint8_t brightness, uint8_t b0, uint8_t b1, uint8_t b2) {






  uint16_t b = 0xE000 | (brightness << 8) | (uint16_t)b0;
  mSPI.writeWord(b);
  uint16_t w = b1 << 8;
  w |= b2;
  mSPI.writeWord(w);

 }

 __attribute__((always_inline)) inline void write2Bytes(uint8_t b1, uint8_t b2) {




  mSPI.writeWord(uint16_t(b1) << 8 | b2);

 }

public:
 APA102Controller() {}

 virtual void init() override {
  mSPI.init();
 }

protected:

 virtual void showPixels(PixelController<RGB_ORDER> & pixels) override {
  switch (GAMMA_CORRECTION_MODE) {
   case fl::kFiveBitGammaCorrectionMode_Null: {
    showPixelsDefault(pixels);
    break;
   }
   case fl::kFiveBitGammaCorrectionMode_BitShift: {
    showPixelsGammaBitShift(pixels);
    break;
   }
  }
 }

private:

 static inline void getGlobalBrightnessAndScalingFactors(
      PixelController<RGB_ORDER> & pixels,
      uint8_t* out_s0, uint8_t* out_s1, uint8_t* out_s2, uint8_t* out_brightness) {

  uint8_t brightness;
  pixels.getHdScale(out_s0, out_s1, out_s2, &brightness);
  struct Math {
   static uint16_t map(uint16_t x, uint16_t in_min, uint16_t in_max, uint16_t out_min, uint16_t out_max) {
    const uint16_t run = in_max - in_min;
    const uint16_t rise = out_max - out_min;
    const uint16_t delta = x - in_min;
    return (delta * rise) / run + out_min;
   }
  };

  uint16_t bri = Math::map(brightness, 0, 255, 0, 31);
  if (bri == 0 && brightness != 0) {

   bri = 1;
  }
  *out_brightness = static_cast<uint8_t>(bri);
  return;
# 485 "../../src/chipsets.h"
 }


 inline void showPixelsDefault(PixelController<RGB_ORDER> & pixels) {
  mSPI.select();
  uint8_t s0, s1, s2, global_brightness;
  getGlobalBrightnessAndScalingFactors(pixels, &s0, &s1, &s2, &global_brightness);
  startBoundary();
  while (pixels.has(1)) {
   uint8_t c0, c1, c2;
   pixels.loadAndScaleRGB(&c0, &c1, &c2);
   writeLed(global_brightness, c0, c1, c2);
   pixels.stepDithering();
   pixels.advanceData();
  }
  endBoundary(pixels.size());

  mSPI.waitFully();
  mSPI.release();
 }

 inline void showPixelsGammaBitShift(PixelController<RGB_ORDER> & pixels) {
  mSPI.select();
  startBoundary();
  while (pixels.has(1)) {

   uint8_t brightness, c0, c1, c2;
   pixels.loadAndScale_APA102_HD(&c0, &c1, &c2, &brightness);
   writeLed(brightness, c0, c1, c2);
   pixels.stepDithering();
   pixels.advanceData();
  }
  endBoundary(pixels.size());
  mSPI.waitFully();
  mSPI.release();
 }
};






template <
 uint8_t DATA_PIN,
 uint8_t CLOCK_PIN,
 EOrder RGB_ORDER = RGB,





 uint32_t SPI_SPEED = (1000000 * (6))
>
class APA102ControllerHD : public APA102Controller<
 DATA_PIN,
 CLOCK_PIN,
 RGB_ORDER,
 SPI_SPEED,
 fl::kFiveBitGammaCorrectionMode_BitShift,
 uint32_t(0x00000000),
 uint32_t(0x00000000)> {
public:
  APA102ControllerHD() = default;
  APA102ControllerHD(const APA102ControllerHD&) = delete;
};






template <
 uint8_t DATA_PIN,
 uint8_t CLOCK_PIN,
 EOrder RGB_ORDER = RGB,
 uint32_t SPI_SPEED = (1000000 * (12))
>
class SK9822Controller : public APA102Controller<
 DATA_PIN,
 CLOCK_PIN,
 RGB_ORDER,
 SPI_SPEED,
 fl::kFiveBitGammaCorrectionMode_Null,
 0x00000000,
 0x00000000
> {
};






template <
 uint8_t DATA_PIN,
 uint8_t CLOCK_PIN,
 EOrder RGB_ORDER = RGB,
 uint32_t SPI_SPEED = (1000000 * (12))
>
class SK9822ControllerHD : public APA102Controller<
 DATA_PIN,
 CLOCK_PIN,
 RGB_ORDER,
 SPI_SPEED,
 fl::kFiveBitGammaCorrectionMode_BitShift,
 0x00000000,
 0x00000000
> {
};



template <
 uint8_t DATA_PIN,
 uint8_t CLOCK_PIN,
 EOrder RGB_ORDER = RGB,
 uint32_t SPI_SPEED = (1000000 * (40))
>
class HD107Controller : public APA102Controller<
 DATA_PIN,
 CLOCK_PIN,
 RGB_ORDER,
 SPI_SPEED,
 fl::kFiveBitGammaCorrectionMode_Null,
 0x00000000,
 0x00000000
> {};


template <
 uint8_t DATA_PIN,
 uint8_t CLOCK_PIN,
 EOrder RGB_ORDER = RGB,
 uint32_t SPI_SPEED = (1000000 * (40))
 >
class HD107HDController : public APA102ControllerHD<
 DATA_PIN,
 CLOCK_PIN,
 RGB_ORDER,
 SPI_SPEED> {
};
# 640 "../../src/chipsets.h"
template <uint8_t DATA_PIN, uint8_t CLOCK_PIN, EOrder RGB_ORDER = RGB, uint32_t SPI_SPEED = (1000000 * (10))>
class P9813Controller : public CPixelLEDController<RGB_ORDER> {
 typedef SPIOutput<DATA_PIN, CLOCK_PIN, SPI_SPEED> SPI;
 SPI mSPI;

 void writeBoundary() { mSPI.writeWord(0); mSPI.writeWord(0); }

 __attribute__((always_inline)) inline void writeLed(uint8_t r, uint8_t g, uint8_t b) {
  uint8_t top = 0xC0 | ((~b & 0xC0) >> 2) | ((~g & 0xC0) >> 4) | ((~r & 0xC0) >> 6);
  mSPI.writeByte(top); mSPI.writeByte(b); mSPI.writeByte(g); mSPI.writeByte(r);
 }

public:
 P9813Controller() {}

 virtual void init() {
  mSPI.init();
 }

protected:

 virtual void showPixels(PixelController<RGB_ORDER> & pixels) {
  mSPI.select();

  writeBoundary();
  while(pixels.has(1)) {
   writeLed(pixels.loadAndScale0(), pixels.loadAndScale1(), pixels.loadAndScale2());
   pixels.advanceData();
   pixels.stepDithering();
  }
  writeBoundary();
  mSPI.waitFully();

  mSPI.release();
 }

};
# 690 "../../src/chipsets.h"
template <uint8_t DATA_PIN, uint8_t CLOCK_PIN, EOrder RGB_ORDER = RGB, uint32_t SPI_SPEED = (1000000 * (16))>
class SM16716Controller : public CPixelLEDController<RGB_ORDER> {
 typedef SPIOutput<DATA_PIN, CLOCK_PIN, SPI_SPEED> SPI;
 SPI mSPI;

 void writeHeader() {

  mSPI.select();
  mSPI.template writeBit<0>(0);
  mSPI.writeByte(0);
  mSPI.writeByte(0);
  mSPI.writeByte(0);
  mSPI.template writeBit<0>(0);
  mSPI.writeByte(0);
  mSPI.writeByte(0);
  mSPI.writeByte(0);
  mSPI.waitFully();
  mSPI.release();
 }

public:
 SM16716Controller() {}

 virtual void init() {
  mSPI.init();
 }

protected:

 virtual void showPixels(PixelController<RGB_ORDER> & pixels) {



  mSPI.template writePixels<0x80, DATA_NOP, RGB_ORDER>(pixels, 
# 723 "../../src/chipsets.h" 3 4
                                                                        __null
# 723 "../../src/chipsets.h"
                                                                            );
  writeHeader();
 }

};
# 998 "../../src/chipsets.h"
template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class GE8822Controller800Khz : public ClocklessController<DATA_PIN, (((350 * ((1000000000 / 1000000L)) + 999)) / 1000), (((660 * ((1000000000 / 1000000L)) + 999)) / 1000), (((350 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER, 4> {};


template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class GW6205Controller400Khz : public ClocklessController<DATA_PIN, (((800 * ((1000000000 / 1000000L)) + 999)) / 1000), (((800 * ((1000000000 / 1000000L)) + 999)) / 1000), (((800 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER, 4> {};


template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class GW6205Controller800Khz : public ClocklessController<DATA_PIN, (((400 * ((1000000000 / 1000000L)) + 999)) / 1000), (((400 * ((1000000000 / 1000000L)) + 999)) / 1000), (((400 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER, 4> {};


template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class UCS1903Controller400Khz : public ClocklessController<DATA_PIN, (((500 * ((1000000000 / 1000000L)) + 999)) / 1000), (((1500 * ((1000000000 / 1000000L)) + 999)) / 1000), (((500 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER> {};


template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class UCS1903BController800Khz : public ClocklessController<DATA_PIN, (((400 * ((1000000000 / 1000000L)) + 999)) / 1000), (((450 * ((1000000000 / 1000000L)) + 999)) / 1000), (((450 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER> {};


template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class UCS1904Controller800Khz : public ClocklessController<DATA_PIN, (((400 * ((1000000000 / 1000000L)) + 999)) / 1000), (((400 * ((1000000000 / 1000000L)) + 999)) / 1000), (((450 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER> {};


template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class UCS2903Controller : public ClocklessController<DATA_PIN, (((250 * ((1000000000 / 1000000L)) + 999)) / 1000), (((750 * ((1000000000 / 1000000L)) + 999)) / 1000), (((250 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER> {};


template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class TM1809Controller800Khz : public ClocklessController<DATA_PIN, (((350 * ((1000000000 / 1000000L)) + 999)) / 1000), (((350 * ((1000000000 / 1000000L)) + 999)) / 1000), (((450 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER> {};


template <uint8_t DATA_PIN, EOrder RGB_ORDER = GRB>
class WS2811Controller800Khz : public ClocklessController<DATA_PIN, ((((int(320 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), ((((int(320 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), ((((int(640 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), RGB_ORDER> {};


template <uint8_t DATA_PIN, EOrder RGB_ORDER = GRB>
class WS2813Controller : public ClocklessController<DATA_PIN, ((((int(320 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), ((((int(320 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), ((((int(640 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), RGB_ORDER> {};
# 1073 "../../src/chipsets.h"
template <uint8_t DATA_PIN, EOrder RGB_ORDER = GRB>
class WS2812Controller800Khz : public ClocklessController<
 DATA_PIN,
 ((((int(250 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)),
 ((((int(625 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)),
 ((((int(375 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)),
 RGB_ORDER> {};




template <uint8_t DATA_PIN, EOrder RGB_ORDER = GRB>
class WS2811Controller400Khz : public ClocklessController<DATA_PIN, ((((int(800 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), ((((int(800 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), ((((int(900 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), RGB_ORDER> {};

template <uint8_t DATA_PIN, EOrder RGB_ORDER = GRB>
class WS2815Controller : public ClocklessController<DATA_PIN, ((((int(250 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), ((((int(1090 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), ((((int(550 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), RGB_ORDER> {};


template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class TM1803Controller400Khz : public ClocklessController<DATA_PIN, (((700 * ((1000000000 / 1000000L)) + 999)) / 1000), (((1100 * ((1000000000 / 1000000L)) + 999)) / 1000), (((700 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER> {};

template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class TM1829Controller800Khz : public ClocklessController<DATA_PIN, (((340 * ((1000000000 / 1000000L)) + 999)) / 1000), (((340 * ((1000000000 / 1000000L)) + 999)) / 1000), (((550 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER, 0, true, 500> {};

template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class TM1829Controller1600Khz : public ClocklessController<DATA_PIN, (((100 * ((1000000000 / 1000000L)) + 999)) / 1000), (((300 * ((1000000000 / 1000000L)) + 999)) / 1000), (((200 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER, 0, true, 500> {};

template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class LPD1886Controller1250Khz : public ClocklessController<DATA_PIN, (((200 * ((1000000000 / 1000000L)) + 999)) / 1000), (((400 * ((1000000000 / 1000000L)) + 999)) / 1000), (((200 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER, 4> {};

template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class LPD1886Controller1250Khz_8bit : public ClocklessController<DATA_PIN, (((200 * ((1000000000 / 1000000L)) + 999)) / 1000), (((400 * ((1000000000 / 1000000L)) + 999)) / 1000), (((200 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER> {};


template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class SK6822Controller : public ClocklessController<DATA_PIN, ((((int(375 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), ((((int(1000 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), ((((int(375 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), RGB_ORDER> {};

template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class SK6812Controller : public ClocklessController<DATA_PIN, ((((int(300 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), ((((int(300 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), ((((int(600 / 1.0) * ((1000000000 / 1000000L)) + 999)) / 1000)), RGB_ORDER> {};

template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class SM16703Controller : public ClocklessController<DATA_PIN, (((300 * ((1000000000 / 1000000L)) + 999)) / 1000), (((600 * ((1000000000 / 1000000L)) + 999)) / 1000), (((300 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER> {};

template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class PL9823Controller : public ClocklessController<DATA_PIN, (((350 * ((1000000000 / 1000000L)) + 999)) / 1000), (((1010 * ((1000000000 / 1000000L)) + 999)) / 1000), (((350 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER> {};


template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class UCS1912Controller : public ClocklessController<DATA_PIN, (((250 * ((1000000000 / 1000000L)) + 999)) / 1000), (((1000 * ((1000000000 / 1000000L)) + 999)) / 1000), (((350 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER> {};
# 1131 "../../src/chipsets.h"
template <uint8_t DATA_PIN, EOrder RGB_ORDER = RGB>
class SM16824EController : public ClocklessController<DATA_PIN, (((300 * ((1000000000 / 1000000L)) + 999)) / 1000), (((900 * ((1000000000 / 1000000L)) + 999)) / 1000), (((100 * ((1000000000 / 1000000L)) + 999)) / 1000), RGB_ORDER, 0, false, 200> {};







template <uint8_t DATA_PIN, EOrder RGB_ORDER = GRB>
class WS2816Controller
    : public CPixelLEDController<RGB_ORDER,
                                 WS2812Controller800Khz<DATA_PIN, RGB>::LANES_VALUE,
                                 WS2812Controller800Khz<DATA_PIN, RGB>::MASK_VALUE> {

public:







 typedef WS2812Controller800Khz<DATA_PIN, RGB> ControllerBaseT;
 class ControllerT : public ControllerBaseT {
  friend class WS2816Controller<DATA_PIN, RGB_ORDER>;
  void *callBeginShowLeds(int size) { return ControllerBaseT::beginShowLeds(size); }
  void callShow(CRGB *data, int nLeds, uint8_t brightness) {
   ControllerBaseT::show(data, nLeds, brightness);
  }
  void callEndShowLeds(void *data) { ControllerBaseT::endShowLeds(data); }
 };

    static const int LANES = ControllerT::LANES_VALUE;
    static const uint32_t MASK = ControllerT::MASK_VALUE;

    WS2816Controller() {}
    ~WS2816Controller() {
        mController.setLeds(nullptr, 0);
        delete [] mData;
    }

    virtual void *beginShowLeds(int size) override {
        mController.setEnabled(true);
  void *result = mController.callBeginShowLeds(2 * size);
        mController.setEnabled(false);
        return result;
    }

    virtual void endShowLeds(void *data) override {
        mController.setEnabled(true);
  mController.callEndShowLeds(data);
        mController.setEnabled(false);
    }

    virtual void showPixels(PixelController<RGB_ORDER, LANES, MASK> &pixels) override {

        ensureBuffer(pixels.size());


  size_t out_index = 0;
        while (pixels.has(1)) {
            pixels.stepDithering();

   uint16_t s0, s1, s2;
            pixels.loadAndScale_WS2816_HD(&s0, &s1, &s2);
   uint8_t b0_hi = s0 >> 8;
   uint8_t b0_lo = s0 & 0xFF;
   uint8_t b1_hi = s1 >> 8;
   uint8_t b1_lo = s1 & 0xFF;
   uint8_t b2_hi = s2 >> 8;
   uint8_t b2_lo = s2 & 0xFF;

   mData[out_index] = CRGB(b0_hi, b0_lo, b1_hi);
   mData[out_index + 1] = CRGB(b1_lo, b2_hi, b2_lo);

            pixels.advanceData();
   out_index += 2;
        }


        mController.setCorrection(CRGB(255, 255, 255));
        mController.setTemperature(CRGB(255, 255, 255));
        mController.setDither(0x00);


        mController.setEnabled(true);



        mController.show(mData, 2 * pixels.size(), 255);

        mController.setEnabled(false);
    }

private:
    void init() override {
        mController.init();
        mController.setEnabled(false);
    }

    void ensureBuffer(int size_8bit) {
        int size_16bit = 2 * size_8bit;
        if (mController.size() != size_16bit) {
            delete [] mData;
            CRGB *new_leds = new CRGB[size_16bit];
   mData = new_leds;
            mController.setLeds(new_leds, size_16bit);
        }
    }

    CRGB *mData = 0;
    ControllerT mController;
};






# 100 "../../src/FastLED.h" 2


# 1 "../../src/fl/leds.h" 1
       




namespace fl {




class Leds {
  public:
    Leds(CRGB *leds, uint16_t width, uint16_t height);
    Leds(CRGB *leds, const XYMap &xymap);


    Leds(const Leds &) = default;
    Leds &operator=(const Leds &) = default;
    Leds(Leds &&) = default;


    CRGB &operator()(int x, int y);
    const CRGB &operator()(int x, int y) const;

    CRGB &at(int x, int y) { return (*this)(x, y); }
    const CRGB &at(int x, int y) const { return (*this)(x, y); }

    size_t width() const { return mXyMap.getHeight(); }
    size_t height() const { return mXyMap.getWidth(); }



    CRGB *operator[](int x);
    const CRGB *operator[](int x) const;

    CRGB *rgb() { return mLeds; }
    const CRGB *rgb() const { return mLeds; }

    const XYMap &xymap() const { return mXyMap; }

    operator CRGB *() { return mLeds; }
    operator const CRGB *() const { return mLeds; }

    void fill(const CRGB &color) {
        for (size_t i = 0; i < mXyMap.getTotal(); ++i) {
            mLeds[i] = color;
        }
    }



  protected:
    static CRGB &empty();
    XYMap mXyMap;
    CRGB *mLeds;
};

template <size_t W, size_t H> class LedsXY : public Leds {
  public:
    LedsXY() : Leds(mLedsData, XYMap::constructSerpentine(W, H)) {}
    explicit LedsXY(bool is_serpentine)
        : Leds(mLedsData, is_serpentine ? XYMap::constructSerpentine(W, H)
                                        : XYMap::constructRectangularGrid(W, H)) {}
    LedsXY(const LedsXY &) = default;
    LedsXY &operator=(const LedsXY &) = default;
    void setXyMap(const XYMap &xymap) { mXyMap = xymap; }
    void setSerpentine(bool is_serpentine) {
        mXyMap = is_serpentine ? XYMap::constructSerpentine(W, H)
                               : XYMap::constructRectangularGrid(W, H);
    }

  private:
    CRGB mLedsData[W * H] = {};
};

}
# 103 "../../src/FastLED.h" 2





uint16_t cled_contoller_size();


enum ESPIChipsets {
 LPD6803,
 LPD8806,
 WS2801,
 WS2803,
 SM16716,
 P9813,
 APA102,
 SK9822,
 SK9822HD,
 DOTSTAR,
 DOTSTARHD,
 APA102HD,
 HD107,
 HD107HD,

};



enum ESM { SMART_MATRIX };




enum OWS2811 { OCTOWS2811,OCTOWS2811_400, OCTOWS2813};




enum SWS2812 { WS2812SERIAL };
# 155 "../../src/FastLED.h"
template<uint8_t DATA_PIN> class NEOPIXEL : public WS2812Controller800Khz<DATA_PIN, GRB> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class SM16703 : public SM16703Controller<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class SM16824E : public SM16824EController<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class TM1829 : public TM1829Controller800Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class TM1812 : public TM1809Controller800Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class TM1809 : public TM1809Controller800Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class TM1804 : public TM1809Controller800Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class TM1803 : public TM1803Controller400Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class UCS1903 : public UCS1903Controller400Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class UCS1903B : public UCS1903BController800Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class UCS1904 : public UCS1904Controller800Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class UCS2903 : public UCS2903Controller<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class WS2812 : public WS2812Controller800Khz<DATA_PIN, RGB_ORDER> {};


template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class WS2815 : public WS2815Controller<DATA_PIN, RGB_ORDER> {};


template <uint8_t DATA_PIN, EOrder RGB_ORDER>
class WS2816 : public WS2816Controller<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class WS2852 : public WS2812Controller800Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class WS2812B : public WS2812Controller800Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class GS1903 : public WS2812Controller800Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class SK6812 : public SK6812Controller<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class SK6822 : public SK6822Controller<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class APA106 : public SK6822Controller<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class PL9823 : public PL9823Controller<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class WS2811 : public WS2811Controller800Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class WS2813 : public WS2813Controller<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class APA104 : public WS2811Controller800Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class WS2811_400 : public WS2811Controller400Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class GE8822 : public GE8822Controller800Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class GW6205 : public GW6205Controller800Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class GW6205_400 : public GW6205Controller400Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class LPD1886 : public LPD1886Controller1250Khz<DATA_PIN, RGB_ORDER> {};



template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class LPD1886_8BIT : public LPD1886Controller1250Khz_8bit<DATA_PIN, RGB_ORDER> {};


template<uint8_t DATA_PIN, EOrder RGB_ORDER>
class UCS1912 : public UCS1912Controller<DATA_PIN, RGB_ORDER> {};
# 323 "../../src/FastLED.h"
enum EBlockChipsets {
# 359 "../../src/FastLED.h"
};







typedef uint8_t (*power_func)(uint8_t scale, uint32_t data);







class CFastLED {

 uint8_t m_Scale;
 uint16_t m_nFPS;
 uint32_t m_nMinMicros;
 uint32_t m_nPowerData;
 power_func m_pPowerFunc;

public:
 CFastLED();



 void addListener(fl::EngineEvents::Listener *listener) { fl::EngineEvents::addListener(listener); }
 void removeListener(fl::EngineEvents::Listener *listener) { fl::EngineEvents::removeListener(listener); }
# 402 "../../src/FastLED.h"
 static CLEDController &addLeds(CLEDController *pLed, struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0);
# 426 "../../src/FastLED.h"
 template<ESPIChipsets CHIPSET, uint8_t DATA_PIN, uint8_t CLOCK_PIN>
 struct ClockedChipsetHelper {

  static const bool IS_VALID = false;
 };
# 452 "../../src/FastLED.h"
 template<uint8_t DATA_PIN, uint8_t CLOCK_PIN> struct ClockedChipsetHelper<LPD6803, DATA_PIN, CLOCK_PIN> { static const bool IS_VALID = true; typedef LPD6803Controller<DATA_PIN, CLOCK_PIN> ControllerType; template<EOrder RGB_ORDER> struct CONTROLLER_CLASS_WITH_ORDER { typedef LPD6803Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER> ControllerType; }; template<EOrder RGB_ORDER, uint32_t FREQ> struct CONTROLLER_CLASS_WITH_ORDER_AND_FREQ { typedef LPD6803Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER, FREQ> ControllerType; }; };
 template<uint8_t DATA_PIN, uint8_t CLOCK_PIN> struct ClockedChipsetHelper<LPD8806, DATA_PIN, CLOCK_PIN> { static const bool IS_VALID = true; typedef LPD8806Controller<DATA_PIN, CLOCK_PIN> ControllerType; template<EOrder RGB_ORDER> struct CONTROLLER_CLASS_WITH_ORDER { typedef LPD8806Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER> ControllerType; }; template<EOrder RGB_ORDER, uint32_t FREQ> struct CONTROLLER_CLASS_WITH_ORDER_AND_FREQ { typedef LPD8806Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER, FREQ> ControllerType; }; };
 template<uint8_t DATA_PIN, uint8_t CLOCK_PIN> struct ClockedChipsetHelper<WS2801, DATA_PIN, CLOCK_PIN> { static const bool IS_VALID = true; typedef WS2801Controller<DATA_PIN, CLOCK_PIN> ControllerType; template<EOrder RGB_ORDER> struct CONTROLLER_CLASS_WITH_ORDER { typedef WS2801Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER> ControllerType; }; template<EOrder RGB_ORDER, uint32_t FREQ> struct CONTROLLER_CLASS_WITH_ORDER_AND_FREQ { typedef WS2801Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER, FREQ> ControllerType; }; };
 template<uint8_t DATA_PIN, uint8_t CLOCK_PIN> struct ClockedChipsetHelper<WS2803, DATA_PIN, CLOCK_PIN> { static const bool IS_VALID = true; typedef WS2803Controller<DATA_PIN, CLOCK_PIN> ControllerType; template<EOrder RGB_ORDER> struct CONTROLLER_CLASS_WITH_ORDER { typedef WS2803Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER> ControllerType; }; template<EOrder RGB_ORDER, uint32_t FREQ> struct CONTROLLER_CLASS_WITH_ORDER_AND_FREQ { typedef WS2803Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER, FREQ> ControllerType; }; };
 template<uint8_t DATA_PIN, uint8_t CLOCK_PIN> struct ClockedChipsetHelper<SM16716, DATA_PIN, CLOCK_PIN> { static const bool IS_VALID = true; typedef SM16716Controller<DATA_PIN, CLOCK_PIN> ControllerType; template<EOrder RGB_ORDER> struct CONTROLLER_CLASS_WITH_ORDER { typedef SM16716Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER> ControllerType; }; template<EOrder RGB_ORDER, uint32_t FREQ> struct CONTROLLER_CLASS_WITH_ORDER_AND_FREQ { typedef SM16716Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER, FREQ> ControllerType; }; };
 template<uint8_t DATA_PIN, uint8_t CLOCK_PIN> struct ClockedChipsetHelper<P9813, DATA_PIN, CLOCK_PIN> { static const bool IS_VALID = true; typedef P9813Controller<DATA_PIN, CLOCK_PIN> ControllerType; template<EOrder RGB_ORDER> struct CONTROLLER_CLASS_WITH_ORDER { typedef P9813Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER> ControllerType; }; template<EOrder RGB_ORDER, uint32_t FREQ> struct CONTROLLER_CLASS_WITH_ORDER_AND_FREQ { typedef P9813Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER, FREQ> ControllerType; }; };


 template<uint8_t DATA_PIN, uint8_t CLOCK_PIN> struct ClockedChipsetHelper<DOTSTAR, DATA_PIN, CLOCK_PIN> { static const bool IS_VALID = true; typedef APA102Controller<DATA_PIN, CLOCK_PIN> ControllerType; template<EOrder RGB_ORDER> struct CONTROLLER_CLASS_WITH_ORDER { typedef APA102Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER> ControllerType; }; template<EOrder RGB_ORDER, uint32_t FREQ> struct CONTROLLER_CLASS_WITH_ORDER_AND_FREQ { typedef APA102Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER, FREQ> ControllerType; }; };
 template<uint8_t DATA_PIN, uint8_t CLOCK_PIN> struct ClockedChipsetHelper<APA102, DATA_PIN, CLOCK_PIN> { static const bool IS_VALID = true; typedef APA102Controller<DATA_PIN, CLOCK_PIN> ControllerType; template<EOrder RGB_ORDER> struct CONTROLLER_CLASS_WITH_ORDER { typedef APA102Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER> ControllerType; }; template<EOrder RGB_ORDER, uint32_t FREQ> struct CONTROLLER_CLASS_WITH_ORDER_AND_FREQ { typedef APA102Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER, FREQ> ControllerType; }; };


 template<uint8_t DATA_PIN, uint8_t CLOCK_PIN> struct ClockedChipsetHelper<DOTSTARHD, DATA_PIN, CLOCK_PIN> { static const bool IS_VALID = true; typedef APA102ControllerHD<DATA_PIN, CLOCK_PIN> ControllerType; template<EOrder RGB_ORDER> struct CONTROLLER_CLASS_WITH_ORDER { typedef APA102ControllerHD<DATA_PIN, CLOCK_PIN, RGB_ORDER> ControllerType; }; template<EOrder RGB_ORDER, uint32_t FREQ> struct CONTROLLER_CLASS_WITH_ORDER_AND_FREQ { typedef APA102ControllerHD<DATA_PIN, CLOCK_PIN, RGB_ORDER, FREQ> ControllerType; }; };
 template<uint8_t DATA_PIN, uint8_t CLOCK_PIN> struct ClockedChipsetHelper<APA102HD, DATA_PIN, CLOCK_PIN> { static const bool IS_VALID = true; typedef APA102ControllerHD<DATA_PIN, CLOCK_PIN> ControllerType; template<EOrder RGB_ORDER> struct CONTROLLER_CLASS_WITH_ORDER { typedef APA102ControllerHD<DATA_PIN, CLOCK_PIN, RGB_ORDER> ControllerType; }; template<EOrder RGB_ORDER, uint32_t FREQ> struct CONTROLLER_CLASS_WITH_ORDER_AND_FREQ { typedef APA102ControllerHD<DATA_PIN, CLOCK_PIN, RGB_ORDER, FREQ> ControllerType; }; };

 template<uint8_t DATA_PIN, uint8_t CLOCK_PIN> struct ClockedChipsetHelper<HD107, DATA_PIN, CLOCK_PIN> { static const bool IS_VALID = true; typedef APA102Controller<DATA_PIN, CLOCK_PIN> ControllerType; template<EOrder RGB_ORDER> struct CONTROLLER_CLASS_WITH_ORDER { typedef APA102Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER> ControllerType; }; template<EOrder RGB_ORDER, uint32_t FREQ> struct CONTROLLER_CLASS_WITH_ORDER_AND_FREQ { typedef APA102Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER, FREQ> ControllerType; }; };
 template<uint8_t DATA_PIN, uint8_t CLOCK_PIN> struct ClockedChipsetHelper<HD107HD, DATA_PIN, CLOCK_PIN> { static const bool IS_VALID = true; typedef APA102ControllerHD<DATA_PIN, CLOCK_PIN> ControllerType; template<EOrder RGB_ORDER> struct CONTROLLER_CLASS_WITH_ORDER { typedef APA102ControllerHD<DATA_PIN, CLOCK_PIN, RGB_ORDER> ControllerType; }; template<EOrder RGB_ORDER, uint32_t FREQ> struct CONTROLLER_CLASS_WITH_ORDER_AND_FREQ { typedef APA102ControllerHD<DATA_PIN, CLOCK_PIN, RGB_ORDER, FREQ> ControllerType; }; };

 template<uint8_t DATA_PIN, uint8_t CLOCK_PIN> struct ClockedChipsetHelper<SK9822, DATA_PIN, CLOCK_PIN> { static const bool IS_VALID = true; typedef SK9822Controller<DATA_PIN, CLOCK_PIN> ControllerType; template<EOrder RGB_ORDER> struct CONTROLLER_CLASS_WITH_ORDER { typedef SK9822Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER> ControllerType; }; template<EOrder RGB_ORDER, uint32_t FREQ> struct CONTROLLER_CLASS_WITH_ORDER_AND_FREQ { typedef SK9822Controller<DATA_PIN, CLOCK_PIN, RGB_ORDER, FREQ> ControllerType; }; };
 template<uint8_t DATA_PIN, uint8_t CLOCK_PIN> struct ClockedChipsetHelper<SK9822HD, DATA_PIN, CLOCK_PIN> { static const bool IS_VALID = true; typedef SK9822ControllerHD<DATA_PIN, CLOCK_PIN> ControllerType; template<EOrder RGB_ORDER> struct CONTROLLER_CLASS_WITH_ORDER { typedef SK9822ControllerHD<DATA_PIN, CLOCK_PIN, RGB_ORDER> ControllerType; }; template<EOrder RGB_ORDER, uint32_t FREQ> struct CONTROLLER_CLASS_WITH_ORDER_AND_FREQ { typedef SK9822ControllerHD<DATA_PIN, CLOCK_PIN, RGB_ORDER, FREQ> ControllerType; }; };
# 502 "../../src/FastLED.h"
 template<ESPIChipsets CHIPSET, uint8_t DATA_PIN, uint8_t CLOCK_PIN, EOrder RGB_ORDER, uint32_t SPI_DATA_RATE > CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {

  typedef ClockedChipsetHelper<CHIPSET, DATA_PIN, CLOCK_PIN> CHIP;
  typedef typename CHIP::template CONTROLLER_CLASS_WITH_ORDER_AND_FREQ<RGB_ORDER, SPI_DATA_RATE>::ControllerType ControllerTypeWithFreq;
  static_assert(CHIP::IS_VALID, "Unsupported chipset");
  static ControllerTypeWithFreq c;
  return addLeds(&c, data, nLedsOrOffset, nLedsIfOffset);
 }


 template<ESPIChipsets CHIPSET, uint8_t DATA_PIN, uint8_t CLOCK_PIN > static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
  typedef ClockedChipsetHelper<CHIPSET, DATA_PIN, CLOCK_PIN> CHIP;
  typedef typename CHIP::ControllerType ControllerType;
  static_assert(CHIP::IS_VALID, "Unsupported chipset");
  static ControllerType c;
  return addLeds(&c, data, nLedsOrOffset, nLedsIfOffset);
 }



 template<ESPIChipsets CHIPSET, uint8_t DATA_PIN, uint8_t CLOCK_PIN, EOrder RGB_ORDER>
 CLEDController& addLeds(struct CRGB* data, int nLedsOrOffset, int nLedsIfOffset = 0) {
  typedef ClockedChipsetHelper<CHIPSET, DATA_PIN, CLOCK_PIN> CHIP;
  static_assert(CHIP::IS_VALID, "Unsupported chipset");
  typedef typename CHIP::template CONTROLLER_CLASS_WITH_ORDER<RGB_ORDER>::ControllerType ControllerTypeWithOrder;
  static ControllerTypeWithOrder c;
  return addLeds(&c, data, nLedsOrOffset, nLedsIfOffset);
 }
# 572 "../../src/FastLED.h"
 template<template<uint8_t DATA_PIN, EOrder RGB_ORDER> class CHIPSET, uint8_t DATA_PIN, EOrder RGB_ORDER>
 static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
  static CHIPSET<DATA_PIN, RGB_ORDER> c;
  return addLeds(&c, data, nLedsOrOffset, nLedsIfOffset);
 }


 template<template<uint8_t DATA_PIN, EOrder RGB_ORDER> class CHIPSET, uint8_t DATA_PIN>
 static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
  static CHIPSET<DATA_PIN, RGB> c;
  return addLeds(&c, data, nLedsOrOffset, nLedsIfOffset);
 }


 template<template<uint8_t DATA_PIN> class CHIPSET, uint8_t DATA_PIN>
 static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
  static CHIPSET<DATA_PIN> c;
  return addLeds(&c, data, nLedsOrOffset, nLedsIfOffset);
 }

 template<template<uint8_t DATA_PIN> class CHIPSET, uint8_t DATA_PIN>
 static CLEDController &addLeds(class fl::Leds& leds, int nLedsOrOffset, int nLedsIfOffset = 0) {
  CRGB* rgb = leds;
  return addLeds<CHIPSET, DATA_PIN>(rgb, nLedsOrOffset, nLedsIfOffset);
 }
# 640 "../../src/FastLED.h"
 template<template<EOrder RGB_ORDER> class CHIPSET, EOrder RGB_ORDER>
 static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
  static CHIPSET<RGB_ORDER> c;
  return addLeds(&c, data, nLedsOrOffset, nLedsIfOffset);
 }


 template<template<EOrder RGB_ORDER> class CHIPSET>
 static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
  static CHIPSET<RGB> c;
  return addLeds(&c, data, nLedsOrOffset, nLedsIfOffset);
 }
# 781 "../../src/FastLED.h"
 void setBrightness(uint8_t scale) { m_Scale = scale; }



 uint8_t getBrightness() { return m_Scale; }




 inline void setMaxPowerInVoltsAndMilliamps(uint8_t volts, uint32_t milliamps) { setMaxPowerInMilliWatts(volts * milliamps); }



 inline void setMaxPowerInMilliWatts(uint32_t milliwatts) { m_pPowerFunc = &calculate_max_brightness_for_power_mW; m_nPowerData = milliwatts; }



 void show(uint8_t scale);


 void show() { show(m_Scale); }


 void onEndFrame();




 void clear(bool writeData = false);


 void clearData();




 void showColor(const struct CRGB & color, uint8_t scale);



 void showColor(const struct CRGB & color) { showColor(color, m_Scale); }





 void delay(unsigned long ms);




 void setTemperature(const struct CRGB & temp);




 void setCorrection(const struct CRGB & correction);




 void setDither(uint8_t ditherMode = 0x01);
# 851 "../../src/FastLED.h"
 void setMaxRefreshRate(uint16_t refresh, bool constrain=false);





 void countFPS(int nFrames=25);



 uint16_t getFPS() { return m_nFPS; }



 int count();



 CLEDController & operator[](int x);



 int size();



 CRGB *leds();
};
# 890 "../../src/FastLED.h"
extern CFastLED FastLED;
# 901 "../../src/FastLED.h"

# 927 "../../src/FastLED.h"
# 1 "../../src/fl/function.h" 1
       





# 6 "../../src/fl/function.h"
#pragma GCC diagnostic push

# 7 "../../src/fl/function.h"
#pragma GCC diagnostic ignored "-W" "float-equal"

namespace fl {







template <typename> class function;

template <typename R, typename... Args> class function<R(Args...)> {
  private:
    struct CallableBase : public Referent {
        virtual R invoke(Args... args) = 0;
        virtual ~CallableBase() = default;
    };


    template <typename F> struct Callable : CallableBase {
        F f;
        Callable(F fn) : f(fn) {}
        R invoke(Args... args) override { return f(args...); }
    };


    template <typename C> struct MemCallable : CallableBase {
        C *obj;
        R (C::*mfp)(Args...);
        MemCallable(C *o, R (C::*m)(Args...)) : obj(o), mfp(m) {}
        R invoke(Args... args) override { return (obj->*mfp)(args...); }
    };


    template <typename C> struct ConstMemCallable : CallableBase {
        const C *obj;
        R (C::*mfp)(Args...) const;
        ConstMemCallable(const C *o, R (C::*m)(Args...) const)
            : obj(o), mfp(m) {}
        R invoke(Args... args) override { return (obj->*mfp)(args...); }
    };

    Ptr<CallableBase> callable_;

  public:
    function() = default;
    ~function() = default;

    function(const function &o) : callable_(o.callable_) {}

    function(function &&o) noexcept {
        callable_.swap(o.callable_);
        o.callable_.reset();
    }

    function &operator=(const function &o) {
        if (this != &o) {
            callable_ = o.callable_;
        }
        return *this;
    }

    function& operator=(function&& o) noexcept {
        if (this != &o) {
            callable_.swap(o.callable_);
            o.callable_.reset();
        }
        return *this;
    }


    template <typename F,
              typename = enable_if_t<!is_member_function_pointer<F>::value>>
    function(F f) : callable_(NewPtr<Callable<F>>(f)) {}


    template <typename C>
    function(R (C::*mf)(Args...), C *obj)
        : callable_(NewPtr<MemCallable<C>>(obj, mf)) {}


    template <typename C>
    function(R (C::*mf)(Args...) const, const C *obj)
        : callable_(NewPtr<ConstMemCallable<C>>(obj, mf)) {}


    R operator()(Args... args) const { return callable_->invoke(args...); }

    explicit operator bool() const { return callable_ != nullptr; }

    bool operator==(const function &o) const {
        return callable_ == o.callable_;
    }

    bool operator!=(const function &o) const {
        return callable_ != o.callable_;
    }
};

}


# 109 "../../src/fl/function.h"
#pragma GCC diagnostic pop
# 928 "../../src/FastLED.h" 2




# 1 "../../src/fl/clear.h" 1
       





namespace fl {

template<typename T>
class Grid;


template <int N> inline void clear(CRGB (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        arr[i] = CRGB::Black;
    }
}

inline void clear(Leds &leds) { leds.fill(CRGB::Black); }

template<size_t W, size_t H>
inline void clear(LedsXY<W, H> &leds) {
    leds.fill(CRGB::Black);
}

template<typename T>
inline void clear(Grid<T> &grid) {
    grid.clear();
}


template<typename Container>
inline void clear(Container &container) {
    container.clear();
}



}
# 933 "../../src/FastLED.h" 2




# 1 "../../src/fl/ui.h" 1
       



# 1 "../../src/fl/audio.h" 1
       

# 1 "../../src/fl/fft.h" 1
       


# 1 "../../src/fl/slice.h" 1
       







namespace fl {

template <typename T, size_t INLINED_SIZE> class FixedVector;

template <typename T, typename Allocator> class HeapVector;

template <typename T, size_t INLINED_SIZE> class InlinedVector;





template <typename T> class Slice {
  public:
    Slice() : mData(nullptr), mSize(0) {}
    Slice(T *data, size_t size) : mData(data), mSize(size) {}

    template<typename Alloc>
    Slice(const HeapVector<T, Alloc> &vector)
        : mData(vector.data()), mSize(vector.size()) {}

    template <size_t INLINED_SIZE>
    Slice(const FixedVector<T, INLINED_SIZE> &vector)
        : mData(vector.data()), mSize(vector.size()) {}

    template <size_t INLINED_SIZE>
    Slice(const InlinedVector<T, INLINED_SIZE> &vector)
        : mData(vector.data()), mSize(vector.size()) {}

    template <typename U, typename Alloc>
    Slice(const HeapVector<U, Alloc> &vector)
        : mData(vector.data()), mSize(vector.size()) {}

    template <typename U, size_t INLINED_SIZE>
    Slice(const FixedVector<U, INLINED_SIZE> &vector)
        : mData(vector.data()), mSize(vector.size()) {}

    template <typename U, size_t INLINED_SIZE>
    Slice(const InlinedVector<U, INLINED_SIZE> &vector)
        : mData(vector.data()), mSize(vector.size()) {}

    template <size_t ARRAYSIZE>
    Slice(T (&array)[ARRAYSIZE]) : mData(array), mSize(ARRAYSIZE) {}

    template <typename U, size_t ARRAYSIZE>
    Slice(T (&array)[ARRAYSIZE]) : mData(array), mSize(ARRAYSIZE) {}

    template <typename Iterator>
    Slice(Iterator begin, Iterator end)
        : mData(&(*begin)), mSize(end - begin) {}

    Slice(const Slice &other) : mData(other.mData), mSize(other.mSize) {}

    Slice &operator=(const Slice &other) {
        mData = other.mData;
        mSize = other.mSize;
        return *this;
    }


    operator Slice<const T>() const { return Slice<const T>(mData, mSize); }

    T &operator[](size_t index) {

        return mData[index];
    }

    const T &operator[](size_t index) const {

        return mData[index];
    }

    T *begin() const { return mData; }

    T *end() const { return mData + mSize; }

    size_t length() const { return mSize; }

    const T *data() const { return mData; }

    T *data() { return mData; }

    size_t size() const { return mSize; }

    Slice<T> slice(size_t start, size_t end) const {

        return Slice<T>(mData + start, end - start);
    }

    Slice<T> slice(size_t start) const {

        return Slice<T>(mData + start, mSize - start);
    }




    size_t find(const T &value) const {
        for (size_t i = 0; i < mSize; ++i) {
            if (mData[i] == value) {
                return i;
            }
        }
        return size_t(-1);
    }

    bool pop_front() {
        if (mSize == 0) {
            return false;
        }
        ++mData;
        --mSize;
        return true;
    }

    bool pop_back() {
        if (mSize == 0) {
            return false;
        }
        --mSize;
        return true;
    }

    T &front() { return *mData; }

    const T &front() const { return *mData; }

    T &back() { return *(mData + mSize - 1); }

    const T &back() const { return *(mData + mSize - 1); }

    bool empty() { return mSize == 0; }

  private:
    T *mData;
    size_t mSize;
};
template <typename T> class MatrixSlice {
  public:


    MatrixSlice() = default;
    MatrixSlice(T *data, int32_t dataWidth, int32_t dataHeight,
                int32_t bottomLeftX, int32_t bottomLeftY, int32_t topRightX,
                int32_t topRightY)
        : mData(data), mDataWidth(dataWidth), mDataHeight(dataHeight),
          mBottomLeft{bottomLeftX, bottomLeftY},
          mTopRight{topRightX, topRightY} {}

    MatrixSlice(const MatrixSlice &other) = default;
    MatrixSlice &operator=(const MatrixSlice &other) = default;


    vec2<int32_t> getParentCoord(int32_t x_local, int32_t y_local) const {
        return {x_local + mBottomLeft.x, y_local + mBottomLeft.y};
    }

    vec2<int32_t> getLocalCoord(int32_t x_world, int32_t y_world) const {

        int32_t x_clamped = fl::clamp(x_world, mBottomLeft.x, mTopRight.x);
        int32_t y_clamped = fl::clamp(y_world, mBottomLeft.y, mTopRight.y);

        return {x_clamped - mBottomLeft.x, y_clamped - mBottomLeft.y};
    }


    T &operator()(int32_t x, int32_t y) { return at(x, y); }


    T *operator[](int32_t row) {
        int32_t parentRow = row + mBottomLeft.y;
        return mData + parentRow * mDataWidth + mBottomLeft.x;
    }

    T &at(int32_t x, int32_t y) {
        auto parent = getParentCoord(x, y);
        return mData[parent.x + parent.y * mDataWidth];
    }

    const T &at(int32_t x, int32_t y) const {
        auto parent = getParentCoord(x, y);
        return mData[parent.x + parent.y * mDataWidth];
    }

  private:
    T *mData = nullptr;
    int32_t mDataWidth = 0;
    int32_t mDataHeight = 0;
    vec2<int32_t> mBottomLeft;
    vec2<int32_t> mTopRight;
};

}
# 5 "../../src/fl/fft.h" 2



namespace fl {

class FFTImpl;
class AudioSample;

struct FFTBins {
  public:
    FFTBins(size_t n) : mSize(n) {
        bins_raw.reserve(n);
        bins_db.reserve(n);
    }


    FFTBins(const FFTBins &other) : bins_raw(other.bins_raw), bins_db(other.bins_db), mSize(other.mSize) {}
    FFTBins &operator=(const FFTBins &other) {
        if (this != &other) {
            mSize = other.mSize;
            bins_raw = other.bins_raw;
            bins_db = other.bins_db;
        }
        return *this;
    }


    FFTBins(FFTBins &&other) noexcept
        : bins_raw(fl::move(other.bins_raw)), bins_db(fl::move(other.bins_db)), mSize(other.mSize) {}

    FFTBins &operator=(FFTBins &&other) noexcept {
        if (this != &other) {
            bins_raw = fl::move(other.bins_raw);
            bins_db = fl::move(other.bins_db);
            mSize = other.mSize;
        }
        return *this;
    }

    void clear() {
        bins_raw.clear();
        bins_db.clear();
    }

    size_t size() const { return mSize; }


    fl::vector<float> bins_raw;

    fl::vector<float> bins_db;

  private:
    size_t mSize;
};

struct FFT_Args {
    static int DefaultSamples() { return 512; }
    static int DefaultBands() { return 16; }
    static float DefaultMinFrequency() { return 174.6f; }
    static float DefaultMaxFrequency() { return 4698.3f; }
    static int DefaultSampleRate() { return 44100; }

    int samples;
    int bands;
    float fmin;
    float fmax;
    int sample_rate;

    FFT_Args(int samples = DefaultSamples(), int bands = DefaultBands(),
             float fmin = DefaultMinFrequency(),
             float fmax = DefaultMaxFrequency(),
             int sample_rate = DefaultSampleRate()) {


        memset(this, 0, sizeof(FFT_Args));
        this->samples = samples;
        this->bands = bands;
        this->fmin = fmin;
        this->fmax = fmax;
        this->sample_rate = sample_rate;
    }


    FFT_Args(const FFT_Args &other) = default;
    FFT_Args &operator=(const FFT_Args &other) = default;
    FFT_Args(FFT_Args &&other) noexcept = default;
    FFT_Args &operator=(FFT_Args &&other) noexcept = default;

    bool operator==(const FFT_Args &other) const ;
    bool operator!=(const FFT_Args &other) const { return !(*this == other); }
};

class FFT {
  public:
    FFT();
    ~FFT();

    FFT(FFT &&) = default;
    FFT &operator=(FFT &&) = default;
    FFT(const FFT & other);
    FFT &operator=(const FFT & other);

    void run(const Slice<const int16_t> &sample, FFTBins *out,
             const FFT_Args &args = FFT_Args());

    void clear();
    size_t size() const;



    void setFFTCacheSize(size_t size);

  private:

    FFTImpl &get_or_create(const FFT_Args &args);
    struct HashMap;
    scoped_ptr<HashMap> mMap;
};

};
# 4 "../../src/fl/audio.h" 2




# 1 "/usr/include/c++/14/math.h" 1 3
# 9 "../../src/fl/audio.h" 2


namespace fl {

class AudioSampleImpl;

class AudioSampleImpl; using AudioSampleImplPtr = fl::Ptr<AudioSampleImpl>;;




class AudioSample {
  public:
    using VectorPCM = fl::vector<int16_t>;
    using const_iterator = VectorPCM::const_iterator;
    AudioSample() {}
    AudioSample(const AudioSample &other) : mImpl(other.mImpl) {}
    AudioSample(AudioSampleImplPtr impl) : mImpl(impl) {}
    AudioSample &operator=(const AudioSample &other);
    bool isValid() const { return mImpl != nullptr; }

    size_t size() const;

    const VectorPCM &pcm() const;


    float zcf() const;
    float rms() const;

    void fft(FFTBins *out);

    const_iterator begin() const { return pcm().begin(); }
    const_iterator end() const { return pcm().end(); }
    const int16_t &at(size_t i) const;
    const int16_t &operator[](size_t i) const;
    operator bool() const { return isValid(); }
    bool operator==(const AudioSample &other) const;
    bool operator!=(const AudioSample &other) const;

  private:
    static const VectorPCM &empty();
    AudioSampleImplPtr mImpl;
};







class SoundLevelMeter {
  public:



    SoundLevelMeter(double spl_floor = 33.0f, double smoothing_alpha = 0.0);


    void processBlock(const int16_t *samples, size_t count);
    void processBlock(fl::Slice<const int16_t> samples) {
        processBlock(samples.data(), samples.size());
    }


    double getDBFS() const { return current_dbfs_; }


    double getSPL() const { return current_spl_; }


    void setFloorSPL(double spl_floor) {
        spl_floor_ = spl_floor;
        offset_ = spl_floor_ - dbfs_floor_global_;
    }


    void resetFloor() {
        dbfs_floor_global_ = (1.0 / 0.0);
        offset_ = 0.0;
    }

  private:
    double spl_floor_;
    double smoothing_alpha_;
    double dbfs_floor_global_;
    double offset_;
    double current_dbfs_;
    double current_spl_;
};


class AudioSampleImpl : public fl::Referent {
  public:
    using VectorPCM = fl::vector<int16_t>;
    ~AudioSampleImpl() {}
    template <typename It> void assign(It begin, It end) {
        mSignedPcm.assign(begin, end);

        initZeroCrossings();
    }
    const VectorPCM &pcm() const { return mSignedPcm; }
# 120 "../../src/fl/audio.h"
    float zcf() const {
        const size_t n = pcm().size();
        if (n < 2) {
            return 0.f;
        }
        return float(mZeroCrossings) / (n - 1);
    }

  private:
    void initZeroCrossings() {
        mZeroCrossings = 0;
        if (mSignedPcm.size() > 1) {
            for (size_t i = 1; i < mSignedPcm.size(); ++i) {
                const bool crossed =
                    (mSignedPcm[i - 1] < 0 && mSignedPcm[i] >= 0) ||
                    (mSignedPcm[i - 1] >= 0 && mSignedPcm[i] < 0);
                if (crossed) {
                    ++mZeroCrossings;
                }
            }
        }
    }

    VectorPCM mSignedPcm;
    int16_t mZeroCrossings = 0;
};

}
# 6 "../../src/fl/ui.h" 2

# 1 "../../src/fl/function_list.h" 1
       





namespace fl {

template <typename FunctionType> class FunctionListBase {
  protected:
    fl::vector<pair<int, FunctionType>> mFunctions;
    int mCounter = 0;

  public:

    using iterator = typename fl::vector<pair<int, FunctionType>>::iterator;
    using const_iterator = typename fl::vector<pair<int, FunctionType>>::const_iterator;

    FunctionListBase() = default;
    ~FunctionListBase() = default;

    int add(FunctionType function) {
        int id = mCounter++;
        pair<int, FunctionType> entry(id, function);
        mFunctions.push_back(entry);
        return id;
    }

    void remove(int id) {
        for (int i = mFunctions.size() - 1; i >= 0; --i) {
            if (mFunctions[i].first == id) {
                mFunctions.erase(mFunctions.begin() + i);
            }
        }
    }



    void clear() { mFunctions.clear(); }


    iterator begin() { return mFunctions.begin(); }
    iterator end() { return mFunctions.end(); }
    const_iterator begin() const { return mFunctions.begin(); }
    const_iterator end() const { return mFunctions.end(); }
    const_iterator cbegin() const { return mFunctions.cbegin(); }
    const_iterator cend() const { return mFunctions.cend(); }


    size_t size() const { return mFunctions.size(); }
    bool empty() const { return mFunctions.empty(); }
};

template <typename... Args>
class FunctionList : public FunctionListBase<function<void(Args...)>> {
  public:
    void invoke(Args... args) {
        for (const auto &pair : this->mFunctions) {
            auto &function = pair.second;
            function(args...);
        }
    }
};

template <>
class FunctionList<void> : public FunctionListBase<function<void()>> {
  public:
    void invoke() {
        for (const auto &pair : this->mFunctions) {
            auto &function = pair.second;
            function();
        }
    }
};

template <>
class FunctionList<void()> : public FunctionListBase<function<void()>> {
  public:
    void invoke() {
        for (const auto &pair : this->mFunctions) {
            auto &function = pair.second;
            function();
        }
    }
};

}
# 8 "../../src/fl/ui.h" 2



# 1 "../../src/fl/ui_impl.h" 1
       
# 13 "../../src/fl/ui_impl.h"
# 1 "../../src/platforms/ui_defs.h" 1
       
# 14 "../../src/fl/ui_impl.h" 2
# 47 "../../src/fl/ui_impl.h"
namespace fl {





class UISliderImpl {
  public:

    UISliderImpl(const char *name, float value = 128.0f, float min = 1,
                 float max = 255, float step = -1.f)
        : mValue(value), mMin(fl::fl_min(min, max)), mMax(fl::fl_max(min, max)) {
        (void)(name);
        (void)(step);
        if (value < min) {
            mValue = min;
        }
        if (value > max) {
            mValue = max;
        }
    }
    ~UISliderImpl() {}
    float value() const { return mValue; }
    float getMax() const { return mMax; }
    float getMin() const { return mMin; }
    void setValue(float value) { mValue = fl::fl_max(mMin, fl::fl_min(mMax, value)); }
    operator float() const { return mValue; }
    operator uint8_t() const { return static_cast<uint8_t>(mValue); }
    operator uint16_t() const { return static_cast<uint16_t>(mValue); }
    operator int() const { return static_cast<int>(mValue); }
    template <typename T> T as() const { return static_cast<T>(mValue); }

    int as_int() const { return static_cast<int>(mValue); }


    void setGroup(const fl::string& groupName) { (void)(groupName); }

    UISliderImpl &operator=(float value) {
        setValue(value);
        return *this;
    }
    UISliderImpl &operator=(int value) {
        setValue(static_cast<float>(value));
        return *this;
    }

  private:
    float mValue;
    float mMin;
    float mMax;
};







class UIButtonImpl {
  public:
    UIButtonImpl(const char *name) { (void)(name); }
    ~UIButtonImpl() {}
    bool isPressed() const { return false; }
    bool clicked() const { return false; }
    int clickedCount() const { return 0; }
    operator bool() const { return false; }
    void click() {}
    fl::string name() const { return mName; }


    void setGroup(const fl::string& groupName) { (void)(groupName); }

  private:
    fl::string mName;
};





class UICheckboxImpl {
  public:
    UICheckboxImpl(const char *name, bool value = false) : mValue(value) {
        (void)(name);
    }
    ~UICheckboxImpl() {}
    operator bool() const { return mValue; }
    explicit operator int() const { return mValue ? 1 : 0; }
    UICheckboxImpl &operator=(bool value) {
        setValue(value);
        return *this;
    }
    UICheckboxImpl &operator=(int value) {
        setValue(value != 0);
        return *this;
    }
    bool value() const { return mValue; }


    void setGroup(const fl::string& groupName) { (void)(groupName); }

  private:
    void setValue(bool value) { mValue = value; }
    bool mValue;
};





class UINumberFieldImpl {
  public:
    UINumberFieldImpl(const char *name, double value, double min = 0,
                      double max = 100)
        : mValue(value), mMin(fl::fl_min(min, max)), mMax(fl::fl_max(min, max)) {
        (void)(name);
    }
    ~UINumberFieldImpl() {}
    double value() const { return mValue; }
    void setValue(double value) { mValue = fl::fl_max(mMin, fl::fl_min(mMax, value)); }
    operator double() const { return mValue; }
    operator int() const { return static_cast<int>(mValue); }
    UINumberFieldImpl &operator=(double value) {
        setValue(value);
        return *this;
    }
    UINumberFieldImpl &operator=(int value) {
        setValue(static_cast<double>(value));
        return *this;
    }


    void setGroup(const fl::string& groupName) { (void)(groupName); }

  private:
    double mValue;
    double mMin;
    double mMax;
};





class UITitleImpl {
  public:
    UITitleImpl(const char *name) { (void)(name); }
    ~UITitleImpl() {}


    void setGroup(const fl::string& groupName) { (void)(groupName); }
};





class UIDescriptionImpl {
  public:
    UIDescriptionImpl(const char *name) { (void)(name); }
    ~UIDescriptionImpl() {}


    void setGroup(const fl::string& groupName) { (void)(groupName); }
};




class UIAudioImpl {
  public:
    UIAudioImpl(const char *name) { (void)(name); }
    ~UIAudioImpl() {}

    AudioSample next() {
        fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fl/ui_impl.h")) << "(" << 222 << "): " << "Audio sample not implemented") .c_str());
        return AudioSample();
    }

    bool hasNext() {
        fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fl/ui_impl.h")) << "(" << 227 << "): " << "Audio sample not implemented") .c_str());
        return false;
    }


    void setGroup(const fl::string& groupName) { (void)(groupName); }
};



class UIDropdownImpl {
  public:

    template<size_t N>
    UIDropdownImpl(const char *name, const fl::string (&options)[N])
        : UIDropdownImpl(name, options, N) {}


    UIDropdownImpl(const char *name, const fl::vector<fl::string>& options)
        : mSelectedIndex(0) {
        (void)(name);
        for (size_t i = 0; i < options.size(); ++i) {
            mOptions.push_back(options[i]);
        }
        if (mOptions.empty()) {
            mOptions.push_back(fl::string("No options"));
        }
    }

    template<typename Iterator>
    UIDropdownImpl(const char *name, Iterator begin, Iterator end)
        : mSelectedIndex(0) {
        (void)(name);
        for (Iterator it = begin; it != end; ++it) {
            mOptions.push_back(*it);
        }
        if (mOptions.empty()) {
            mOptions.push_back(fl::string("No options"));
        }
    }


    UIDropdownImpl(const char *name, fl::Slice<fl::string> options)
        : mSelectedIndex(0) {
        (void)(name);
        for (size_t i = 0; i < options.size(); ++i) {
            mOptions.push_back(options[i]);
        }
        if (mOptions.empty()) {
            mOptions.push_back(fl::string("No options"));
        }
    }


    UIDropdownImpl(const char *name, fl::initializer_list<fl::string> options)
        : mSelectedIndex(0) {
        (void)(name);
        for (const auto& option : options) {
            mOptions.push_back(option);
        }
        if (mOptions.empty()) {
            mOptions.push_back(fl::string("No options"));
        }
    }

    ~UIDropdownImpl() {}

    fl::string value() const {
        if (mSelectedIndex < mOptions.size()) {
            return mOptions[mSelectedIndex];
        }
        return fl::string("Invalid");
    }

    int value_int() const { return static_cast<int>(mSelectedIndex); }

    void setSelectedIndex(int index) {
        if (index >= 0 && index < static_cast<int>(mOptions.size())) {
            mSelectedIndex = static_cast<size_t>(index);
        }
    }

    size_t getOptionCount() const { return mOptions.size(); }
    fl::string getOption(size_t index) const {
        if (index < mOptions.size()) {
            return mOptions[index];
        }
        return fl::string("Invalid");
    }


    void setGroup(const fl::string& groupName) { (void)(groupName); }

  private:

    UIDropdownImpl(const char *name, const fl::string* options, size_t count)
        : mSelectedIndex(0) {
        (void)(name);
        for (size_t i = 0; i < count; ++i) {
            mOptions.push_back(options[i]);
        }
        if (mOptions.empty()) {
            mOptions.push_back(fl::string("No options"));
        }
    }

    fl::vector<fl::string> mOptions;
    size_t mSelectedIndex;
};
# 344 "../../src/fl/ui_impl.h"
class UIGroupImpl {
  public:
    UIGroupImpl(const char *name) : mGroupName(name) {
        (void)(name);
    }
    ~UIGroupImpl() {}
    fl::string name() const { return mGroupName; }

  private:
    fl::string mGroupName;
};



}
# 12 "../../src/fl/ui.h" 2


# 1 "../../src/sensors/button.h" 1
       







# 1 "../../src/sensors/digital_pin.h" 1
       






namespace fl {

class DigitalPinImpl; using DigitalPinImplPtr = fl::Ptr<DigitalPinImpl>;;





class DigitalPin {
  public:
    enum Mode {
        kInput = 0,
        kOutput,
        kInputPullup,

    };

    DigitalPin(int pin);
    ~DigitalPin();
    DigitalPin(const DigitalPin &other);
    DigitalPin &operator=(const DigitalPin &other);

    DigitalPin(DigitalPin &&other) = delete;

    void setPinMode(Mode mode);
    bool high() const;
    void write(bool is_high);
  private:
    DigitalPinImplPtr mImpl;
};

}
# 10 "../../src/sensors/button.h" 2

namespace fl {

enum ButtonStrategy {







    kHighLowFloating,
    kPullUp,

};




class ButtonLowLevel {
  public:
    ButtonLowLevel(int pin, ButtonStrategy strategy = kHighLowFloating);
    ~ButtonLowLevel();
    ButtonLowLevel(const ButtonLowLevel &other) = default;
    ButtonLowLevel &operator=(const ButtonLowLevel &other) = delete;
    ButtonLowLevel(ButtonLowLevel &&other) = delete;
    bool isPressed();

    bool highLowFloating();

    void setStrategy(ButtonStrategy strategy);

  private:
    fl::DigitalPin mPin;
    ButtonStrategy mStrategy = kHighLowFloating;
};




class Button {
  public:
    Button(int pin,
           ButtonStrategy strategy = ButtonStrategy::kHighLowFloating);

    int onClick(fl::function<void()> callback);
    void removeOnClick(int id) {
        mOnClickCallbacks.remove(id);
    }

    void setStrategy(ButtonStrategy strategy) {
        mButton.setStrategy(strategy);
    }

    bool isPressed() {
        return mButton.isPressed();
    }

    bool clicked() const {

        return mClickedThisFrame;
    }

  protected:
    struct Listener : public EngineEvents::Listener {
        Listener(Button *owner);
        ~Listener();
        void addToEngineEventsOnce();







        void onEndFrame() override;

      private:
        Button *mOwner;
        bool added = false;
    };

  private:
    ButtonLowLevel mButton;
    Listener mListener;
    bool mPressedLastFrame = false;
    bool mClickedThisFrame = false;

    fl::FunctionList<void> mOnClickCallbacks;

};

}
# 15 "../../src/fl/ui.h" 2






namespace fl {


class UIElement {
  public:
    UIElement() {}
    virtual ~UIElement() {}
    virtual void setGroup(const fl::string& groupName) { mGroupName = groupName; }

    fl::string getGroup() const { return mGroupName; }
    bool hasGroup() const { return !mGroupName.empty(); }

  private:
    fl::string mGroupName;
};



class UISlider : public UIElement {
  public:
    UISlider(const UISlider &) = delete; UISlider &operator=(const UISlider &) = delete;

    UISlider(const char *name, float value = 128.0f, float min = 1,
             float max = 255, float step = -1.f)
        : mImpl(name, value, min, max, step), mListener(this) {}
    float value() const { return mImpl.value(); }
    float value_normalized() const {
        float min = mImpl.getMin();
        float max = mImpl.getMax();
        if ((fl::fl_abs((max) - (min)) < 0.0001f)) {
            return 0;
        }
        return (value() - min) / (max - min);
    }
    float getMax() const { return mImpl.getMax(); }
    void setValue(float value);
    operator float() const { return mImpl.value(); }
    operator uint8_t() const { return static_cast<uint8_t>(mImpl.value()); }
    operator uint16_t() const { return static_cast<uint16_t>(mImpl.value()); }
    operator int() const { return static_cast<int>(mImpl.value()); }
    template <typename T> T as() const {
        return static_cast<T>(mImpl.value());
    }

    int as_int() const { return static_cast<int>(mImpl.value()); }

    UISlider &operator=(float value) {
        mImpl.setValue(value);
        return *this;
    }
    UISlider &operator=(int value) {
        mImpl.setValue(static_cast<float>(value));
        return *this;
    }


    void setGroup(const fl::string& groupName) override {
        UIElement::setGroup(groupName);

        mImpl.setGroup(groupName);
    }


    int onChanged(function<void(UISlider &)> callback) {
        int out = mCallbacks.add(callback);
        mListener.addToEngineEventsOnce();
        return out;
    }
    void clearCallbacks() { mCallbacks.clear(); }

  protected:
    UISliderImpl mImpl;

    struct Listener : public EngineEvents::Listener {
        Listener(UISlider *owner) : mOwner(owner) {
            EngineEvents::addListener(this);
        }
        ~Listener() {
            if (added) {
                EngineEvents::removeListener(this);
            }
        }
        void addToEngineEventsOnce() {
            if (added) {
                return;
            }
            EngineEvents::addListener(this);
            added = true;
        }
        void onBeginFrame() override;

      private:
        UISlider *mOwner;
        bool added = false;
    };

  private:
    FunctionList<UISlider &> mCallbacks;
    float mLastFrameValue = 0;
    bool mLastFramevalueValid = false;
    Listener mListener;
};



class UIButton : public UIElement {
  public:
    UIButton(const UIButton &) = delete; UIButton &operator=(const UIButton &) = delete;
    UIButton(const char *name) : mImpl(name), mListener(this) {}
    ~UIButton() {}
    bool isPressed() const {
        if (mImpl.isPressed()) {
            return true;
        }

        if (mRealButton) {
            return mRealButton->isPressed();
        }

        return false;
    }
    bool clicked() const {
        if (mImpl.clicked()) {
            return true;
        }
        if (mRealButton) {

            return mRealButton->isPressed();
        }
        return false;
    }
    int clickedCount() const { return mImpl.clickedCount(); }
    operator bool() const { return clicked(); }
    bool value() const { return clicked(); }

    void addRealButton(const Button& pin) {
        mRealButton.reset(new Button(pin));
    }

    void click() { mImpl.click(); }


    void setGroup(const fl::string& groupName) override {
        UIElement::setGroup(groupName);

        mImpl.setGroup(groupName);
    }

    int onChanged(function<void(UIButton &)> callback) {
        int id = mCallbacks.add(callback);
        mListener.addToEngineEventsOnce();
        return id;
    }

    int onClicked(function<void()> callback) {
        int id = mCallbacks.add([callback](UIButton &btn) {
            if (btn.clicked()) {
                callback();
            }
        });
        mListener.addToEngineEventsOnce();
        return id;
    }

    void removeCallback(int id) { mCallbacks.remove(id); }
    void clearCallbacks() { mCallbacks.clear(); }

  protected:
    UIButtonImpl mImpl;

    struct Listener : public EngineEvents::Listener {
        Listener(UIButton *owner) : mOwner(owner) {
            EngineEvents::addListener(this);
        }
        ~Listener() {
            if (added) {
                EngineEvents::removeListener(this);
            }
        }
        void addToEngineEventsOnce() {
            if (added) {
                return;
            }
            EngineEvents::addListener(this);
            added = true;
        }
        void onBeginFrame() override;

      private:
        UIButton *mOwner;
        bool added = false;
        bool mClickedLastFrame = false;
    };

  private:
    FunctionList<UIButton &> mCallbacks;
    Listener mListener;
    fl::scoped_ptr<Button> mRealButton;
};

class UICheckbox : public UIElement {
  public:
    UICheckbox(const UICheckbox &) = delete; UICheckbox &operator=(const UICheckbox &) = delete;;
    UICheckbox(const char *name, bool value = false)
        : mImpl(name, value), mListener(this) {}
    ~UICheckbox() {}

    operator bool() const { return value(); }
    explicit operator int() const { return static_cast<int>(value()); }
    UICheckbox &operator=(bool value) {
        mImpl = value;
        return *this;
    }
    bool value() const { return mImpl.value(); }


    void setGroup(const fl::string& groupName) override {
        UIElement::setGroup(groupName);

        mImpl.setGroup(groupName);
    }


    void onChanged(function<void(UICheckbox &)> callback) {
        mCallbacks.add(callback);
        mListener.addToEngineEventsOnce();
    }
    void clearCallbacks() { mCallbacks.clear(); }

  protected:
    UICheckboxImpl mImpl;

    struct Listener : public EngineEvents::Listener {
        Listener(UICheckbox *owner) : mOwner(owner) {
            EngineEvents::addListener(this);
        }
        ~Listener() {
            if (added) {
                EngineEvents::removeListener(this);
            }
        }
        void addToEngineEventsOnce() {
            if (added) {
                return;
            }
            EngineEvents::addListener(this);
            added = true;
        }
        void onBeginFrame() override;

      private:
        UICheckbox *mOwner;
        bool added = false;
    };

  private:
    FunctionList<UICheckbox &> mCallbacks;
    bool mLastFrameValue = false;
    bool mLastFrameValueValid = false;
    Listener mListener;
};

class UINumberField : public UIElement {
  public:
    UINumberField(const UINumberField &) = delete; UINumberField &operator=(const UINumberField &) = delete;;
    UINumberField(const char *name, double value, double min = 0,
                  double max = 100)
        : mImpl(name, value, min, max), mListener(this) {}
    ~UINumberField() {}
    double value() const { return mImpl.value(); }
    void setValue(double value) { mImpl.setValue(value); }
    operator double() const { return mImpl.value(); }
    operator int() const { return static_cast<int>(mImpl.value()); }
    UINumberField &operator=(double value) {
        setValue(value);
        return *this;
    }
    UINumberField &operator=(int value) {
        setValue(static_cast<double>(value));
        return *this;
    }


    void setGroup(const fl::string& groupName) override {
        UIElement::setGroup(groupName);

        mImpl.setGroup(groupName);
    }


    void onChanged(function<void(UINumberField &)> callback) {
        mCallbacks.add(callback);
        mListener.addToEngineEventsOnce();
    }
    void clearCallbacks() { mCallbacks.clear(); }

  protected:
    UINumberFieldImpl mImpl;

  private:
    struct Listener : public EngineEvents::Listener {
        Listener(UINumberField *owner) : mOwner(owner) {
            EngineEvents::addListener(this);
        }
        ~Listener() {
            if (added) {
                EngineEvents::removeListener(this);
            }
        }
        void addToEngineEventsOnce() {
            if (added) {
                return;
            }
            EngineEvents::addListener(this);
            added = true;
        }
        void onBeginFrame() override;

      private:
        UINumberField *mOwner;
        bool added = false;
    };

    Listener mListener;
    double mLastFrameValue = 0;
    bool mLastFrameValueValid = false;
    FunctionList<UINumberField &> mCallbacks;
};

class UITitle : public UIElement {
  public:
    UITitle(const UITitle &) = delete; UITitle &operator=(const UITitle &) = delete;;
    UITitle(const char *name) : mImpl(name) {}
    ~UITitle() {}


    void setGroup(const fl::string& groupName) override {
        UIElement::setGroup(groupName);

        mImpl.setGroup(groupName);
    }

  protected:
    UITitleImpl mImpl;
};

class UIDescription : public UIElement {
  public:
    UIDescription(const UIDescription &) = delete; UIDescription &operator=(const UIDescription &) = delete;;
    UIDescription(const char *name) : mImpl(name) {}
    ~UIDescription() {}


    void setGroup(const fl::string& groupName) override {
        UIElement::setGroup(groupName);

        mImpl.setGroup(groupName);
    }

  protected:
    UIDescriptionImpl mImpl;
};

class UIAudio : public UIElement {
  public:
    UIAudio(const UIAudio &) = delete; UIAudio &operator=(const UIAudio &) = delete;
    UIAudio(const char *name) : mImpl(name) {}
    ~UIAudio() {}
    AudioSample next() { return mImpl.next(); }
    bool hasNext() { return mImpl.hasNext(); }


    void setGroup(const fl::string& groupName) override {
        UIElement::setGroup(groupName);

        mImpl.setGroup(groupName);
    }

  protected:
    UIAudioImpl mImpl;
};

class UIDropdown : public UIElement {
  public:
    UIDropdown(const UIDropdown &) = delete; UIDropdown &operator=(const UIDropdown &) = delete;

    template<typename Iterator>
    UIDropdown(const char *name, Iterator begin, Iterator end)
        : mImpl(name, begin, end), mListener(this) {}


    UIDropdown(const char *name, fl::Slice<fl::string> options)
        : mImpl(name, options), mListener(this) {}


    UIDropdown(const char *name, fl::initializer_list<fl::string> options)
        : mImpl(name, options), mListener(this) {}

    ~UIDropdown() {}

    fl::string value() const { return mImpl.value(); }
    int as_int() const { return mImpl.value_int(); }
    fl::string as_string() const { return value(); }

    void setSelectedIndex(int index) {
        mImpl.setSelectedIndex(index);
    }

    size_t getOptionCount() const { return mImpl.getOptionCount(); }
    fl::string getOption(size_t index) const { return mImpl.getOption(index); }

    operator fl::string() const { return value(); }
    operator int() const { return as_int(); }

    UIDropdown &operator=(int index) {
        setSelectedIndex(index);
        return *this;
    }


    void addNextButton(int pin) {
        mNextButton.reset(new Button(pin));
    }


    void nextOption() {
        int currentIndex = as_int();
        int nextIndex = (currentIndex + 1) % static_cast<int>(getOptionCount());
        setSelectedIndex(nextIndex);
    }


    void setGroup(const fl::string& groupName) override {
        UIElement::setGroup(groupName);

        mImpl.setGroup(groupName);
    }

    int onChanged(function<void(UIDropdown &)> callback) {
        int out = mCallbacks.add(callback);
        mListener.addToEngineEventsOnce();
        return out;
    }
    void clearCallbacks() { mCallbacks.clear(); }

  protected:
    UIDropdownImpl mImpl;

    struct Listener : public EngineEvents::Listener {
        Listener(UIDropdown *owner) : mOwner(owner) {
            EngineEvents::addListener(this);
        }
        ~Listener() {
            if (added) {
                EngineEvents::removeListener(this);
            }
        }
        void addToEngineEventsOnce() {
            if (added) {
                return;
            }
            EngineEvents::addListener(this);
            added = true;
        }
        void onBeginFrame() override;

      private:
        UIDropdown *mOwner;
        bool added = false;
    };

  private:
    FunctionList<UIDropdown &> mCallbacks;
    int mLastFrameValue = -1;
    bool mLastFrameValueValid = false;
    Listener mListener;
    fl::scoped_ptr<Button> mNextButton;
};

class UIGroup {
  public:
    UIGroup(const UIGroup &) = delete; UIGroup &operator=(const UIGroup &) = delete;;


    UIGroup(const fl::string& groupName) : mImpl(groupName.c_str()) {}


    template<typename... UIElements>
    UIGroup(const fl::string& groupName, UIElements&... elements)
        : mImpl(groupName.c_str()) {

        add(elements...);
    }

    ~UIGroup() {}


    fl::string name() const { return mImpl.name(); }


    operator fl::string() const { return name(); }


    template<typename T>
    void addControl(T* control) {
        control->setGroup(name());
    }

  protected:
    UIGroupImpl mImpl;

private:

    template<typename T>
    void add(T& control) {

        control.setGroup(name());
    }

    template<typename T, typename... Rest>
    void add(T& control, Rest&... rest) {

        control.setGroup(name());
        add(rest...);
    }
};
# 556 "../../src/fl/ui.h"
template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UISlider>::value && fl::is_pod<T>::value, bool>::type operator >=(const T &pod, const UISlider &obj) { return pod >= obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator >=( const UISlider &obj, const T &pod) { return obj >= pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UISlider>::value && fl::is_pod<T>::value, bool>::type operator <=(const T &pod, const UISlider &obj) { return pod <= obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator <=( const UISlider &obj, const T &pod) { return obj <= pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UISlider>::value && fl::is_pod<T>::value, bool>::type operator >(const T &pod, const UISlider &obj) { return pod > obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator >( const UISlider &obj, const T &pod) { return obj > pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UISlider>::value && fl::is_pod<T>::value, bool>::type operator <(const T &pod, const UISlider &obj) { return pod < obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator <( const UISlider &obj, const T &pod) { return obj < pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UISlider>::value && fl::is_pod<T>::value, bool>::type operator ==(const T &pod, const UISlider &obj) { return pod == obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator ==( const UISlider &obj, const T &pod) { return obj == pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UISlider>::value && fl::is_pod<T>::value, bool>::type operator !=(const T &pod, const UISlider &obj) { return pod != obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator !=( const UISlider &obj, const T &pod) { return obj != pod; };
template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UINumberField>::value && fl::is_pod<T>::value, bool>::type operator >=(const T &pod, const UINumberField &obj) { return pod >= obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator >=( const UINumberField &obj, const T &pod) { return obj >= pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UINumberField>::value && fl::is_pod<T>::value, bool>::type operator <=(const T &pod, const UINumberField &obj) { return pod <= obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator <=( const UINumberField &obj, const T &pod) { return obj <= pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UINumberField>::value && fl::is_pod<T>::value, bool>::type operator >(const T &pod, const UINumberField &obj) { return pod > obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator >( const UINumberField &obj, const T &pod) { return obj > pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UINumberField>::value && fl::is_pod<T>::value, bool>::type operator <(const T &pod, const UINumberField &obj) { return pod < obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator <( const UINumberField &obj, const T &pod) { return obj < pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UINumberField>::value && fl::is_pod<T>::value, bool>::type operator ==(const T &pod, const UINumberField &obj) { return pod == obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator ==( const UINumberField &obj, const T &pod) { return obj == pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UINumberField>::value && fl::is_pod<T>::value, bool>::type operator !=(const T &pod, const UINumberField &obj) { return pod != obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator !=( const UINumberField &obj, const T &pod) { return obj != pod; };
template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UICheckbox>::value && fl::is_pod<T>::value, bool>::type operator >=(const T &pod, const UICheckbox &obj) { return pod >= obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator >=( const UICheckbox &obj, const T &pod) { return obj >= pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UICheckbox>::value && fl::is_pod<T>::value, bool>::type operator <=(const T &pod, const UICheckbox &obj) { return pod <= obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator <=( const UICheckbox &obj, const T &pod) { return obj <= pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UICheckbox>::value && fl::is_pod<T>::value, bool>::type operator >(const T &pod, const UICheckbox &obj) { return pod > obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator >( const UICheckbox &obj, const T &pod) { return obj > pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UICheckbox>::value && fl::is_pod<T>::value, bool>::type operator <(const T &pod, const UICheckbox &obj) { return pod < obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator <( const UICheckbox &obj, const T &pod) { return obj < pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UICheckbox>::value && fl::is_pod<T>::value, bool>::type operator ==(const T &pod, const UICheckbox &obj) { return pod == obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator ==( const UICheckbox &obj, const T &pod) { return obj == pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UICheckbox>::value && fl::is_pod<T>::value, bool>::type operator !=(const T &pod, const UICheckbox &obj) { return pod != obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator !=( const UICheckbox &obj, const T &pod) { return obj != pod; };
template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UIButton>::value && fl::is_pod<T>::value, bool>::type operator >=(const T &pod, const UIButton &obj) { return pod >= obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator >=( const UIButton &obj, const T &pod) { return obj >= pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UIButton>::value && fl::is_pod<T>::value, bool>::type operator <=(const T &pod, const UIButton &obj) { return pod <= obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator <=( const UIButton &obj, const T &pod) { return obj <= pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UIButton>::value && fl::is_pod<T>::value, bool>::type operator >(const T &pod, const UIButton &obj) { return pod > obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator >( const UIButton &obj, const T &pod) { return obj > pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UIButton>::value && fl::is_pod<T>::value, bool>::type operator <(const T &pod, const UIButton &obj) { return pod < obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator <( const UIButton &obj, const T &pod) { return obj < pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UIButton>::value && fl::is_pod<T>::value, bool>::type operator ==(const T &pod, const UIButton &obj) { return pod == obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator ==( const UIButton &obj, const T &pod) { return obj == pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UIButton>::value && fl::is_pod<T>::value, bool>::type operator !=(const T &pod, const UIButton &obj) { return pod != obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator !=( const UIButton &obj, const T &pod) { return obj != pod; };
template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UIDropdown>::value && fl::is_pod<T>::value, bool>::type operator >=(const T &pod, const UIDropdown &obj) { return pod >= obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator >=( const UIDropdown &obj, const T &pod) { return obj >= pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UIDropdown>::value && fl::is_pod<T>::value, bool>::type operator <=(const T &pod, const UIDropdown &obj) { return pod <= obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator <=( const UIDropdown &obj, const T &pod) { return obj <= pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UIDropdown>::value && fl::is_pod<T>::value, bool>::type operator >(const T &pod, const UIDropdown &obj) { return pod > obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator >( const UIDropdown &obj, const T &pod) { return obj > pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UIDropdown>::value && fl::is_pod<T>::value, bool>::type operator <(const T &pod, const UIDropdown &obj) { return pod < obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator <( const UIDropdown &obj, const T &pod) { return obj < pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UIDropdown>::value && fl::is_pod<T>::value, bool>::type operator ==(const T &pod, const UIDropdown &obj) { return pod == obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator ==( const UIDropdown &obj, const T &pod) { return obj == pod; } template <typename T, typename U> typename fl::enable_if< fl::is_same<U, UIDropdown>::value && fl::is_pod<T>::value, bool>::type operator !=(const T &pod, const UIDropdown &obj) { return pod != obj; } template <typename T> typename fl::enable_if<fl::is_pod<T>::value, bool>::type operator !=( const UIDropdown &obj, const T &pod) { return obj != pod; };

}
# 938 "../../src/FastLED.h" 2
using fl::UITitle;
using fl::UIDescription;
using fl::UIButton;
using fl::UICheckbox;
using fl::UINumberField;
using fl::UISlider;
using fl::UIDropdown;
using fl::UIGroup;
using fl::XYMap;
# 2 "FestivalStick.cpp" 2
# 12 "FestivalStick.cpp"
# 1 "curr.h" 1
# 25 "curr.h"
# 1 "../../src/fl/corkscrew.h" 1
       
# 44 "../../src/fl/corkscrew.h"
# 1 "../../src/fl/tile2x2.h" 1
       
# 12 "../../src/fl/tile2x2.h"

struct CRGB;


namespace fl {

class XYMap;
class XYRasterU8Sparse;


class Tile2x2_u8 {

  public:
    static void Rasterize(const Slice<const Tile2x2_u8> &tiles,
                          XYRasterU8Sparse *output);

    Tile2x2_u8() = default;
    Tile2x2_u8(const vec2<int16_t> &origin) : mOrigin(origin) {}
    Tile2x2_u8(const Tile2x2_u8 &) = default;
    Tile2x2_u8 &operator=(const Tile2x2_u8 &) = default;
    Tile2x2_u8(Tile2x2_u8 &&) = default;

    void scale(uint8_t scale);

    void setOrigin(int16_t x, int16_t y) { mOrigin = vec2<int16_t>(x, y); }

    uint8_t &operator()(int x, int y) { return at(x, y); }
    uint8_t &at(int x, int y) { return mTile[y][x]; }
    const uint8_t &at(int x, int y) const { return mTile[y][x]; }

    uint8_t &lower_left() { return at(0, 0); }
    uint8_t &upper_left() { return at(0, 1); }
    uint8_t &lower_right() { return at(1, 0); }
    uint8_t &upper_right() { return at(1, 1); }

    const uint8_t &lower_left() const { return at(0, 0); }
    const uint8_t &upper_left() const { return at(0, 1); }
    const uint8_t &lower_right() const { return at(1, 0); }
    const uint8_t &upper_right() const { return at(1, 1); }

    uint8_t maxValue() const;

    static Tile2x2_u8 MaxTile(const Tile2x2_u8 &a, const Tile2x2_u8 &b);

    vec2<int16_t> origin() const { return mOrigin; }


    rect<int16_t> bounds() const;


    void draw(const CRGB &color, const XYMap &xymap, CRGB *out) const;



    template <typename XYVisitor>
    void draw(const XYMap &xymap, XYVisitor &visitor) const {
        for (uint16_t x = 0; x < 2; ++x) {
            for (uint16_t y = 0; y < 2; ++y) {
                uint8_t value = at(x, y);
                if (value > 0) {
                    int xx = mOrigin.x + x;
                    int yy = mOrigin.y + y;
                    if (xymap.has(xx, yy)) {
                        int index = xymap(xx, yy);
                        visitor.draw(vec2<int16_t>(xx, yy), index, value);
                    }
                }
            }
        }
    }

  private:
    uint8_t mTile[2][2] = {};

    vec2<int16_t> mOrigin;
};

class Tile2x2_u8_wrap {




  public:
    using Entry = fl::pair<vec2i16, uint8_t>;
    using Data = Entry[2][2];

    Tile2x2_u8_wrap();
    Tile2x2_u8_wrap(const Tile2x2_u8 &from, uint16_t width);
    Tile2x2_u8_wrap(const Tile2x2_u8 &from, uint16_t width, uint16_t height);

    Tile2x2_u8_wrap(const Data& data);


    Entry &at(uint16_t x, uint16_t y);
    const Entry &at(uint16_t x, uint16_t y) const;


    static vector_fixed<Tile2x2_u8_wrap, 2> Interpolate(const Tile2x2_u8_wrap& a, const Tile2x2_u8_wrap& b, float t);

  private:
    Data mData = {};
};

}
# 45 "../../src/fl/corkscrew.h" 2



namespace fl {


class Leds;
class ScreenMap;
template<typename T> class Grid;


constexpr uint16_t calculateCorkscrewWidth(float totalTurns, uint16_t numLeds) {
    return static_cast<uint16_t>(ceil_constexpr(static_cast<float>(numLeds) / totalTurns));
}

constexpr uint16_t calculateCorkscrewHeight(float totalTurns, uint16_t numLeds) {
    return (calculateCorkscrewWidth(totalTurns, numLeds) * static_cast<int>(ceil_constexpr(totalTurns)) > numLeds) ?
        static_cast<uint16_t>(ceil_constexpr(static_cast<float>(numLeds) / static_cast<float>(calculateCorkscrewWidth(totalTurns, numLeds)))) :
        static_cast<uint16_t>(ceil_constexpr(totalTurns));
}




struct Gap {
    int num_leds = 0;
    float gap = 0.0f;

    Gap() = default;
    Gap(float g) : num_leds(0), gap(g) {}
    Gap(int n, float g) : num_leds(n), gap(g) {}


    Gap(const Gap &other) = default;
    Gap &operator=(const Gap &other) = default;
    Gap(Gap &&other) noexcept = default;
    Gap &operator=(Gap &&other) noexcept = default;
};






struct CorkscrewInput {
    float totalTurns = 19.f;
    uint16_t numLeds = 144;
    Gap gapParams;
    bool invert = false;

    CorkscrewInput() = default;


    CorkscrewInput(float total_turns, uint16_t leds, bool invertMapping = false,
                   const Gap& gap = Gap())
        : totalTurns(total_turns), numLeds(leds), gapParams(gap),
          invert(invertMapping) {}


    CorkscrewInput(const CorkscrewInput &other) = default;
    CorkscrewInput &operator=(const CorkscrewInput &other) = default;
    CorkscrewInput(CorkscrewInput &&other) noexcept = default;
    CorkscrewInput &operator=(CorkscrewInput &&other) noexcept = default;


    uint16_t calculateWidth() const {

        float ledsPerTurn = static_cast<float>(numLeds) / totalTurns;
        return static_cast<uint16_t>(fl::ceil(ledsPerTurn));
    }

    uint16_t calculateHeight() const {

        uint16_t width = calculateWidth();
        uint16_t height_from_turns = static_cast<uint16_t>(fl::ceil(totalTurns));


        if (width * height_from_turns > numLeds) {

            return static_cast<uint16_t>(fl::ceil(static_cast<float>(numLeds) / static_cast<float>(width)));
        }

        return height_from_turns;
    }
};

struct CorkscrewState {
    uint16_t width = 0;
    uint16_t height = 0;

    CorkscrewState() = default;


    CorkscrewState(const CorkscrewState &other) = default;
    CorkscrewState &operator=(const CorkscrewState &other) = default;
    CorkscrewState(CorkscrewState &&other) noexcept = default;
    CorkscrewState &operator=(CorkscrewState &&other) noexcept = default;

    class iterator {
      public:
        using value_type = vec2f;
        using difference_type = int32_t;
        using pointer = vec2f *;
        using reference = vec2f &;

        iterator(const class Corkscrew *corkscrew, size_t position)
            : corkscrew_(corkscrew), position_(position) {}

        vec2f operator*() const;

        iterator &operator++() {
            ++position_;
            return *this;
        }

        iterator operator++(int) {
            iterator temp = *this;
            ++position_;
            return temp;
        }

        iterator &operator--() {
            --position_;
            return *this;
        }

        iterator operator--(int) {
            iterator temp = *this;
            --position_;
            return temp;
        }

        bool operator==(const iterator &other) const {
            return position_ == other.position_;
        }

        bool operator!=(const iterator &other) const {
            return position_ != other.position_;
        }

        difference_type operator-(const iterator &other) const {
            return static_cast<difference_type>(position_) -
                   static_cast<difference_type>(other.position_);
        }

      private:
        const class Corkscrew *corkscrew_;
        size_t position_;
    };
};



class Corkscrew {
  public:
    using Input = CorkscrewInput;
    using State = CorkscrewState;
    using iterator = CorkscrewState::iterator;

    Corkscrew(const Input &input);
    Corkscrew(const Corkscrew &) = default;
    Corkscrew(Corkscrew &&) = default;

    vec2f at_no_wrap(uint16_t i) const;
    vec2f at_exact(uint16_t i) const;


    Tile2x2_u8_wrap at_wrap(float i) const;
    size_t size() const;
    iterator begin() { return iterator(this, 0); }
    iterator end() { return iterator(this, size()); }

    int16_t cylinder_width() const { return mState.width; }
    int16_t cylinder_height() const { return mState.height; }


    void setCachingEnabled(bool enabled);



    fl::vector<CRGB>& getBuffer();
    const fl::vector<CRGB>& getBuffer() const;


    CRGB* data();
    const CRGB* data() const;





    void readFrom(const fl::Grid<CRGB>& source_grid, bool use_multi_sampling = true);




    void clearBuffer();


    void fillBuffer(const CRGB& color);



    fl::ScreenMap toScreenMap(float diameter = 0.5f) const;


    static State generateState(const Input &input);

  private:



    Tile2x2_u8 at_splat_extrapolate(float i) const;



    void readFromMulti(const fl::Grid<CRGB>& target_grid) const;


    void initializeBuffer() const;


    void initializeCache() const;


    Tile2x2_u8_wrap calculateTileAtWrap(float i) const;

    Input mInput;
    State mState;


    mutable fl::vector<CRGB> mCorkscrewLeds;
    mutable bool mBufferInitialized = false;


    mutable fl::vector<Tile2x2_u8_wrap> mTileCache;
    mutable bool mCacheInitialized = false;
    bool mCachingEnabled = true;
};

}
# 26 "curr.h" 2
# 1 "../../src/fl/grid.h" 1

       




namespace fl {


template <typename T> class Grid {
  public:
    Grid() = default;

    Grid(uint32_t width, uint32_t height) { reset(width, height); }

    void reset(uint32_t width, uint32_t height) {
        clear();
        if (width != mWidth || height != mHeight) {
            mWidth = width;
            mHeight = height;
            mData.resize(width * height);

        }
        mSlice = fl::MatrixSlice<T>(mData.data(), width, height, 0, 0,
                                    width, height);
    }


    void clear() {
        for (uint32_t i = 0; i < mWidth * mHeight; ++i) {
            mData[i] = T();
        }
    }

    vec2<T> minMax() const {
        T minValue = mData[0];
        T maxValue = mData[0];
        for (uint32_t i = 1; i < mWidth * mHeight; ++i) {
            if (mData[i] < minValue) {
                minValue = mData[i];
            }
            if (mData[i] > maxValue) {
                maxValue = mData[i];
            }
        }


        vec2<T> out(minValue, maxValue);
        return out;
    }

    T &at(uint32_t x, uint32_t y) { return access(x, y); }
    const T &at(uint32_t x, uint32_t y) const { return access(x, y); }

    T &operator()(uint32_t x, uint32_t y) { return at(x, y); }
    const T &operator()(uint32_t x, uint32_t y) const { return at(x, y); }

    uint32_t width() const { return mWidth; }
    uint32_t height() const { return mHeight; }

    T* data() { return mData.data(); }
    const T* data() const { return mData.data(); }

    size_t size() const { return mData.size(); }

  private:
    static T &NullValue() {
        static T gNull;
        return gNull;
    }
    T &access(uint32_t x, uint32_t y) {
        if (x < mWidth && y < mHeight) {
            return mSlice.at(x, y);
        } else {
            return NullValue();
        }
    }
    const T &access(uint32_t x, uint32_t y) const {
        if (x < mWidth && y < mHeight) {
            return mSlice.at(x, y);
        } else {
            return NullValue();
        }
    }
    fl::vector<T> mData;
    uint32_t mWidth = 0;
    uint32_t mHeight = 0;
    fl::MatrixSlice<T> mSlice;
};

}
# 27 "curr.h" 2


# 1 "../../src/fl/sstream.h" 1
       



namespace fl {
using sstream = StrStream;
}
# 30 "curr.h" 2


# 1 "../../src/fl/array.h" 1
       
# 10 "../../src/fl/array.h"
namespace fl {
# 21 "../../src/fl/array.h"
template <typename T, size_t N> class array {
  public:

    using value_type = T;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using reference = value_type &;
    using const_reference = const value_type &;
    using pointer = value_type *;
    using const_pointer = const value_type *;
    using iterator = pointer;
    using const_iterator = const_pointer;


    array() = default;


    explicit array(const T &value) {

        fill_n(data_, N, value);
    }


    array(fl::initializer_list<T> list) {
        for (size_t i = 0; i < N && i < list.size(); ++i) {
            data_[i] = list[i];
        }
    }


    array(const array &) = default;


    array(array &&) = default;


    array &operator=(const array &) = default;


    array &operator=(array &&) = default;


    T &at(size_type pos) {
        if (pos >= N) {
            return error_value();
        }
        return data_[pos];
    }

    const T &at(size_type pos) const {
        if (pos >= N) {
            return error_value();
        }
        return data_[pos];
    }

    T &operator[](size_type pos) { return data_[pos]; }

    const_reference operator[](size_type pos) const { return data_[pos]; }

    T &front() { return data_[0]; }

    const T &front() const { return data_[0]; }

    T &back() { return data_[N - 1]; }

    const T &back() const { return data_[N - 1]; }

    pointer data() noexcept { return data_; }

    const_pointer data() const noexcept { return data_; }


    iterator begin() noexcept { return data_; }

    const_iterator begin() const noexcept { return data_; }

    const_iterator cbegin() const noexcept { return data_; }

    iterator end() noexcept { return data_ + N; }

    const_iterator end() const noexcept { return data_ + N; }


    bool empty() const noexcept { return N == 0; }

    size_type size() const noexcept { return N; }

    size_type max_size() const noexcept { return N; }


    void fill(const T &value) {
        for (size_type i = 0; i < N; ++i) {
            data_[i] = value;
        }
    }

    void swap(array &other) {
        for (size_type i = 0; i < N; ++i) {
            fl::swap(data_[i], other.data_[i]);
        }
    }

  private:
    static T &error_value() {
        static T empty_value;
        return empty_value;
    }
    T data_[N];
};


template <typename T, size_t N>
bool operator==(const array<T, N> &lhs, const array<T, N> &rhs) {

    for (size_t i = 0; i < N; ++i) {
        if (lhs[i] != rhs[i]) {
            return false;
        }
    }
}

template <typename T, size_t N>
bool operator!=(const array<T, N> &lhs, const array<T, N> &rhs) {
    return !(lhs == rhs);
}

template <typename T, size_t N>
void swap(array<T, N> &lhs,
          array<T, N> &rhs) noexcept(noexcept(lhs.swap(rhs))) {
    lhs.swap(rhs);
}

}
# 33 "curr.h" 2
# 1 "../../src/fx/2d/wave.h" 1
       






# 1 "../../src/fl/gradient.h" 1
       





# 1 "../../src/fl/variant.h" 1
       




namespace fl {


template <typename... Types> class Variant {
  public:
    using Tag = uint8_t;
    static constexpr Tag Empty = 0;



    Variant() noexcept : _tag(Empty) {}

    template <typename T, typename = typename fl::enable_if<
                              contains_type<T, Types...>::value>::type>
    Variant(const T &value) : _tag(Empty) {
        construct<T>(value);
    }

    template <typename T, typename = typename fl::enable_if<
                              contains_type<T, Types...>::value>::type>
    Variant(T &&value) : _tag(Empty) {
        construct<T>(fl::move(value));
    }

    Variant(const Variant &other) : _tag(Empty) {
        if (!other.empty()) {
            copy_construct_from(other);
        }
    }

    Variant(Variant &&other) noexcept : _tag(Empty) {
        if (!other.empty()) {
            move_construct_from(other);
            other.reset();
        }
    }

    ~Variant() { reset(); }

    Variant &operator=(const Variant &other) {
        if (this != &other) {
            reset();
            if (!other.empty()) {
                copy_construct_from(other);
            }
        }
        return *this;
    }

    Variant &operator=(Variant &&other) noexcept {
        if (this != &other) {
            reset();
            if (!other.empty()) {
                move_construct_from(other);
                other.reset();
            }
        }
        return *this;
    }

    template <typename T, typename = typename fl::enable_if<
                              contains_type<T, Types...>::value>::type>
    Variant &operator=(const T &value) {
        reset();
        construct<T>(value);
        return *this;
    }

    template <typename T, typename = typename fl::enable_if<
                              contains_type<T, Types...>::value>::type>
    Variant &operator=(T &&value) {
        reset();
        construct<T>(fl::move(value));
        return *this;
    }



    template <typename T, typename... Args>
    typename fl::enable_if<contains_type<T, Types...>::value, T &>::type
    emplace(Args &&...args) {
        reset();
        construct<T>(fl::forward<Args>(args)...);
        return ptr<T>();
    }

    void reset() noexcept {
        if (!empty()) {
            destroy_current();
            _tag = Empty;
        }
    }

    Tag tag() const noexcept { return _tag; }
    bool empty() const noexcept { return _tag == Empty; }

    template <typename T> bool is() const noexcept {
        return _tag == type_to_tag<T>();
    }

    template <typename T> T *ptr() {
        return is<T>() ? reinterpret_cast<T *>(&_storage) : nullptr;
    }

    template <typename T> const T *ptr() const {
        return is<T>() ? reinterpret_cast<const T *>(&_storage) : nullptr;
    }
# 128 "../../src/fl/variant.h"
    template <typename T> bool equals(const T &other) const {
        if (auto p = ptr<T>()) {
            return *p == other;
        }
        return false;
    }


    template <typename Visitor> void visit(Visitor &visitor) {
        if (_tag == Empty)
            return;


        using Fn = void (*)(void *, Visitor &);




        static constexpr Fn table[] = {
            &Variant::template visit_fn<Types, Visitor>...};


        table[_tag - 1](&_storage, visitor);
    }

    template <typename Visitor> void visit(Visitor &visitor) const {
        if (_tag == Empty)
            return;


        using Fn = void (*)(const void *, Visitor &);


        static constexpr Fn table[] = {
            &Variant::template visit_fn_const<Types, Visitor>...};


        table[_tag - 1](&_storage, visitor);
    }

  private:

    template <typename T, typename Visitor>
    static void visit_fn(void *storage, Visitor &v) {

        v.accept(*reinterpret_cast<T *>(storage));
    }

    template <typename T, typename Visitor>
    static void visit_fn_const(const void *storage, Visitor &v) {

        v.accept(*reinterpret_cast<const T *>(storage));
    }


    void destroy_current() noexcept {
        using Fn = void (*)(void *);
        static constexpr Fn table[] = {&Variant::template destroy_fn<Types>...};
        if (_tag != Empty) {
            table[_tag - 1](&_storage);
        }
    }

    template <typename T> static void destroy_fn(void *storage) {
        reinterpret_cast<T *>(storage)->~T();
    }


    void copy_construct_from(const Variant &other) {
        using Fn = void (*)(void *, const Variant &);
        static constexpr Fn table[] = {&Variant::template copy_fn<Types>...};
        table[other._tag - 1](&_storage, other);
        _tag = other._tag;
    }

    template <typename T>
    static void copy_fn(void *storage, const Variant &other) {
        new (storage) T(*reinterpret_cast<const T *>(&other._storage));
    }


    void move_construct_from(Variant &other) noexcept {
        using Fn = void (*)(void *, Variant &);
        static constexpr Fn table[] = {&Variant::template move_fn<Types>...};
        table[other._tag - 1](&_storage, other);
        _tag = other._tag;
        other.reset();
    }

    template <typename T> static void move_fn(void *storage, Variant &other) {
        new (storage) T(fl::move(*reinterpret_cast<T *>(&other._storage)));
    }
# 228 "../../src/fl/variant.h"
    template <typename T> static constexpr Tag type_to_tag() {
        return type_to_tag_impl<T, Types...>::value;
    }


    template <typename T, typename... Ts> struct type_to_tag_impl;

    template <typename T> struct type_to_tag_impl<T> {
        static constexpr Tag value = 0;
    };

    template <typename T, typename U, typename... Rest>
    struct type_to_tag_impl<T, U, Rest...> {
        static constexpr Tag value =
            fl::is_same<T, U>::value
                ? 1
                : (type_to_tag_impl<T, Rest...>::value == 0
                       ? 0
                       : type_to_tag_impl<T, Rest...>::value + 1);
    };

    template <typename T, typename... Args> void construct(Args &&...args) {
        new (&_storage) T(fl::forward<Args>(args)...);
        _tag = type_to_tag<T>();
    }

    alignas(
        max_align<Types...>::value) char _storage[max_size<Types...>::value];

    Tag _tag;
};

}
# 8 "../../src/fl/gradient.h" 2

namespace fl {

class CRGBPalette16;
class CRGBPalette32;
class CRGBPalette256;
class GradientInlined;

class Gradient {
  public:
    using GradientFunction = fl::function<CRGB(uint8_t index)>;
    Gradient() = default;
    Gradient(const GradientInlined &other);

    template <typename T> Gradient(T *palette);
    Gradient(const Gradient &other);
    Gradient &operator=(const Gradient &other);

    Gradient(Gradient &&other) noexcept;


    void set(const CRGBPalette16 *palette);
    void set(const CRGBPalette32 *palette);
    void set(const CRGBPalette256 *palette);
    void set(const GradientFunction &func);

    CRGB colorAt(uint8_t index) const;
    void fill(Slice<const uint8_t> input, Slice<CRGB> output) const;

  private:
    using GradientVariant =
        Variant<const CRGBPalette16 *, const CRGBPalette32 *,
                const CRGBPalette256 *, GradientFunction>;
    GradientVariant mVariant;
};

class GradientInlined {
  public:
    using GradientFunction = fl::function<CRGB(uint8_t index)>;
    using GradientVariant =
        Variant<CRGBPalette16, CRGBPalette32, CRGBPalette256, GradientFunction>;
    GradientInlined() = default;

    template <typename T> GradientInlined(const T &palette) { set(palette); }

    GradientInlined(const GradientInlined &other) : mVariant(other.mVariant) {}

    void set(const CRGBPalette16 &palette) { mVariant = palette; }
    void set(const CRGBPalette32 &palette) { mVariant = palette; }
    void set(const CRGBPalette256 &palette) { mVariant = palette; }
    void set(const GradientFunction &func) { mVariant = func; }

    CRGB colorAt(uint8_t index) const;
    void fill(Slice<const uint8_t> input, Slice<CRGB> output) const;

    GradientVariant &variant() { return mVariant; }
    const GradientVariant &variant() const { return mVariant; }

  private:
    GradientVariant mVariant;
};

}
# 9 "../../src/fx/2d/wave.h" 2

# 1 "../../src/fl/wave_simulation.h" 1
# 13 "../../src/fl/wave_simulation.h"
       







# 1 "../../src/fl/wave_simulation_real.h" 1
# 9 "../../src/fl/wave_simulation_real.h"
       
# 20 "../../src/fl/wave_simulation_real.h"
# 1 "../../src/fl/supersample.h" 1
       

namespace fl {
enum SuperSample {
    SUPER_SAMPLE_NONE = 1,
    SUPER_SAMPLE_2X = 2,
    SUPER_SAMPLE_4X = 4,
    SUPER_SAMPLE_8X = 8
};
}
# 21 "../../src/fl/wave_simulation_real.h" 2

# 1 "../../src/fx/fx.h" 1
       




# 1 "../../src/fx/detail/draw_context.h" 1
       





namespace fl {



struct _DrawContext {
    uint32_t now;
    CRGB *leds;
    uint16_t frame_time = 0;
    float speed = 1.0f;
    _DrawContext(uint32_t now, CRGB *leds, uint16_t frame_time = 0,
                 float speed = 1.0f)
        : now(now), leds(leds), frame_time(frame_time), speed(speed) {}
};

}
# 7 "../../src/fx/fx.h" 2
# 1 "../../src/fx/detail/transition.h" 1
       




namespace fl {


class Transition {
  public:
    Transition() : mStart(0), mDuration(0), mNotStarted(true) {}
    ~Transition() {}

    uint8_t getProgress(uint32_t now) {
        if (mNotStarted) {
            return 0;
        }
        if (now < mStart) {
            return 0;
        } else if (now >= mStart + mDuration) {
            return 255;
        } else {
            return ((now - mStart) * 255) / mDuration;
        }
    }

    void start(uint32_t now, uint32_t duration) {
        mNotStarted = false;
        mStart = now;
        mDuration = duration;
    }

    void end() { mNotStarted = true; }

    bool isTransitioning(uint32_t now) {
        if (mNotStarted) {
            return false;
        }
        return now >= mStart && now < mStart + mDuration;
    }

  private:
    uint32_t mStart;
    uint32_t mDuration;
    bool mNotStarted;
};

}
# 8 "../../src/fx/fx.h" 2





namespace fl {

class Fx; using FxPtr = fl::Ptr<Fx>;;


class Fx : public fl::Referent {
  public:

    using DrawContext = _DrawContext;

    Fx(uint16_t numLeds) : mNumLeds(numLeds) {}




    virtual void
    draw(DrawContext context) = 0;




    virtual bool hasFixedFrameRate(float *fps) const {
        (void)(fps);
        return false;
    }


    virtual fl::string fxName() const = 0;


    virtual void pause(uint32_t now) { (void)(now); }
    virtual void resume(uint32_t now) {
        (void)(now);
    }


    uint16_t getNumLeds() const { return mNumLeds; }

  protected:
    virtual ~Fx() {}
    uint16_t mNumLeds;
};

}
# 23 "../../src/fl/wave_simulation_real.h" 2
# 1 "../../src/fx/fx2d.h" 1
       
# 10 "../../src/fx/fx2d.h"
namespace fl {

class Fx2d; using Fx2dPtr = fl::Ptr<Fx2d>;;



class Fx2d : public Fx {
  public:


    Fx2d(const XYMap &xyMap) : Fx(xyMap.getTotal()), mXyMap(xyMap) {}
    uint16_t xyMap(uint16_t x, uint16_t y) const {
        return mXyMap.mapToIndex(x, y);
    }
    uint16_t getHeight() const { return mXyMap.getHeight(); }
    uint16_t getWidth() const { return mXyMap.getWidth(); }
    void setXYMap(const XYMap &xyMap) { mXyMap = xyMap; }
    XYMap &getXYMap() { return mXyMap; }
    const XYMap &getXYMap() const { return mXyMap; }

  protected:
    XYMap mXyMap;
};

}
# 24 "../../src/fl/wave_simulation_real.h" 2

namespace fl {

namespace wave_detail {
int16_t float_to_fixed(float f);


float fixed_to_float(int16_t f);
}

class WaveSimulation1D_Real {
  public:





    WaveSimulation1D_Real(uint32_t length, float speed = 0.16f,
                          int dampening = 6);
    ~WaveSimulation1D_Real() = default;


    void setSpeed(float something);


    void setDampening(int damp);


    int getDampenening() const;


    float getSpeed() const;

    void setHalfDuplex(bool on) { mHalfDuplex = on; }

    bool getHalfDuplex() const { return mHalfDuplex; }




    float getf(size_t x) const;

    int16_t geti16(size_t x) const;
    int16_t geti16Previous(size_t x) const;

    int8_t geti8(size_t x) const { return static_cast<int8_t>(geti16(x) >> 8); }



    uint8_t getu8(size_t x) const {
        int16_t value = geti16(x);





        if (mHalfDuplex) {
            uint16_t v2 = static_cast<uint16_t>(value);
            v2 *= 2;
            return static_cast<uint8_t>(v2 >> 8);
        } else {
            return static_cast<uint8_t>(
                ((static_cast<uint16_t>(value) + 32768)) >> 8);
        }
    }


    bool has(size_t x) const;



    void set(size_t x, float value);


    void update();

  private:
    uint32_t length;


    fl::vector<int16_t> grid1;
    fl::vector<int16_t> grid2;
    size_t whichGrid;

    int16_t mCourantSq;
    int mDampenening;
    bool mHalfDuplex =
        true;

};

class WaveSimulation2D_Real {
  public:





    WaveSimulation2D_Real(uint32_t W, uint32_t H, float speed = 0.16f,
                          float dampening = 6.0f);
    ~WaveSimulation2D_Real() = default;


    void setSpeed(float something);



    void setDampening(int damp);


    int getDampenening() const;


    float getSpeed() const;



    float getf(size_t x, size_t y) const;



    int16_t geti16(size_t x, size_t y) const;
    int16_t geti16Previous(size_t x, size_t y) const;

    int8_t geti8(size_t x, size_t y) const {
        return static_cast<int8_t>(geti16(x, y) >> 8);
    }

    uint8_t getu8(size_t x, size_t y) const {
        int16_t value = geti16(x, y);





        if (mHalfDuplex) {
            uint16_t v2 = static_cast<uint16_t>(value);
            v2 *= 2;
            return static_cast<uint8_t>(v2 >> 8);
        } else {
            return static_cast<uint8_t>(
                ((static_cast<uint16_t>(value) + 32768)) >> 8);
        }
    }

    void setXCylindrical(bool on) { mXCylindrical = on; }


    bool has(size_t x, size_t y) const;




    void setf(size_t x, size_t y, float value);

    void seti16(size_t x, size_t y, int16_t value);

    void setHalfDuplex(bool on) { mHalfDuplex = on; }

    bool getHalfDuplex() const { return mHalfDuplex; }


    void update();

    uint32_t getWidth() const { return width; }
    uint32_t getHeight() const { return height; }

  private:
    uint32_t width;
    uint32_t height;
    uint32_t stride;


    fl::vector<int16_t, fl::allocator_psram<int16_t>> grid1;
    fl::vector<int16_t, fl::allocator_psram<int16_t>> grid2;

    size_t whichGrid;

    int16_t mCourantSq;
    int mDampening;
    bool mHalfDuplex =
        true;
    bool mXCylindrical = false;
};

}
# 22 "../../src/fl/wave_simulation.h" 2
# 30 "../../src/fl/wave_simulation.h"
namespace fl {

enum U8EasingFunction { WAVE_U8_MODE_LINEAR, WAVE_U8_MODE_SQRT };
# 42 "../../src/fl/wave_simulation.h"
class WaveSimulation1D {
  public:





    WaveSimulation1D(uint32_t length,
                     SuperSample factor = SuperSample::SUPER_SAMPLE_NONE,
                     float speed = 0.16f, int dampening = 6);

    void init(uint32_t length, SuperSample factor, float speed, int dampening);

    void setSuperSample(SuperSample factor) {
        if (uint32_t(factor) == mMultiplier) {
            return;
        }
        init(mOuterLength, factor, mSim->getSpeed(), mSim->getDampenening());
    }


    void setEasingMode(U8EasingFunction mode) { mU8Mode = mode; }

    ~WaveSimulation1D() = default;


    void setSpeed(float speed);
    void setDampening(int damp);
    int getDampenening() const;
    float getSpeed() const;


    void setExtraFrames(uint8_t extra);




    float getf(size_t x) const;



    int16_t geti16(size_t x) const;
    int16_t geti16Previous(size_t x) const;

    bool geti16All(size_t x, int16_t *curr, int16_t *prev, int16_t *diff) const;


    int8_t geti8(size_t x) const;

    uint8_t getu8(size_t x) const;


    bool has(size_t x) const;



    void setf(size_t x, float value);

    void setHalfDuplex(bool on) { mSim->setHalfDuplex(on); }


    void update();


    uint32_t getLength() const;

    WaveSimulation1D_Real &real() { return *mSim; }

  private:
    uint32_t mOuterLength;
    uint8_t mExtraFrames = 0;
    uint32_t mMultiplier;
    U8EasingFunction mU8Mode = WAVE_U8_MODE_LINEAR;

    fl::scoped_ptr<WaveSimulation1D_Real> mSim;
};

class WaveSimulation2D {
  public:
# 130 "../../src/fl/wave_simulation.h"
    WaveSimulation2D(uint32_t W, uint32_t H,
                     SuperSample factor = SuperSample::SUPER_SAMPLE_NONE,
                     float speed = 0.16f, float dampening = 6.0f);

    void init(uint32_t width, uint32_t height, SuperSample factor, float speed,
              int dampening);

    ~WaveSimulation2D() = default;


    void setSpeed(float speed);

    void setExtraFrames(uint8_t extra);

    void setDampening(int damp);

    void setEasingMode(U8EasingFunction mode) { mU8Mode = mode; }

    int getDampenening() const;

    float getSpeed() const;

    void setSuperSample(SuperSample factor) {
        if (uint32_t(factor) == mMultiplier) {
            return;
        }
        init(mOuterWidth, mOuterHeight, factor, mSim->getSpeed(),
             mSim->getDampenening());
    }

    void setXCylindrical(bool on) { mSim->setXCylindrical(on); }




    float getf(size_t x, size_t y) const;



    int16_t geti16(size_t x, size_t y) const;
    int16_t geti16Previous(size_t x, size_t y) const;

    bool geti16All(size_t x, size_t y, int16_t *curr, int16_t *prev,
                   int16_t *diff) const;


    int8_t geti8(size_t x, size_t y) const;



    uint8_t getu8(size_t x, size_t y) const;


    bool has(size_t x, size_t y) const;




    void setf(size_t x, size_t y, float value);

    void seti16(size_t x, size_t y, int16_t value);

    void setHalfDuplex(bool on) { mSim->setHalfDuplex(on); }


    void update();


    uint32_t getWidth() const;
    uint32_t getHeight() const;

    WaveSimulation2D_Real &real() { return *mSim; }

  private:
    uint32_t mOuterWidth;
    uint32_t mOuterHeight;
    uint8_t mExtraFrames = 0;
    uint32_t mMultiplier = 1;
    U8EasingFunction mU8Mode = WAVE_U8_MODE_LINEAR;

    fl::scoped_ptr<WaveSimulation2D_Real> mSim;
    fl::Grid<int16_t> mChangeGrid;
};

}
# 11 "../../src/fx/2d/wave.h" 2





namespace fl {

class WaveFx; using WaveFxPtr = fl::Ptr<WaveFx>;;
class WaveCrgbMap; using WaveCrgbMapPtr = fl::Ptr<WaveCrgbMap>;;
class WaveCrgbMapDefault; using WaveCrgbMapDefaultPtr = fl::Ptr<WaveCrgbMapDefault>;;
class WaveCrgbGradientMap; using WaveCrgbGradientMapPtr = fl::Ptr<WaveCrgbGradientMap>;;

class WaveCrgbMap : public Referent {
  public:
    virtual ~WaveCrgbMap() = default;
    virtual void mapWaveToLEDs(const XYMap &xymap, WaveSimulation2D &waveSim,
                               CRGB *leds) = 0;
};



class WaveCrgbMapDefault : public WaveCrgbMap {
  public:
    void mapWaveToLEDs(const XYMap &xymap, WaveSimulation2D &waveSim,
                       CRGB *leds) override {
        const uint32_t width = waveSim.getWidth();
        const uint32_t height = waveSim.getHeight();
        for (uint32_t y = 0; y < height; y++) {
            for (uint32_t x = 0; x < width; x++) {
                uint32_t idx = xymap(x, y);
                uint8_t value8 = waveSim.getu8(x, y);
                leds[idx] = CRGB(value8, value8, value8);
            }
        }
    }
};

class WaveCrgbGradientMap : public WaveCrgbMap {
  public:
    using Gradient = fl::GradientInlined;
    WaveCrgbGradientMap(const CRGBPalette16 &palette) : mGradient(palette) {}

    void mapWaveToLEDs(const XYMap &xymap, WaveSimulation2D &waveSim,
                       CRGB *leds) override;

  private:
    Gradient mGradient;
};

struct WaveFxArgs {
    WaveFxArgs() = default;
    WaveFxArgs(SuperSample factor, bool half_duplex, bool auto_updates,
               float speed, float dampening, WaveCrgbMapPtr crgbMap)
        : factor(factor), half_duplex(half_duplex), auto_updates(auto_updates),
          speed(speed), dampening(dampening), crgbMap(crgbMap) {}
    WaveFxArgs(const WaveFxArgs &) = default;
    WaveFxArgs &operator=(const WaveFxArgs &) = default;
    SuperSample factor = SuperSample::SUPER_SAMPLE_2X;
    bool half_duplex = true;
    bool auto_updates = true;
    float speed = 0.16f;
    float dampening = 6.0f;
    bool x_cyclical = false;
    WaveCrgbMapPtr crgbMap;
};


class WaveFx : public Fx2d {
  public:
    using Args = WaveFxArgs;

    WaveFx(XYMap xymap, Args args = Args())
        : Fx2d(xymap), mWaveSim(xymap.getWidth(), xymap.getHeight(),
                                args.factor, args.speed, args.dampening) {

        if (args.crgbMap == nullptr) {

            mCrgbMap = WaveCrgbMapDefaultPtr::New();
        } else {

            mCrgbMap = args.crgbMap;
        }
        setAutoUpdate(args.auto_updates);
        setXCylindrical(args.x_cyclical);
    }

    void setXCylindrical(bool on) { mWaveSim.setXCylindrical(on); }

    void setSpeed(float speed) {

        mWaveSim.setSpeed(speed);
    }

    void setDampening(float dampening) {

        mWaveSim.setDampening(dampening);
    }

    void setHalfDuplex(bool on) {

        mWaveSim.setHalfDuplex(on);
    }

    void setSuperSample(SuperSample factor) {

        mWaveSim.setSuperSample(factor);
    }

    void setEasingMode(U8EasingFunction mode) {

        mWaveSim.setEasingMode(mode);
    }

    void setf(size_t x, size_t y, float value) {

        mWaveSim.setf(x, y, value);
    }

    void addf(size_t x, size_t y, float value) {

        float sum = value + mWaveSim.getf(x, y);
        mWaveSim.setf(x, y, fl::fl_min(1.0f, sum));
    }

    uint8_t getu8(size_t x, size_t y) const {

        return mWaveSim.getu8(x, y);
    }


    void setCrgbMap(WaveCrgbMapPtr crgbMap) {

        mCrgbMap.reset(crgbMap);
    }

    void draw(DrawContext context) override {

        if (mAutoUpdates) {
            mWaveSim.update();
        }

        mCrgbMap->mapWaveToLEDs(mXyMap, mWaveSim, context.leds);
    }

    void setAutoUpdate(bool autoUpdate) {

        mAutoUpdates = autoUpdate;
    }

    void update() {



        mWaveSim.update();
    }

    fl::string fxName() const override { return "WaveFx"; }

    WaveSimulation2D mWaveSim;
    WaveCrgbMapPtr mCrgbMap;
    bool mAutoUpdates = true;
};

}
# 34 "curr.h" 2
# 1 "../../src/fx/2d/blend.h" 1






       
# 16 "../../src/fx/2d/blend.h"
# 1 "../../src/fx/frame.h" 1
       
# 12 "../../src/fx/frame.h"
# 1 "../../src/fl/draw_mode.h" 1
       

namespace fl {

enum DrawMode { DRAW_MODE_OVERWRITE, DRAW_MODE_BLEND_BY_MAX_BRIGHTNESS };

}
# 13 "../../src/fx/frame.h" 2

namespace fl {

class Frame; using FramePtr = fl::Ptr<Frame>;;





class Frame : public fl::Referent {
  public:




    explicit Frame(int pixels_per_frame);
    ~Frame() override;
    CRGB *rgb() { return mRgb.data(); }
    const CRGB *rgb() const { return mRgb.data(); }
    size_t size() const { return mPixelsCount; }
    void copy(const Frame &other);
    void interpolate(const Frame &frame1, const Frame &frame2,
                     uint8_t amountOfFrame2);
    static void interpolate(const Frame &frame1, const Frame &frame2,
                            uint8_t amountofFrame2, CRGB *pixels);
    void draw(CRGB *leds, DrawMode draw_mode = DRAW_MODE_OVERWRITE) const;
    void drawXY(CRGB *leds, const XYMap &xyMap,
                DrawMode draw_mode = DRAW_MODE_OVERWRITE) const;
    void clear();

  private:
    const size_t mPixelsCount;
    fl::vector<CRGB, fl::allocator_psram<CRGB>> mRgb;
};

inline void Frame::copy(const Frame &other) {
    memcpy(mRgb.data(), other.mRgb.data(), other.mPixelsCount * sizeof(CRGB));
}

}
# 17 "../../src/fx/2d/blend.h" 2



namespace fl {

struct Blend2dParams {
    uint8_t blur_amount = 0;
    uint8_t blur_passes = 1;
};

class Blend2d; using Blend2dPtr = fl::Ptr<Blend2d>;;

class Blend2d : public Fx2d {
  public:
    using Params = Blend2dParams;


    Blend2d(const XYMap &xymap);
    fl::string fxName() const override;
    void add(Fx2dPtr layer, const Params &p = Params());
    void add(Fx2d &layer, const Params &p = Params());
    void draw(DrawContext context) override;
    void clear();
    void setGlobalBlurAmount(uint8_t blur_amount) {
        mGlobalBlurAmount = blur_amount;
    }
    void setGlobalBlurPasses(uint8_t blur_passes) {
        mGlobalBlurPasses = blur_passes;
    }
    bool setParams(Fx2dPtr fx, const Params &p);
    bool setParams(Fx2d &fx, const Params &p);

  protected:
    struct Entry {
        Fx2dPtr fx;
        uint8_t blur_amount = 0;
        uint8_t blur_passes = 1;
        Entry() = default;
        Entry(Fx2dPtr fx, uint8_t blur_amount, uint8_t blur_passes)
            : fx(fx), blur_amount(blur_amount), blur_passes(blur_passes) {}
    };
    HeapVector<Entry> mLayers;
    FramePtr mFrame;
    FramePtr mFrameTransform;
    uint8_t mGlobalBlurAmount = 0;
    uint8_t mGlobalBlurPasses = 1;
};

}
# 35 "curr.h" 2
# 1 "../../src/fx/fx_engine.h" 1
       







# 1 "../../src/fx/detail/fx_compositor.h" 1
       
# 10 "../../src/fx/detail/fx_compositor.h"
# 1 "../../src/fx/detail/fx_layer.h" 1
       
# 14 "../../src/fx/detail/fx_layer.h"
namespace fl {

class FxLayer; using FxLayerPtr = fl::Ptr<FxLayer>;;
class FxLayer : public fl::Referent {
  public:
    void setFx(fl::Ptr<Fx> newFx);

    void draw(uint32_t now);

    void pause(uint32_t now);

    void release();

    fl::Ptr<Fx> getFx();

    CRGB *getSurface();

  private:
    fl::Ptr<Frame> frame;
    fl::Ptr<Fx> fx;
    bool running = false;
};

}
# 11 "../../src/fx/detail/fx_compositor.h" 2






namespace fl {


class FxCompositor {
  public:
    FxCompositor(uint32_t numLeds) : mNumLeds(numLeds) {
        mLayers[0] = FxLayerPtr::New();
        mLayers[1] = FxLayerPtr::New();
    }

    void startTransition(uint32_t now, uint32_t duration, fl::Ptr<Fx> nextFx) {
        completeTransition();
        if (duration == 0) {
            mLayers[0]->setFx(nextFx);
            return;
        }
        mLayers[1]->setFx(nextFx);
        mTransition.start(now, duration);
    }

    void completeTransition() {
        if (mLayers[1]->getFx()) {
            swapLayers();
            mLayers[1]->release();
        }
        mTransition.end();
    }

    void draw(uint32_t now, uint32_t warpedTime, CRGB *finalBuffer);

  private:
    void swapLayers() {
        FxLayerPtr tmp = mLayers[0];
        mLayers[0] = mLayers[1];
        mLayers[1] = tmp;
    }

    FxLayerPtr mLayers[2];
    const uint32_t mNumLeds;
    Transition mTransition;
};

inline void FxCompositor::draw(uint32_t now, uint32_t warpedTime,
                               CRGB *finalBuffer) {
    if (!mLayers[0]->getFx()) {
        return;
    }
    mLayers[0]->draw(warpedTime);
    uint8_t progress = mTransition.getProgress(now);
    if (!progress) {
        memcpy(finalBuffer, mLayers[0]->getSurface(), sizeof(CRGB) * mNumLeds);
        return;
    }
    mLayers[1]->draw(warpedTime);
    const CRGB *surface0 = mLayers[0]->getSurface();
    const CRGB *surface1 = mLayers[1]->getSurface();

    for (uint32_t i = 0; i < mNumLeds; i++) {
        const CRGB &p0 = surface0[i];
        const CRGB &p1 = surface1[i];
        CRGB out = CRGB::blend(p0, p1, progress);
        finalBuffer[i] = out;
    }
    if (progress == 255) {
        completeTransition();
    }
}

}
# 10 "../../src/fx/fx_engine.h" 2


# 1 "../../src/fx/time.h" 1
       







namespace fl {

class TimeFunction; using TimeFunctionPtr = fl::Ptr<TimeFunction>;;
class TimeWarp; using TimeWarpPtr = fl::Ptr<TimeWarp>;;


class TimeFunction : public fl::Referent {
  public:
    virtual ~TimeFunction() {}
    virtual uint32_t
    update(uint32_t timeNow) = 0;

    virtual uint32_t time() const = 0;
    virtual void reset(uint32_t realTimeNow) = 0;
};







class TimeWarp : public TimeFunction {
  public:
    TimeWarp(uint32_t realTimeNow = 0, float initialTimeScale = 1.0f);
    ~TimeWarp();
    void setSpeed(float speedScale);
    void setScale(float speed)
        __attribute__((deprecated("Use setSpeed(...) instead.")));
    float scale() const;
    uint32_t update(uint32_t timeNow) override;
    uint32_t time() const override;
    void reset(uint32_t realTimeNow) override;
    void pause(uint32_t now);
    void resume(uint32_t now);

  private:
    void applyExact(uint32_t timeNow);
    uint32_t mLastRealTime = 0;
    uint32_t mStartTime = 0;
    uint32_t mRelativeTime = 0;
    float mTimeScale = 1.0f;
    uint32_t mPauseTime = 0;
};

}
# 13 "../../src/fx/fx_engine.h" 2
# 1 "../../src/fx/video.h" 1
       






# 1 "../../src/fx/fx1d.h" 1
       







namespace fl {


class Fx1d : public Fx {
  public:
    Fx1d(uint16_t numLeds) : Fx(numLeds), mXMap(numLeds, false) {}
    void setXmap(const XMap &xMap) { mXMap = xMap; }

    uint16_t xyMap(uint16_t x) const { return mXMap.mapToIndex(x); }

  protected:
    XMap mXMap;
};

}
# 9 "../../src/fx/video.h" 2



struct CRGB;


namespace fl {


class FileHandle; using FileHandlePtr = fl::Ptr<FileHandle>;;
class ByteStream; using ByteStreamPtr = fl::Ptr<ByteStream>;;
class Frame; using FramePtr = fl::Ptr<Frame>;;
class VideoImpl; using VideoImplPtr = fl::Ptr<VideoImpl>;;
class VideoFxWrapper; using VideoFxWrapperPtr = fl::Ptr<VideoFxWrapper>;;
class ByteStreamMemory; using ByteStreamMemoryPtr = fl::Ptr<ByteStreamMemory>;;




class Video : public Fx1d {
  public:
    static size_t DefaultFrameHistoryCount() {



        return 2;

    }






    Video();
    Video(size_t pixelsPerFrame, float fps = 30.0f,
          size_t frameHistoryCount =
              DefaultFrameHistoryCount());

    ~Video();
    Video(const Video &);
    Video &operator=(const Video &);


    void draw(DrawContext context) override;
    Str fxName() const override;


    bool begin(fl::FileHandlePtr h);
    bool beginStream(fl::ByteStreamPtr s);
    bool draw(uint32_t now, CRGB *leds);
    bool draw(uint32_t now, Frame *frame);
    void end();
    bool finished();
    bool rewind();
    void setTimeScale(float timeScale);
    float timeScale() const;
    Str error() const;
    void setError(const Str &error) { mError = error; }
    size_t pixelsPerFrame() const;
    void pause(uint32_t now) override;
    void resume(uint32_t now) override;
    void setFade(uint32_t fadeInTime, uint32_t fadeOutTime);
    int32_t durationMicros() const;


    operator bool() const { return mImpl.get(); }

  private:
    bool mFinished = false;
    VideoImplPtr mImpl;
    Str mError;
    Str mName;
};






class VideoFxWrapper : public Fx1d {
  public:
    VideoFxWrapper(FxPtr fx);
    ~VideoFxWrapper() override;
    void draw(DrawContext context) override;
    Str fxName() const override;
    void setFade(uint32_t fadeInTime, uint32_t fadeOutTime);

  private:
    FxPtr mFx;
    VideoImplPtr mVideo;
    ByteStreamMemoryPtr mByteStream;
    float mFps = 30.0f;
};

}
# 14 "../../src/fx/fx_engine.h" 2



class TimeFunction;





namespace fl {
# 34 "../../src/fx/fx_engine.h"
class FxEngine {
  public:
    typedef fl::FixedMap<int, FxPtr, 64> IntFxMap;




    FxEngine(uint16_t numLeds, bool interpolate = true);




    ~FxEngine();







    int addFx(FxPtr effect);
# 64 "../../src/fx/fx_engine.h"
    int addFx(Fx &effect) { return addFx(fl::Ptr<Fx>::NoTracking(effect)); }
# 73 "../../src/fx/fx_engine.h"
    FxPtr removeFx(int index);






    FxPtr getFx(int index);

    int getCurrentFxId() const { return mCurrId; }






    bool draw(uint32_t now, CRGB *outputBuffer);






    bool nextFx(uint16_t transition_ms = 500);







    bool setNextFx(int index, uint16_t duration);

    IntFxMap &_getEffects() { return mEffects; }






    void setSpeed(float scale) { mTimeFunction.setSpeed(scale); }

  private:
    int mCounter = 0;
    TimeWarp mTimeFunction;

    IntFxMap mEffects;
    FxCompositor mCompositor;
    int mCurrId;
    uint16_t mDuration = 0;
    bool mDurationSet =
        false;
    bool mInterpolate = true;
};

}
# 36 "curr.h" 2
# 1 "../../src/fx/2d/animartrix.hpp" 1
       
# 21 "../../src/fx/2d/animartrix.hpp"
# 1 "../../src/fx/2d/animartrix_detail.hpp" 1
       
# 30 "../../src/fx/2d/animartrix_detail.hpp"
# 1 "/usr/include/c++/14/math.h" 1 3
# 31 "../../src/fx/2d/animartrix_detail.hpp" 2
# 78 "../../src/fx/2d/animartrix_detail.hpp"

# 78 "../../src/fx/2d/animartrix_detail.hpp"
#pragma GCC push_options
# 78 "../../src/fx/2d/animartrix_detail.hpp"
#pragma GCC optimize ("fast-math")
# 78 "../../src/fx/2d/animartrix_detail.hpp"

# 78 "../../src/fx/2d/animartrix_detail.hpp"
#pragma GCC optimize ("tree-vectorize")
# 78 "../../src/fx/2d/animartrix_detail.hpp"

# 78 "../../src/fx/2d/animartrix_detail.hpp"
#pragma GCC optimize ("unroll-loops")
# 78 "../../src/fx/2d/animartrix_detail.hpp"


# 79 "../../src/fx/2d/animartrix_detail.hpp"
#pragma GCC push_options
# 79 "../../src/fx/2d/animartrix_detail.hpp"
#pragma GCC optimize ("O3")
# 79 "../../src/fx/2d/animartrix_detail.hpp"

# 105 "../../src/fx/2d/animartrix_detail.hpp"
namespace animartrix_detail {


struct render_parameters {



    float center_x = (999 / 2) - 0.5;
    float center_y = (999 / 2) - 0.5;
    float dist, angle;
    float scale_x = 0.1;
    float scale_y = 0.1;
    float scale_z = 0.1;
    float offset_x, offset_y, offset_z;
    float z;
    float low_limit = 0;
    float high_limit = 1;
};

struct oscillators {

    float master_speed;
    float
        offset[10];
    float ratio[10];
};

struct modulators {

    float linear[10];
    float radial[10];
    float directional[10];
    float noise_angle[10];
};

struct rgb {
    float red, green, blue;
};

static const uint8_t PERLIN_NOISE[] = {
    151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7,
    225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190,
    6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117,
    35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
    171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158,
    231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46,
    245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209,
    76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
    164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5,
    202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16,
    58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,
    154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253,
    19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97,
    228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51,
    145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184,
    84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
    222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156,
    180};

__attribute__((always_inline)) inline uint8_t P(uint8_t x) {
    const uint8_t idx = x & 255;
    const uint8_t *ptr = PERLIN_NOISE + idx;
    return *ptr;
}

class ANIMartRIX {

  public:
    int num_x;
    int num_y;

    float speed_factor = 1;

    float radial_filter_radius = 23.0;

    bool serpentine;

    render_parameters animation;
    oscillators timings;
    modulators move;
    rgb pixel;

    fl::HeapVector<fl::HeapVector<float>>
        polar_theta;
    fl::HeapVector<fl::HeapVector<float>>
        distance;

    unsigned long a, b, c;

    float show1, show2, show3, show4, show5, show6, show7, show8, show9, show0;

    ANIMartRIX() {}

    ANIMartRIX(int w, int h) { this->init(w, h); }

    virtual ~ANIMartRIX() {}

    virtual uint16_t xyMap(uint16_t x, uint16_t y) = 0;

    uint32_t currentTime = 0;
    void setTime(uint32_t t) { currentTime = t; }
    uint32_t getTime() { return currentTime ? currentTime : millis(); }

    void init(int w, int h) {
        animation = render_parameters();
        timings = oscillators();
        move = modulators();
        pixel = rgb();

        this->num_x = w;
        this->num_y = h;
        if (w <= 16) {
            this->radial_filter_radius = 11;
        } else {
            this->radial_filter_radius = 23;
        }
        render_polar_lookup_table(
            (num_x / 2) - 0.5,
            (num_y / 2) - 0.5);



        timings.master_speed = 0.01;
    }






    void setSpeedFactor(float speed) { this->speed_factor = speed; }



    float subtract(float &a, float &b) { return a - b; }

    float multiply(float &a, float &b) { return a * b / 255.f; }




    float colorburn(float &a, float &b) {

        return (1 - ((1 - a / 255.f) / (b / 255.f))) * 255.f;
    }



    float add(float &a, float &b) { return a + b; }



    float screen(float &a, float &b) {

        return (1 - (1 - a / 255.f) * (1 - b / 255.f)) * 255.f;
    }

    float colordodge(float &a, float &b) { return (a / (255.f - b)) * 255.f; }







    float fade(float t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    float lerp(float t, float a, float b) { return a + t * (b - a); }
    float grad(int hash, float x, float y, float z) {
        int h = hash & 15;
        float u = h < 8 ? x : y,
            v = h < 4 ? y
                : h == 12 || h == 14 ? x
                                     : z;
        return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
    }

    float pnoise(float x, float y, float z) {

        int X = (int)floorf(x) & 255,
            Y = (int)floorf(y) & 255,
            Z = (int)floorf(z) & 255;
        x -= floorf(x);
        y -= floorf(y);
        z -= floorf(z);
        float u = fade(x),
            v = fade(y),
            w = fade(z);
        int A = P(X) + Y, AA = P(A) + Z,
            AB = P(A + 1) + Z,
            B = P(X + 1) + Y, BA = P(B) + Z,
            BB = P(B + 1) + Z;

        return lerp(w,
                    lerp(v,
                         lerp(u, grad(P(AA), x, y, z),
                              grad(P(BA), x - 1, y, z)),
                         lerp(u, grad(P(AB), x, y - 1, z),
                              grad(P(BB), x - 1, y - 1, z))),
                    lerp(v,
                         lerp(u, grad(P(AA + 1), x, y, z - 1),
                              grad(P(BA + 1), x - 1, y, z - 1)),
                         lerp(u, grad(P(AB + 1), x, y - 1, z - 1),
                              grad(P(BB + 1), x - 1, y - 1, z - 1))));
    }

    void calculate_oscillators(oscillators &timings) {

        double runtime = getTime() * timings.master_speed *
                         speed_factor;

        for (int i = 0; i < 10; i++) {

            move.linear[i] = (runtime + timings.offset[i]) *
                             timings.ratio[i];


            move.radial[i] = fmodf(move.linear[i],
                                   2 * 3.1415926535897932384626433832795);


            move.directional[i] =
                sinf(move.radial[i]);


            move.noise_angle[i] =
                3.1415926535897932384626433832795 *
                (1 +
                 pnoise(move.linear[i], 0,
                        0));
        }
    }

    void run_default_oscillators(float master_speed = 0.005) {
        timings.master_speed = master_speed;

        timings.ratio[0] = 1;

        timings.ratio[1] = 2;
        timings.ratio[2] = 3;
        timings.ratio[3] = 4;
        timings.ratio[4] = 5;
        timings.ratio[5] = 6;
        timings.ratio[6] = 7;
        timings.ratio[7] = 8;
        timings.ratio[8] = 9;
        timings.ratio[9] = 10;

        timings.offset[0] = 000;
        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;
        timings.offset[4] = 400;
        timings.offset[5] = 500;
        timings.offset[6] = 600;
        timings.offset[7] = 700;
        timings.offset[8] = 800;
        timings.offset[9] = 900;

        calculate_oscillators(timings);
    }





    float render_value(render_parameters &animation) {



        float newx = (animation.offset_x + animation.center_x -
                      (cosf(animation.angle) * animation.dist)) *
                     animation.scale_x;
        float newy = (animation.offset_y + animation.center_y -
                      (sinf(animation.angle) * animation.dist)) *
                     animation.scale_y;
        float newz = (animation.offset_z + animation.z) * animation.scale_z;



        float raw_noise_field_value = pnoise(newx, newy, newz);






        if (raw_noise_field_value < animation.low_limit)
            raw_noise_field_value = animation.low_limit;
        if (raw_noise_field_value > animation.high_limit)
            raw_noise_field_value = animation.high_limit;

        float scaled_noise_value =
            map_float(raw_noise_field_value, animation.low_limit,
                      animation.high_limit, 0, 255);

        return scaled_noise_value;
    }




    void render_polar_lookup_table(float cx, float cy) {
        polar_theta.resize(num_x, fl::HeapVector<float>(num_y, 0.0f));
        distance.resize(num_x, fl::HeapVector<float>(num_y, 0.0f));

        for (int xx = 0; xx < num_x; xx++) {
            for (int yy = 0; yy < num_y; yy++) {

                float dx = xx - cx;
                float dy = yy - cy;

                distance[xx][yy] = hypotf(dx, dy);
                polar_theta[xx][yy] = atan2f(dy, dx);
            }
        }
    }




    float map_float(float x, float in_min, float in_max, float out_min,
                    float out_max) {

        float result =
            (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
        if (result < out_min)
            result = out_min;
        if (result > out_max)
            result = out_max;

        return result;
    }
# 457 "../../src/fx/2d/animartrix_detail.hpp"
    rgb rgb_sanity_check(rgb &pixel) {







        if (pixel.red < 0)
            pixel.red = 0;
        if (pixel.green < 0)
            pixel.green = 0;
        if (pixel.blue < 0)
            pixel.blue = 0;


        if (pixel.red > 255)
            pixel.red = 255;
        if (pixel.green > 255)
            pixel.green = 255;
        if (pixel.blue > 255)
            pixel.blue = 255;

        return pixel;
    }



    void get_ready() {
        a = micros();
        logOutput();
    }

    virtual void setPixelColorInternal(int x, int y, rgb pixel) = 0;



    void logOutput() { b = micros(); }

    void logFrame() { c = micros(); }





    void report_performance() {

        float calc = b - a;
        float push = c - b;
        float total = c - a;
        int fps = 1000000 / total;
        int kpps = (fps * num_x * num_y) / 1000;

        (void)(fps);
        (void)(" fps  ");
        (void)(kpps);
        (void)(" kpps @");
        (void)(num_x * num_y);
        (void)(" LEDs  ");
        (void)(round(total));
        (void)(" s per frame  waiting: ");
        (void)(round((calc * 100) / total));
        (void)("%  rendering: ");
        (void)(round((push * 100) / total));
        (void)("%  (");
        (void)(round(calc));
        (void)(" + ");
        (void)(round(push));
        (void)(" s)  Core-temp: ");


        (void)(" C\n");
    }



    void Rotating_Blob() {

        get_ready();

        timings.master_speed = 0.01;
        timings.ratio[0] = 0.1;
        timings.ratio[1] = 0.03;
        timings.ratio[2] = 0.03;
        timings.ratio[3] = 0.03;

        timings.offset[1] = 10;
        timings.offset[2] = 20;
        timings.offset[3] = 30;

        calculate_oscillators(
            timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {


                animation.scale_x = 0.05;
                animation.scale_y = 0.05;
                animation.offset_x = 0;
                animation.offset_y = 0;
                animation.offset_z = 100;
                animation.angle = polar_theta[x][y] + move.radial[0];
                animation.dist = distance[x][y];
                animation.z = move.linear[0];
                animation.low_limit = -1;
                float show1 = render_value(animation);

                animation.angle =
                    polar_theta[x][y] - move.radial[1] + show1 / 512.0;
                animation.dist = distance[x][y] * show1 / 255.0;
                animation.low_limit = 0;
                animation.z = move.linear[1];
                float show2 = render_value(animation);

                animation.angle =
                    polar_theta[x][y] - move.radial[2] + show1 / 512.0;
                animation.dist = distance[x][y] * show1 / 220.0;
                animation.z = move.linear[2];
                float show3 = render_value(animation);

                animation.angle =
                    polar_theta[x][y] - move.radial[3] + show1 / 512.0;
                animation.dist = distance[x][y] * show1 / 200.0;
                animation.z = move.linear[3];
                float show4 = render_value(animation);


                pixel.red = (show2 + show4) / 2;
                pixel.green = show3 / 6;
                pixel.blue = 0;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Chasing_Spirals() {

        get_ready();

        timings.master_speed = 0.01;
        timings.ratio[0] = 0.1;
        timings.ratio[1] = 0.13;
        timings.ratio[2] = 0.16;

        timings.offset[1] = 10;
        timings.offset[2] = 20;
        timings.offset[3] = 30;

        calculate_oscillators(
            timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {


                animation.angle =
                    3 * polar_theta[x][y] + move.radial[0] - distance[x][y] / 3;
                animation.dist = distance[x][y];
                animation.scale_z = 0.1;
                animation.scale_y = 0.1;
                animation.scale_x = 0.1;
                animation.offset_x = move.linear[0];
                animation.offset_y = 0;
                animation.offset_z = 0;
                animation.z = 0;
                float show1 = render_value(animation);

                animation.angle =
                    3 * polar_theta[x][y] + move.radial[1] - distance[x][y] / 3;
                animation.dist = distance[x][y];
                animation.offset_x = move.linear[1];
                float show2 = render_value(animation);

                animation.angle =
                    3 * polar_theta[x][y] + move.radial[2] - distance[x][y] / 3;
                animation.dist = distance[x][y];
                animation.offset_x = move.linear[2];
                float show3 = render_value(animation);


                float radius = radial_filter_radius;
                float radial_filter = (radius - distance[x][y]) / radius;

                pixel.red = 3 * show1 * radial_filter;
                pixel.green = show2 * radial_filter / 2;
                pixel.blue = show3 * radial_filter / 4;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Rings() {

        get_ready();

        timings.master_speed = 0.01;
        timings.ratio[0] = 1;
        timings.ratio[1] = 1.1;
        timings.ratio[2] = 1.2;

        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;

        calculate_oscillators(
            timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {


                animation.angle = 5;
                animation.scale_x = 0.2;
                animation.scale_y = 0.2;
                animation.scale_z = 1;
                animation.dist = distance[x][y];
                animation.offset_y = -move.linear[0];
                animation.offset_x = 0;
                float show1 = render_value(animation);


                animation.angle = 10;

                animation.dist = distance[x][y];
                animation.offset_y = -move.linear[1];
                float show2 = render_value(animation);


                animation.angle = 12;

                animation.dist = distance[x][y];
                animation.offset_y = -move.linear[2];
                float show3 = render_value(animation);


                pixel.red = show1;
                pixel.green = show2 / 4;
                pixel.blue = show3 / 4;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Waves() {

        get_ready();

        timings.master_speed = 0.01;
        timings.ratio[0] = 2;
        timings.ratio[1] = 2.1;
        timings.ratio[2] = 1.2;

        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;

        calculate_oscillators(
            timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {


                animation.angle = polar_theta[x][y];
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.scale_z = 0.1;
                animation.dist = distance[x][y];
                animation.offset_y = 0;
                animation.offset_x = 0;
                animation.z = 2 * distance[x][y] - move.linear[0];
                float show1 = render_value(animation);

                animation.angle = polar_theta[x][y];
                animation.dist = distance[x][y];
                animation.z = 2 * distance[x][y] - move.linear[1];
                float show2 = render_value(animation);


                pixel.red = show1;
                pixel.green = 0;
                pixel.blue = show2;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Center_Field() {

        get_ready();

        timings.master_speed = 0.01;
        timings.ratio[0] = 1;
        timings.ratio[1] = 1.1;
        timings.ratio[2] = 1.2;

        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;

        calculate_oscillators(
            timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {


                animation.angle = polar_theta[x][y];
                animation.scale_x = 0.07;
                animation.scale_y = 0.07;
                animation.scale_z = 0.1;
                animation.dist = 5 * sqrtf(distance[x][y]);
                animation.offset_y = move.linear[0];
                animation.offset_x = 0;
                animation.z = 0;
                float show1 = render_value(animation);

                animation.angle = polar_theta[x][y];
                animation.scale_x = 0.07;
                animation.scale_y = 0.07;
                animation.scale_z = 0.1;
                animation.dist = 4 * sqrtf(distance[x][y]);
                animation.offset_y = move.linear[0];
                animation.offset_x = 0;
                animation.z = 0;
                float show2 = render_value(animation);


                pixel.red = show1;
                pixel.green = show2;
                pixel.blue = 0;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Distance_Experiment() {

        get_ready();

        timings.master_speed = 0.01;
        timings.ratio[0] = 0.2;
        timings.ratio[1] = 0.13;
        timings.ratio[2] = 0.012;

        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;

        calculate_oscillators(
            timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {


                animation.dist = powf(distance[x][y], 0.5);
                animation.angle = polar_theta[x][y] + move.radial[0];
                animation.scale_x = 0.07;
                animation.scale_y = 0.07;
                animation.scale_z = 0.1;
                animation.offset_y = move.linear[0];
                animation.offset_x = 0;
                animation.offset_z = 0;
                animation.z = 0;
                float show1 = render_value(animation);

                animation.dist = powf(distance[x][y], 0.6);
                animation.angle = polar_theta[x][y] + move.noise_angle[2];
                animation.scale_x = 0.07;
                animation.scale_y = 0.07;
                animation.scale_z = 0.1;
                animation.offset_y = move.linear[1];
                animation.offset_x = 0;
                animation.offset_z = 0;
                animation.z = 0;
                float show2 = render_value(animation);


                pixel.red = show1 + show2;
                pixel.green = show2;
                pixel.blue = 0;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Caleido1() {

        get_ready();

        timings.master_speed = 0.003;
        timings.ratio[0] = 0.02;
        timings.ratio[1] = 0.03;
        timings.ratio[2] = 0.04;
        timings.ratio[3] = 0.05;
        timings.ratio[4] = 0.6;
        timings.offset[0] = 0;
        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;
        timings.offset[4] = 400;

        calculate_oscillators(
            timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {


                animation.dist = distance[x][y] * (2 + move.directional[0]) / 3;
                animation.angle = 3 * polar_theta[x][y] +
                                  3 * move.noise_angle[0] + move.radial[4];
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.scale_z = 0.1;
                animation.offset_y = 2 * move.linear[0];
                animation.offset_x = 0;
                animation.offset_z = 0;
                animation.z = move.linear[0];
                float show1 = render_value(animation);

                animation.dist = distance[x][y] * (2 + move.directional[1]) / 3;
                animation.angle = 4 * polar_theta[x][y] +
                                  3 * move.noise_angle[1] + move.radial[4];
                animation.offset_x = 2 * move.linear[1];
                animation.z = move.linear[1];
                float show2 = render_value(animation);

                animation.dist = distance[x][y] * (2 + move.directional[2]) / 3;
                animation.angle = 5 * polar_theta[x][y] +
                                  3 * move.noise_angle[2] + move.radial[4];
                animation.offset_y = 2 * move.linear[2];
                animation.z = move.linear[2];
                float show3 = render_value(animation);

                animation.dist = distance[x][y] * (2 + move.directional[3]) / 3;
                animation.angle = 4 * polar_theta[x][y] +
                                  3 * move.noise_angle[3] + move.radial[4];
                animation.offset_x = 2 * move.linear[3];
                animation.z = move.linear[3];
                float show4 = render_value(animation);


                pixel.red = show1;
                pixel.green = show3 * distance[x][y] / 10;
                pixel.blue = (show2 + show4) / 2;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Caleido2() {

        get_ready();

        timings.master_speed = 0.002;
        timings.ratio[0] = 0.02;
        timings.ratio[1] = 0.03;
        timings.ratio[2] = 0.04;
        timings.ratio[3] = 0.05;
        timings.ratio[4] = 0.6;
        timings.offset[0] = 0;
        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;
        timings.offset[4] = 400;

        calculate_oscillators(
            timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {


                animation.dist = distance[x][y] * (2 + move.directional[0]) / 3;
                animation.angle = 2 * polar_theta[x][y] +
                                  3 * move.noise_angle[0] + move.radial[4];
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.scale_z = 0.1;
                animation.offset_y = 2 * move.linear[0];
                animation.offset_x = 0;
                animation.offset_z = 0;
                animation.z = move.linear[0];
                float show1 = render_value(animation);

                animation.dist = distance[x][y] * (2 + move.directional[1]) / 3;
                animation.angle = 2 * polar_theta[x][y] +
                                  3 * move.noise_angle[1] + move.radial[4];
                animation.offset_x = 2 * move.linear[1];
                animation.z = move.linear[1];
                float show2 = render_value(animation);

                animation.dist = distance[x][y] * (2 + move.directional[2]) / 3;
                animation.angle = 2 * polar_theta[x][y] +
                                  3 * move.noise_angle[2] + move.radial[4];
                animation.offset_y = 2 * move.linear[2];
                animation.z = move.linear[2];
                float show3 = render_value(animation);

                animation.dist = distance[x][y] * (2 + move.directional[3]) / 3;
                animation.angle = 2 * polar_theta[x][y] +
                                  3 * move.noise_angle[3] + move.radial[4];
                animation.offset_x = 2 * move.linear[3];
                animation.z = move.linear[3];
                float show4 = render_value(animation);


                pixel.red = show1;
                pixel.green = show3 * distance[x][y] / 10;
                pixel.blue = (show2 + show4) / 2;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Caleido3() {

        get_ready();

        timings.master_speed = 0.004;
        timings.ratio[0] = 0.02;
        timings.ratio[1] = 0.03;
        timings.ratio[2] = 0.04;
        timings.ratio[3] = 0.05;
        timings.ratio[4] = 0.6;
        timings.offset[0] = 0;
        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;
        timings.offset[4] = 400;

        calculate_oscillators(
            timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {


                animation.dist = distance[x][y] * (2 + move.directional[0]) / 3;
                animation.angle = 2 * polar_theta[x][y] +
                                  3 * move.noise_angle[0] + move.radial[4];
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.scale_z = 0.1;
                animation.offset_y = 2 * move.linear[0];
                animation.offset_x = 2 * move.linear[1];
                animation.offset_z = 0;
                animation.z = move.linear[0];
                float show1 = render_value(animation);

                animation.dist = distance[x][y] * (2 + move.directional[1]) / 3;
                animation.angle = 2 * polar_theta[x][y] +
                                  3 * move.noise_angle[1] + move.radial[4];
                animation.offset_x = 2 * move.linear[1];
                animation.offset_y = show1 / 20.0;
                animation.z = move.linear[1];
                float show2 = render_value(animation);

                animation.dist = distance[x][y] * (2 + move.directional[2]) / 3;
                animation.angle = 2 * polar_theta[x][y] +
                                  3 * move.noise_angle[2] + move.radial[4];
                animation.offset_y = 2 * move.linear[2];
                animation.offset_x = show2 / 20.0;
                animation.z = move.linear[2];
                float show3 = render_value(animation);

                animation.dist = distance[x][y] * (2 + move.directional[3]) / 3;
                animation.angle = 2 * polar_theta[x][y] +
                                  3 * move.noise_angle[3] + move.radial[4];
                animation.offset_x = 2 * move.linear[3];
                animation.offset_y = show3 / 20.0;
                animation.z = move.linear[3];
                float show4 = render_value(animation);


                float radius = radial_filter_radius;

                pixel.red = show1 * (y + 1) / num_y;
                pixel.green = show3 * distance[x][y] / 10;
                pixel.blue = (show2 + show4) / 2;
                if (distance[x][y] > radius) {
                    pixel.red = 0;
                    pixel.green = 0;
                    pixel.blue = 0;
                }

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Lava1() {

        get_ready();

        timings.master_speed = 0.0015;
        timings.ratio[0] = 4;
        timings.ratio[1] = 1;
        timings.ratio[2] = 1;
        timings.ratio[3] = 0.05;
        timings.ratio[4] = 0.6;
        timings.offset[0] = 0;
        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;
        timings.offset[4] = 400;

        calculate_oscillators(
            timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {


                animation.dist = distance[x][y] * 0.8;
                animation.angle = polar_theta[x][y];
                animation.scale_x = 0.15;
                animation.scale_y = 0.12;
                animation.scale_z = 0.01;
                animation.offset_y = -move.linear[0];
                animation.offset_x = 0;
                animation.offset_z = 0;
                animation.z = 30;
                float show1 = render_value(animation);

                animation.offset_y = -move.linear[1];
                animation.scale_x = 0.15;
                animation.scale_y = 0.12;
                animation.offset_x = show1 / 100;
                animation.offset_y += show1 / 100;

                float show2 = render_value(animation);

                animation.offset_y = -move.linear[2];
                animation.scale_x = 0.15;
                animation.scale_y = 0.12;
                animation.offset_x = show2 / 100;
                animation.offset_y += show2 / 100;

                float show3 = render_value(animation);


                float linear = (y) / (num_y - 1.f);

                pixel.red = linear * show2;
                pixel.green = 0.1 * linear * (show2 - show3);
                pixel.blue = 0;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Scaledemo1() {

        get_ready();

        timings.master_speed = 0.000001;
        timings.ratio[0] = 0.4;
        timings.ratio[1] = 0.32;
        timings.ratio[2] = 0.10;
        timings.ratio[3] = 0.05;
        timings.ratio[4] = 0.6;
        timings.offset[0] = 0;
        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;
        timings.offset[4] = 400;

        calculate_oscillators(
            timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {


                animation.dist = 0.3 * distance[x][y] * 0.8;
                animation.angle = 3 * polar_theta[x][y] + move.radial[2];
                animation.scale_x = 0.1 + (move.noise_angle[0]) / 10;
                animation.scale_y =
                    0.1 + (move.noise_angle[1]) /
                              10;
                animation.scale_z = 0.01;
                animation.offset_y = 0;
                animation.offset_x = 0;
                animation.offset_z = 100 * move.linear[0];
                animation.z = 30;
                float show1 = render_value(animation);

                animation.angle = 3;
                float show2 = render_value(animation);

                float dist = 1;
                pixel.red = show1 * dist;
                pixel.green = (show1 - show2) * dist * 0.3;
                pixel.blue = (show2 - show1) * dist;

                if (distance[x][y] > 16) {
                    pixel.red = 0;
                    pixel.green = 0;
                    pixel.blue = 0;
                }

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Yves() {

        get_ready();

        a = micros();

        timings.master_speed = 0.001;
        timings.ratio[0] = 3;
        timings.ratio[1] = 2;
        timings.ratio[2] = 1;
        timings.ratio[3] = 0.13;
        timings.ratio[4] = 0.15;
        timings.ratio[5] = 0.03;
        timings.ratio[6] = 0.025;
        timings.offset[0] = 0;
        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;
        timings.offset[4] = 400;
        timings.offset[5] = 500;
        timings.offset[6] = 600;

        calculate_oscillators(
            timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle =
                    polar_theta[x][y] + 2 * 3.1415926535897932384626433832795 + move.noise_angle[5];
                animation.scale_x = 0.08;
                animation.scale_y = 0.08;
                animation.scale_z = 0.08;
                animation.offset_y = -move.linear[0];
                animation.offset_x = 0;
                animation.offset_z = 0;
                animation.z = 0;
                float show1 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle =
                    polar_theta[x][y] + 2 * 3.1415926535897932384626433832795 + move.noise_angle[6];
                ;
                animation.scale_x = 0.08;
                animation.scale_y = 0.08;
                animation.scale_z = 0.08;
                animation.offset_y = -move.linear[1];
                animation.offset_x = 0;
                animation.offset_z = 0;
                animation.z = 0;
                float show2 = render_value(animation);

                animation.angle = polar_theta[x][y] + show1 / 100 +
                                  move.noise_angle[3] + move.noise_angle[4];
                animation.dist = distance[x][y] + show2 / 50;
                animation.offset_y = -move.linear[2];

                animation.offset_y += show1 / 100;
                animation.offset_x += show2 / 100;

                float show3 = render_value(animation);

                animation.offset_y = 0;
                animation.offset_x = 0;

                float show4 = render_value(animation);

                pixel.red = show3;
                pixel.green = show3 * show4 / 255;
                pixel.blue = 0;

                pixel = rgb_sanity_check(pixel);
                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Spiralus() {

        get_ready();

        timings.master_speed = 0.0011;
        timings.ratio[0] = 1.5;
        timings.ratio[1] = 2.3;
        timings.ratio[2] = 3;
        timings.ratio[3] = 0.05;
        timings.ratio[4] = 0.2;
        timings.ratio[5] = 0.03;
        timings.ratio[6] = 0.025;
        timings.ratio[7] = 0.021;
        timings.ratio[8] = 0.027;
        timings.offset[0] = 0;
        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;
        timings.offset[4] = 400;
        timings.offset[5] = 500;
        timings.offset[6] = 600;

        calculate_oscillators(
            timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle = 2 * polar_theta[x][y] + move.noise_angle[5] +
                                  move.directional[3] * move.noise_angle[6] *
                                      animation.dist / 10;
                animation.scale_x = 0.08;
                animation.scale_y = 0.08;
                animation.scale_z = 0.02;
                animation.offset_y = -move.linear[0];
                animation.offset_x = 0;
                animation.offset_z = 0;
                animation.z = move.linear[1];
                float show1 = render_value(animation);

                animation.angle = 2 * polar_theta[x][y] + move.noise_angle[7] +
                                  move.directional[5] * move.noise_angle[8] *
                                      animation.dist / 10;
                animation.offset_y = -move.linear[1];
                animation.z = move.linear[2];

                float show2 = render_value(animation);

                animation.angle = 2 * polar_theta[x][y] + move.noise_angle[6] +
                                  move.directional[6] * move.noise_angle[7] *
                                      animation.dist / 10;
                animation.offset_y = move.linear[2];
                animation.z = move.linear[0];
                float show3 = render_value(animation);

                float f = 1;

                pixel.red = f * (show1 + show2);
                pixel.green = f * (show1 - show2);
                pixel.blue = f * (show3 - show1);

                pixel = rgb_sanity_check(pixel);
                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Spiralus2() {

        get_ready();

        timings.master_speed = 0.0015;
        timings.ratio[0] = 1.5;
        timings.ratio[1] = 2.3;
        timings.ratio[2] = 3;
        timings.ratio[3] = 0.05;
        timings.ratio[4] = 0.2;
        timings.ratio[5] = 0.05;
        timings.ratio[6] = 0.055;
        timings.ratio[7] = 0.06;
        timings.ratio[8] = 0.027;
        timings.offset[0] = 0;
        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;
        timings.offset[4] = 400;
        timings.offset[5] = 500;
        timings.offset[6] = 600;

        calculate_oscillators(
            timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle = 5 * polar_theta[x][y] + move.noise_angle[5] +
                                  move.directional[3] * move.noise_angle[6] *
                                      animation.dist / 10;
                animation.scale_x = 0.08;
                animation.scale_y = 0.08;
                animation.scale_z = 0.02;
                animation.offset_y = -move.linear[0];
                animation.offset_x = 0;
                animation.offset_z = 0;
                animation.z = move.linear[1];
                float show1 = render_value(animation);

                animation.angle = 6 * polar_theta[x][y] + move.noise_angle[7] +
                                  move.directional[5] * move.noise_angle[8] *
                                      animation.dist / 10;
                animation.offset_y = -move.linear[1];
                animation.z = move.linear[2];

                float show2 = render_value(animation);

                animation.angle = 6 * polar_theta[x][y] + move.noise_angle[6] +
                                  move.directional[6] * move.noise_angle[7] *
                                      animation.dist / 10;
                animation.offset_y = move.linear[2];
                animation.z = move.linear[0];
                animation.dist = distance[x][y] * 0.8;
                float show3 = render_value(animation);

                float f = 1;

                pixel.red = f * (show1 + show2);
                pixel.green = f * (show1 - show2);
                pixel.blue = f * (show3 - show1);

                pixel = rgb_sanity_check(pixel);
                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Hot_Blob() {

        get_ready();
        run_default_oscillators(0.001);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y];

                animation.scale_x = 0.07 + move.directional[0] * 0.002;
                animation.scale_y = 0.07;

                animation.offset_y = -move.linear[0];
                animation.offset_x = 0;
                animation.offset_z = 0;

                animation.z = 0;
                animation.low_limit = -1;
                float show1 = render_value(animation);

                animation.offset_y = -move.linear[1];
                float show3 = render_value(animation);

                animation.offset_x = show3 / 20;
                animation.offset_y = -move.linear[0] / 2 + show1 / 70;
                animation.low_limit = 0;
                float show2 = render_value(animation);

                animation.offset_x = show3 / 20;
                animation.offset_y = -move.linear[0] / 2 + show1 / 70;
                animation.z = 100;
                float show4 = render_value(animation);

                float radius = radial_filter_radius;

                float radial = (radius - animation.dist) / animation.dist;

                float linear = (y + 1) / (num_y - 1.f);

                pixel.red = radial * show2;
                pixel.green = linear * radial * 0.3 * (show2 - show4);
                pixel.blue = 0;

                pixel = rgb_sanity_check(pixel);
                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Zoom() {

        get_ready();

        run_default_oscillators();
        timings.master_speed = 0.003;
        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = (distance[x][y] * distance[x][y]) / 2;
                animation.angle = polar_theta[x][y];

                animation.scale_x = 0.005;
                animation.scale_y = 0.005;

                animation.offset_y = -10 * move.linear[0];
                animation.offset_x = 0;
                animation.offset_z = 0;

                animation.z = 0;
                animation.low_limit = 0;
                float show1 = render_value(animation);

                float linear = 1;

                pixel.red = show1 * linear;
                pixel.green = 0;
                pixel.blue = 0;

                pixel = rgb_sanity_check(pixel);
                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Slow_Fade() {

        get_ready();

        run_default_oscillators();
        timings.master_speed = 0.00005;
        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist =
                    sqrtf(distance[x][y]) * 0.7 * (move.directional[0] + 1.5);
                animation.angle =
                    polar_theta[x][y] - move.radial[0] + distance[x][y] / 5;

                animation.scale_x = 0.11;
                animation.scale_y = 0.11;

                animation.offset_y = -50 * move.linear[0];
                animation.offset_x = 0;
                animation.offset_z = 0;

                animation.z = move.linear[0];
                animation.low_limit = -0.1;
                animation.high_limit = 1;
                float show1 = render_value(animation);

                animation.dist = animation.dist * 1.1;
                animation.angle += move.noise_angle[0] / 10;
                float show2 = render_value(animation);

                animation.dist = animation.dist * 1.1;
                animation.angle += move.noise_angle[1] / 10;

                float show3 = render_value(animation);

                float radius = radial_filter_radius;

                float radial = (radius - distance[x][y]) / distance[x][y];

                pixel.red = radial * show1;
                pixel.green = radial * (show1 - show2) / 6;
                pixel.blue = radial * (show1 - show3) / 5;

                pixel = rgb_sanity_check(pixel);
                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Polar_Waves() {

        get_ready();

        timings.master_speed = 0.5;

        timings.ratio[0] = 0.0025;

        timings.ratio[1] = 0.0027;
        timings.ratio[2] = 0.0031;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = (distance[x][y]);
                animation.angle =
                    polar_theta[x][y] - animation.dist * 0.1 + move.radial[0];
                animation.z = (animation.dist * 1.5) - 10 * move.linear[0];
                animation.scale_x = 0.15;
                animation.scale_y = 0.15;
                animation.offset_x = move.linear[0];

                float show1 = render_value(animation);
                animation.angle =
                    polar_theta[x][y] - animation.dist * 0.1 + move.radial[1];
                animation.z = (animation.dist * 1.5) - 10 * move.linear[1];
                animation.offset_x = move.linear[1];

                float show2 = render_value(animation);
                animation.angle =
                    polar_theta[x][y] - animation.dist * 0.1 + move.radial[2];
                animation.z = (animation.dist * 1.5) - 10 * move.linear[2];
                animation.offset_x = move.linear[2];

                float show3 = render_value(animation);

                float radius = radial_filter_radius;

                float radial = (radius - distance[x][y]) / distance[x][y];

                pixel.red = radial * show1;
                pixel.green = radial * show2;
                pixel.blue = radial * show3;

                pixel = rgb_sanity_check(pixel);
                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void RGB_Blobs() {

        get_ready();

        timings.master_speed = 0.2;

        timings.ratio[0] = 0.0025;

        timings.ratio[1] = 0.0027;
        timings.ratio[2] = 0.0031;
        timings.ratio[3] = 0.0033;

        timings.ratio[4] = 0.0036;
        timings.ratio[5] = 0.0039;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y] + move.radial[0] +
                                  move.noise_angle[0] + move.noise_angle[3];
                animation.z = (sqrtf(animation.dist));
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = 10;
                animation.offset_x = 10 * move.linear[0];
                float show1 = render_value(animation);

                animation.angle = polar_theta[x][y] + move.radial[1] +
                                  move.noise_angle[1] + move.noise_angle[4];
                animation.offset_x = 11 * move.linear[1];
                animation.offset_z = 100;
                float show2 = render_value(animation);

                animation.angle = polar_theta[x][y] + move.radial[2] +
                                  move.noise_angle[2] + move.noise_angle[5];
                animation.offset_x = 12 * move.linear[2];
                animation.offset_z = 300;
                float show3 = render_value(animation);

                float radius = radial_filter_radius;

                float radial = (radius - distance[x][y]) / distance[x][y];

                pixel.red = radial * show1;
                pixel.green = radial * show2;
                pixel.blue = radial * show3;

                pixel = rgb_sanity_check(pixel);
                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void RGB_Blobs2() {

        get_ready();

        timings.master_speed = 0.12;

        timings.ratio[0] = 0.0025;

        timings.ratio[1] = 0.0027;
        timings.ratio[2] = 0.0031;
        timings.ratio[3] = 0.0033;

        timings.ratio[4] = 0.0036;
        timings.ratio[5] = 0.0039;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y] + move.radial[0] +
                                  move.noise_angle[0] + move.noise_angle[3] +
                                  move.noise_angle[1];
                animation.z = (sqrtf(animation.dist));
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = 10;
                animation.offset_x = 10 * move.linear[0];
                float show1 = render_value(animation);

                animation.angle = polar_theta[x][y] + move.radial[1] +
                                  move.noise_angle[1] + move.noise_angle[4] +
                                  move.noise_angle[2];
                animation.offset_x = 11 * move.linear[1];
                animation.offset_z = 100;
                float show2 = render_value(animation);

                animation.angle = polar_theta[x][y] + move.radial[2] +
                                  move.noise_angle[2] + move.noise_angle[5] +
                                  move.noise_angle[3];
                animation.offset_x = 12 * move.linear[2];
                animation.offset_z = 300;
                float show3 = render_value(animation);

                float radius = radial_filter_radius;

                float radial = (radius - distance[x][y]) / distance[x][y];

                pixel.red = radial * (show1 - show3);
                pixel.green = radial * (show2 - show1);
                pixel.blue = radial * (show3 - show2);

                pixel = rgb_sanity_check(pixel);
                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void RGB_Blobs3() {

        get_ready();

        timings.master_speed = 0.12;

        timings.ratio[0] = 0.0025;

        timings.ratio[1] = 0.0027;
        timings.ratio[2] = 0.0031;
        timings.ratio[3] = 0.0033;

        timings.ratio[4] = 0.0036;
        timings.ratio[5] = 0.0039;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y] + move.noise_angle[4];
                animation.angle = polar_theta[x][y] + move.radial[0] +
                                  move.noise_angle[0] + move.noise_angle[3] +
                                  move.noise_angle[1];
                animation.z = (sqrtf(animation.dist));
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = 10;
                animation.offset_x = 10 * move.linear[0];
                float show1 = render_value(animation);

                animation.angle = polar_theta[x][y] + move.radial[1] +
                                  move.noise_angle[1] + move.noise_angle[4] +
                                  move.noise_angle[2];
                animation.offset_x = 11 * move.linear[1];
                animation.offset_z = 100;
                float show2 = render_value(animation);

                animation.angle = polar_theta[x][y] + move.radial[2] +
                                  move.noise_angle[2] + move.noise_angle[5] +
                                  move.noise_angle[3];
                animation.offset_x = 12 * move.linear[2];
                animation.offset_z = 300;
                float show3 = render_value(animation);

                float radius = radial_filter_radius;

                float radial = (radius - distance[x][y]) / distance[x][y];

                pixel.red = radial * (show1 + show3) * 0.5 * animation.dist / 5;
                pixel.green = radial * (show2 + show1) * 0.5 * y / 15;
                pixel.blue = radial * (show3 + show2) * 0.5 * x / 15;

                pixel = rgb_sanity_check(pixel);
                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void RGB_Blobs4() {

        get_ready();

        timings.master_speed = 0.02;

        timings.ratio[0] = 0.0025;

        timings.ratio[1] = 0.0027;
        timings.ratio[2] = 0.0031;
        timings.ratio[3] = 0.0033;

        timings.ratio[4] = 0.0036;
        timings.ratio[5] = 0.0039;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y] + move.noise_angle[4];
                animation.angle = polar_theta[x][y] + move.radial[0] +
                                  move.noise_angle[0] + move.noise_angle[3] +
                                  move.noise_angle[1];
                animation.z = 3 + sqrtf(animation.dist);
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = 10;
                animation.offset_x = 50 * move.linear[0];
                float show1 = render_value(animation);

                animation.angle = polar_theta[x][y] + move.radial[1] +
                                  move.noise_angle[1] + move.noise_angle[4] +
                                  move.noise_angle[2];
                animation.offset_x = 50 * move.linear[1];
                animation.offset_z = 100;
                float show2 = render_value(animation);

                animation.angle = polar_theta[x][y] + move.radial[2] +
                                  move.noise_angle[2] + move.noise_angle[5] +
                                  move.noise_angle[3];
                animation.offset_x = 50 * move.linear[2];
                animation.offset_z = 300;
                float show3 = render_value(animation);

                float radius = 23;
                float radial = (radius - distance[x][y]) / distance[x][y];

                pixel.red = radial * (show1 + show3) * 0.5 * animation.dist / 5;
                pixel.green = radial * (show2 + show1) * 0.5 * y / 15;
                pixel.blue = radial * (show3 + show2) * 0.5 * x / 15;

                pixel = rgb_sanity_check(pixel);
                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void RGB_Blobs5() {

        get_ready();

        timings.master_speed = 0.02;

        timings.ratio[0] = 0.0025;

        timings.ratio[1] = 0.0027;
        timings.ratio[2] = 0.0031;
        timings.ratio[3] = 0.0033;

        timings.ratio[4] = 0.0036;
        timings.ratio[5] = 0.0039;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y] + move.noise_angle[4];
                animation.angle = polar_theta[x][y] + move.radial[0] +
                                  move.noise_angle[0] + move.noise_angle[3] +
                                  move.noise_angle[1];
                animation.z = 3 + sqrtf(animation.dist);
                animation.scale_x = 0.05;
                animation.scale_y = 0.05;
                animation.offset_z = 10;
                animation.offset_x = 50 * move.linear[0];
                float show1 = render_value(animation);

                animation.angle = polar_theta[x][y] + move.radial[1] +
                                  move.noise_angle[1] + move.noise_angle[4] +
                                  move.noise_angle[2];
                animation.offset_x = 50 * move.linear[1];
                animation.offset_z = 100;
                float show2 = render_value(animation);

                animation.angle = polar_theta[x][y] + move.radial[2] +
                                  move.noise_angle[2] + move.noise_angle[5] +
                                  move.noise_angle[3];
                animation.offset_x = 50 * move.linear[2];
                animation.offset_z = 300;
                float show3 = render_value(animation);

                float radius = 23;
                float radial = (radius - distance[x][y]) / distance[x][y];

                pixel.red = radial * (show1 + show3) * 0.5 * animation.dist / 5;
                pixel.green = radial * (show2 + show1) * 0.5 * y / 15;
                pixel.blue = radial * (show3 + show2) * 0.5 * x / 15;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Big_Caleido() {

        get_ready();

        timings.master_speed = 0.02;

        timings.ratio[0] = 0.0025;

        timings.ratio[1] = 0.0027;
        timings.ratio[2] = 0.0031;
        timings.ratio[3] = 0.0033;

        timings.ratio[4] = 0.0036;
        timings.ratio[5] = 0.0039;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle = 5 * polar_theta[x][y] +
                                  5 * move.noise_angle[0] +
                                  animation.dist * 0.1;
                animation.z = 5;
                animation.scale_x = 0.05;
                animation.scale_y = 0.05;
                animation.offset_z = 50 * move.linear[0];
                animation.offset_x = 50 * move.noise_angle[0];
                animation.offset_y = 50 * move.noise_angle[1];
                float show1 = render_value(animation);

                animation.angle = 6 * polar_theta[x][y] +
                                  5 * move.noise_angle[1] +
                                  animation.dist * 0.15;
                animation.z = 5;
                animation.scale_x = 0.05;
                animation.scale_y = 0.05;
                animation.offset_z = 50 * move.linear[1];
                animation.offset_x = 50 * move.noise_angle[1];
                animation.offset_y = 50 * move.noise_angle[2];
                float show2 = render_value(animation);

                animation.angle = 5;
                animation.z = 5;
                animation.scale_x = 0.10;
                animation.scale_y = 0.10;
                animation.offset_z = 10 * move.linear[2];
                animation.offset_x = 10 * move.noise_angle[2];
                animation.offset_y = 10 * move.noise_angle[3];
                float show3 = render_value(animation);

                animation.angle = 15;
                animation.z = 15;
                animation.scale_x = 0.10;
                animation.scale_y = 0.10;
                animation.offset_z = 10 * move.linear[3];
                animation.offset_x = 10 * move.noise_angle[3];
                animation.offset_y = 10 * move.noise_angle[4];
                float show4 = render_value(animation);

                animation.angle = 2;
                animation.z = 15;
                animation.scale_x = 0.15;
                animation.scale_y = 0.15;
                animation.offset_z = 10 * move.linear[4];
                animation.offset_x = 10 * move.noise_angle[4];
                animation.offset_y = 10 * move.noise_angle[5];
                float show5 = render_value(animation);

                pixel.red = show1 - show4;
                pixel.green = show2 - show5;
                pixel.blue = show3 - show2 + show1;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }

    }

    void SM1() {

        get_ready();

        timings.master_speed = 0.02;

        timings.ratio[0] = 0.0025;

        timings.ratio[1] = 0.0027;
        timings.ratio[2] = 0.0031;
        timings.ratio[3] = 0.0033;

        timings.ratio[4] = 0.0036;
        timings.ratio[5] = 0.0039;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x / 2; x++) {
            for (int y = 0; y < num_y / 2; y++) {

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y] + 5 * move.noise_angle[0];
                animation.z = 5;
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = 50 * move.linear[0];
                animation.offset_x = 150 * move.directional[0];
                animation.offset_y = 150 * move.directional[1];
                float show1 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y] + 4 * move.noise_angle[1];
                animation.z = 15;
                animation.scale_x = 0.15;
                animation.scale_y = 0.15;
                animation.offset_z = 50 * move.linear[1];
                animation.offset_x = 150 * move.directional[1];
                animation.offset_y = 150 * move.directional[2];
                float show2 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y] + 5 * move.noise_angle[2];
                animation.z = 25;
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = 50 * move.linear[2];
                animation.offset_x = 150 * move.directional[2];
                animation.offset_y = 150 * move.directional[3];
                float show3 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y] + 5 * move.noise_angle[3];
                animation.z = 35;
                animation.scale_x = 0.15;
                animation.scale_y = 0.15;
                animation.offset_z = 50 * move.linear[3];
                animation.offset_x = 150 * move.directional[3];
                animation.offset_y = 150 * move.directional[4];
                float show4 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y] + 5 * move.noise_angle[4];
                animation.z = 45;
                animation.scale_x = 0.2;
                animation.scale_y = 0.2;
                animation.offset_z = 50 * move.linear[4];
                animation.offset_x = 150 * move.directional[4];
                animation.offset_y = 150 * move.directional[5];
                float show5 = render_value(animation);

                pixel.red = show1 + show2;
                pixel.green = show3 + show4;
                pixel.blue = show5;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);

                setPixelColorInternal((num_x - 1) - x, y, pixel);
                setPixelColorInternal((num_x - 1) - x, (num_y - 1) - y, pixel);
                setPixelColorInternal(x, (num_y - 1) - y, pixel);
            }
        }

    }

    void SM2() {

        get_ready();

        timings.master_speed = 0.03;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.0033;

        timings.ratio[4] = 0.0036;
        timings.ratio[5] = 0.0039;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y] * (move.directional[0]);
                animation.angle = polar_theta[x][y] + move.radial[0];
                animation.z = 5;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_z = 5 * move.linear[0];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show1 = render_value(animation);

                animation.dist = distance[x][y] * move.directional[1];
                animation.angle = polar_theta[x][y] + move.radial[1];
                animation.z = 50;
                animation.scale_x = 0.07;
                animation.scale_y = 0.07;
                animation.offset_z = 5 * move.linear[1];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show2 = render_value(animation);

                animation.dist = distance[x][y] * move.directional[2];
                animation.angle = polar_theta[x][y] + move.radial[2];
                animation.z = 500;
                animation.scale_x = 0.05;
                animation.scale_y = 0.05;
                animation.offset_z = 5 * move.linear[2];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show3 = render_value(animation);

                pixel.red = show1;
                pixel.green = show2;
                pixel.blue = show3;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }

    }

    void SM3() {

        get_ready();

        timings.master_speed = 0.02;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.0033;

        timings.ratio[4] = 0.0036;
        timings.ratio[5] = 0.0039;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y];
                animation.z = 5;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_z = 0;
                animation.offset_x = 0;
                animation.offset_y = -20 * move.linear[0];
                ;
                animation.low_limit = -1;
                animation.high_limit = 1;
                show1 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y];
                animation.z = 500;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_z = 0;
                animation.offset_x = 0;
                animation.offset_y = -20 * move.linear[0];
                ;
                animation.low_limit = -1;
                animation.high_limit = 1;
                show2 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y];
                animation.z = 50;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_z = 0;
                animation.offset_x = 500 + show1 / 20;
                animation.offset_y = -4 * move.linear[0] + show2 / 20;
                animation.low_limit = 0;
                animation.high_limit = 1;
                show3 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y];
                animation.z = 50;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_z = 0;
                animation.offset_x = 500 + show1 / 18;
                animation.offset_y = -4 * move.linear[0] + show2 / 18;
                animation.low_limit = 0;
                animation.high_limit = 1;
                show4 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y];
                animation.z = 50;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_z = 0;
                animation.offset_x = 500 + show1 / 19;
                animation.offset_y = -4 * move.linear[0] + show2 / 19;
                animation.low_limit = 0.3;
                animation.high_limit = 1;
                show5 = render_value(animation);

                pixel.red = show4;
                pixel.green = show3;
                pixel.blue = show5;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void SM4() {

        get_ready();

        timings.master_speed = 0.02;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.0033;

        timings.ratio[4] = 0.0036;
        timings.ratio[5] = 0.0039;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y];
                animation.z = 5;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_z = 0;
                animation.offset_x = 0;
                animation.offset_y = -20 * move.linear[0];
                ;
                animation.low_limit = 0;
                animation.high_limit = 1;
                show1 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y];
                animation.z = 500;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_z = 0;
                animation.offset_x = 0;
                animation.offset_y = -40 * move.linear[0];
                ;
                animation.low_limit = 0;
                animation.high_limit = 1;
                show2 = render_value(animation);

                pixel.red = add(show2, show1);
                pixel.green = 0;
                pixel.blue = colordodge(show2, show1);

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void SM5() {

        get_ready();

        timings.master_speed = 0.03;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.0053;

        timings.ratio[4] = 0.0056;
        timings.ratio[5] = 0.0059;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y] * (move.directional[0]);
                animation.angle = polar_theta[x][y] + move.radial[0];
                animation.z = 5;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_z = 5 * move.linear[0];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show1 = render_value(animation);

                animation.dist = distance[x][y] * move.directional[1];
                animation.angle = polar_theta[x][y] + move.radial[1];
                animation.z = 50;
                animation.scale_x = 0.07;
                animation.scale_y = 0.07;
                animation.offset_z = 5 * move.linear[1];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show2 = render_value(animation);

                animation.dist = distance[x][y] * move.directional[2];
                animation.angle = polar_theta[x][y] + move.radial[2];
                animation.z = 500;
                animation.scale_x = 0.05;
                animation.scale_y = 0.05;
                animation.offset_z = 5 * move.linear[2];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show3 = render_value(animation);

                animation.dist = distance[x][y] * (move.directional[3]);
                animation.angle = polar_theta[x][y] + move.radial[3];
                animation.z = 5;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_z = 5 * move.linear[3];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show4 = render_value(animation);

                animation.dist = distance[x][y] * move.directional[4];
                animation.angle = polar_theta[x][y] + move.radial[4];
                animation.z = 50;
                animation.scale_x = 0.07;
                animation.scale_y = 0.07;
                animation.offset_z = 5 * move.linear[4];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show5 = render_value(animation);

                animation.dist = distance[x][y] * move.directional[5];
                animation.angle = polar_theta[x][y] + move.radial[5];
                animation.z = 500;
                animation.scale_x = 0.05;
                animation.scale_y = 0.05;
                animation.offset_z = 5 * move.linear[5];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show6 = render_value(animation);

                float radius = radial_filter_radius;

                float radial = (radius - distance[x][y]) / distance[x][y];

                pixel.red = radial * add(show1, show4);
                pixel.green = radial * colordodge(show2, show5);
                pixel.blue = radial * screen(show3, show6);

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void SM6() {

        get_ready();

        timings.master_speed = 0.03;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.0053;

        timings.ratio[4] = 0.0056;
        timings.ratio[5] = 0.0059;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                float s = 0.7;

                animation.dist = distance[x][y] * (move.directional[0]) * s;
                animation.angle = polar_theta[x][y] + move.radial[0];
                animation.z = 5;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_z = 5 * move.linear[0];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show1 = render_value(animation);

                animation.dist = distance[x][y] * move.directional[1] * s;
                animation.angle = polar_theta[x][y] + move.radial[1];
                animation.z = 50;
                animation.scale_x = 0.07;
                animation.scale_y = 0.07;
                animation.offset_z = 5 * move.linear[1];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show2 = render_value(animation);

                animation.dist = distance[x][y] * move.directional[2] * s;
                animation.angle = polar_theta[x][y] + move.radial[2];
                animation.z = 500;
                animation.scale_x = 0.05;
                animation.scale_y = 0.05;
                animation.offset_z = 5 * move.linear[2];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show3 = render_value(animation);

                animation.dist = distance[x][y] * (move.directional[3]) * s;
                animation.angle = polar_theta[x][y] + move.radial[3];
                animation.z = 5;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_z = 5 * move.linear[3];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show4 = render_value(animation);

                animation.dist = distance[x][y] * move.directional[4] * s;
                animation.angle = polar_theta[x][y] + move.radial[4];
                animation.z = 50;
                animation.scale_x = 0.07;
                animation.scale_y = 0.07;
                animation.offset_z = 5 * move.linear[4];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show5 = render_value(animation);

                animation.dist = distance[x][y] * move.directional[5] * s;
                animation.angle = polar_theta[x][y] + move.radial[5];
                animation.z = 500;
                animation.scale_x = 0.05;
                animation.scale_y = 0.05;
                animation.offset_z = 5 * move.linear[5];
                animation.offset_x = 0;
                animation.offset_y = 0;
                float show6 = render_value(animation);

                float radius = radial_filter_radius;

                float radial = (radius - distance[x][y]) / distance[x][y];

                show7 = screen(show1, show4);
                show8 = colordodge(show2, show5);
                show9 = screen(show3, show6);

                pixel.red = radial * (show7 + show8);
                pixel.green = 0;
                pixel.blue = radial * show9;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void SM8() {

        get_ready();

        timings.master_speed = 0.005;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.0053;

        timings.ratio[4] = 0.0056;
        timings.ratio[5] = 0.01;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {



                animation.dist = distance[x][y];
                animation.angle = 2;
                animation.z = 5;
                animation.scale_x = 0.15;
                animation.scale_y = 0.15;
                animation.offset_z = 0;
                animation.offset_y = 50 * move.linear[0];
                animation.offset_x = 0;
                animation.low_limit = 0;
                float show1 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = 2;
                animation.z = 150;
                animation.offset_x = -50 * move.linear[0];
                float show2 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = 1;
                animation.z = 550;
                animation.scale_x = 0.15;
                animation.scale_y = 0.15;
                animation.offset_x = 0;
                animation.offset_y = -50 * move.linear[1];
                float show4 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = 1;
                animation.z = 1250;
                animation.scale_x = 0.15;
                animation.scale_y = 0.15;
                animation.offset_x = 0;
                animation.offset_y = 50 * move.linear[1];
                float show5 = render_value(animation);





                show3 = add(show1, show2);
                show6 = screen(show4, show5);


                pixel.red = show3;
                pixel.green = 0;
                pixel.blue = show6;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void SM9() {

        get_ready();

        timings.master_speed = 0.005;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.0053;

        timings.ratio[4] = 0.0056;
        timings.ratio[5] = 0.0059;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y];
                animation.z = 5;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_y = -30 * move.linear[0];
                animation.offset_z = 0;
                animation.offset_x = 0;
                animation.low_limit = -1;
                show1 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y];
                animation.z = 50;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_y = -30 * move.linear[1];
                animation.offset_z = 0;
                animation.offset_x = 0;
                animation.low_limit = -1;
                show2 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y] + 2 + (show1 / 255) * 3.1415926535897932384626433832795;
                animation.z = 5;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_y = -10 * move.linear[0];
                animation.offset_z = 0;
                animation.offset_x = 0;
                animation.low_limit = 0;
                show3 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y] + 2 + (show2 / 255) * 3.1415926535897932384626433832795;
                ;
                animation.z = 5;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_y = -20 * move.linear[0];
                animation.offset_z = 0;
                animation.offset_x = 0;
                animation.low_limit = 0;
                show4 = render_value(animation);

                show5 = screen(show4, show3);
                show6 = colordodge(show5, show3);

                float linear1 = y / 32.f;
                float linear2 = (32 - y) / 32.f;

                pixel.red = show5 * linear1;
                pixel.green = 0;
                pixel.blue = show6 * linear2;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void SM10() {

        get_ready();

        timings.master_speed = 0.006;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.0053;

        timings.ratio[4] = 0.0056;
        timings.ratio[5] = 0.0059;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                float scale = 0.6;

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y];
                animation.z = 5;
                animation.scale_x = 0.09 * scale;
                animation.scale_y = 0.09 * scale;
                animation.offset_y = -30 * move.linear[0];
                animation.offset_z = 0;
                animation.offset_x = 0;
                animation.low_limit = -1;
                show1 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y];
                animation.z = 50;
                animation.scale_x = 0.09 * scale;
                animation.scale_y = 0.09 * scale;
                animation.offset_y = -30 * move.linear[1];
                animation.offset_z = 0;
                animation.offset_x = 0;
                animation.low_limit = -1;
                show2 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y] + 2 + (show1 / 255) * 3.1415926535897932384626433832795;
                animation.z = 5;
                animation.scale_x = 0.09 * scale;
                animation.scale_y = 0.09 * scale;
                animation.offset_y = -10 * move.linear[0];
                animation.offset_z = 0;
                animation.offset_x = 0;
                animation.low_limit = 0;
                show3 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y] + 2 + (show2 / 255) * 3.1415926535897932384626433832795;
                ;
                animation.z = 5;
                animation.scale_x = 0.09 * scale;
                animation.scale_y = 0.09 * scale;
                animation.offset_y = -20 * move.linear[0];
                animation.offset_z = 0;
                animation.offset_x = 0;
                animation.low_limit = 0;
                show4 = render_value(animation);

                show5 = screen(show4, show3);
                show6 = colordodge(show5, show3);




                pixel.red = (show5 + show6) / 2;
                pixel.green = (show5 - 50) + (show6 / 16);
                pixel.blue = 0;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Complex_Kaleido() {

        get_ready();

        timings.master_speed = 0.009;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.0053;

        timings.ratio[4] = 0.0056;
        timings.ratio[5] = 0.0059;

        calculate_oscillators(timings);



        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle = 5 * polar_theta[x][y] + 10 * move.radial[0] +
                                  animation.dist / 2;
                animation.z = 5;
                animation.scale_x = 0.07;
                animation.scale_y = 0.07;
                animation.offset_z = 0;
                animation.offset_x = -30 * move.linear[0];
                animation.offset_y = 0;
                animation.low_limit = 0;
                show1 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = -5 * polar_theta[x][y] + 12 * move.radial[1] +
                                  animation.dist / 2;
                animation.z = 500;
                animation.scale_x = 0.07;
                animation.scale_y = 0.07;
                animation.offset_z = 0;
                animation.offset_x = -30 * move.linear[1];
                animation.offset_y = 0;
                animation.low_limit = 0;
                show2 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = -5 * polar_theta[x][y] + 12 * move.radial[2] +
                                  animation.dist / 2;
                animation.z = 500;
                animation.scale_x = 0.05;
                animation.scale_y = 0.05;
                animation.offset_z = 0;
                animation.offset_x = -40 * move.linear[2];
                animation.offset_y = 0;
                animation.low_limit = 0;
                show3 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = 5 * polar_theta[x][y] + 12 * move.radial[3] +
                                  animation.dist / 2;
                animation.z = 500;
                animation.scale_x = 0.09;
                animation.scale_y = 0.09;
                animation.offset_z = 0;
                animation.offset_x = -35 * move.linear[3];
                animation.offset_y = 0;
                animation.low_limit = 0;
                show4 = render_value(animation);

                show5 = screen(show4, show3);
                show6 = colordodge(show2, show3);




                float radius = radial_filter_radius;

                float radial = (radius - distance[x][y]) / distance[x][y];

                pixel.red = radial * (show1 + show2);
                pixel.green = 0.3 * radial * show6;
                pixel.blue = radial * show5;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Complex_Kaleido_2() {

        get_ready();

        timings.master_speed = 0.009;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.0053;

        timings.ratio[4] = 0.0056;
        timings.ratio[5] = 0.0059;

        calculate_oscillators(timings);

        float size = 0.5;

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle = 5 * polar_theta[x][y] + 10 * move.radial[0] +
                                  animation.dist / 2;
                animation.z = 5;
                animation.scale_x = 0.07 * size;
                animation.scale_y = 0.07 * size;
                animation.offset_z = 0;
                animation.offset_x = -30 * move.linear[0];
                animation.offset_y = 0;
                animation.low_limit = 0;
                show1 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = -5 * polar_theta[x][y] + 12 * move.radial[1] +
                                  animation.dist / 2;
                animation.z = 500;
                animation.scale_x = 0.07 * size;
                animation.scale_y = 0.07 * size;
                animation.offset_z = 0;
                animation.offset_x = -30 * move.linear[1];
                animation.offset_y = 0;
                animation.low_limit = 0;
                show2 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = -5 * polar_theta[x][y] + 12 * move.radial[2] +
                                  animation.dist / 2;
                animation.z = 500;
                animation.scale_x = 0.05 * size;
                animation.scale_y = 0.05 * size;
                animation.offset_z = 0;
                animation.offset_x = -40 * move.linear[2];
                animation.offset_y = 0;
                animation.low_limit = 0;
                show3 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = 5 * polar_theta[x][y] + 12 * move.radial[3] +
                                  animation.dist / 2;
                animation.z = 500;
                animation.scale_x = 0.09 * size;
                animation.scale_y = 0.09 * size;
                animation.offset_z = 0;
                animation.offset_x = -35 * move.linear[3];
                animation.offset_y = 0;
                animation.low_limit = 0;
                show4 = render_value(animation);

                show5 = screen(show4, show3);
                show6 = colordodge(show2, show3);




                float radius = radial_filter_radius;

                float radial = (radius - distance[x][y]) / distance[x][y];

                pixel.red = radial * (show1 + show2);
                pixel.green = 0.3 * radial * show6;
                pixel.blue = radial * show5;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Complex_Kaleido_3() {

        get_ready();

        timings.master_speed = 0.001;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.033;

        timings.ratio[4] = 0.037;
        timings.ratio[5] = 0.038;
        timings.ratio[5] = 0.041;

        calculate_oscillators(timings);

        float size = 0.4 + move.directional[0] * 0.1;

        float q = 2;

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle =
                    5 * polar_theta[x][y] + 10 * move.radial[0] +
                    animation.dist / (((move.directional[0] + 3) * 2)) +
                    move.noise_angle[0] * q;
                animation.z = 5;
                animation.scale_x = 0.08 * size * (move.directional[0] + 1.5);
                animation.scale_y = 0.07 * size;
                animation.offset_z = -10 * move.linear[0];
                animation.offset_x = -30 * move.linear[0];
                animation.offset_y = 0;
                animation.low_limit = 0;
                show1 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle =
                    -5 * polar_theta[x][y] + 10 * move.radial[1] +
                    animation.dist / (((move.directional[1] + 3) * 2)) +
                    move.noise_angle[1] * q;
                animation.z = 500;
                animation.scale_x = 0.07 * size * (move.directional[1] + 1.1);
                animation.scale_y = 0.07 * size * (move.directional[2] + 1.3);
                ;
                animation.offset_z = -12 * move.linear[1];
                ;
                animation.offset_x = -(num_x - 1) * move.linear[1];
                animation.offset_y = 0;
                animation.low_limit = 0;
                show2 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle =
                    -5 * polar_theta[x][y] + 12 * move.radial[2] +
                    animation.dist / (((move.directional[3] + 3) * 2)) +
                    move.noise_angle[2] * q;
                animation.z = 500;
                animation.scale_x = 0.05 * size * (move.directional[3] + 1.5);
                ;
                animation.scale_y = 0.05 * size * (move.directional[4] + 1.5);
                ;
                animation.offset_z = -12 * move.linear[3];
                animation.offset_x = -40 * move.linear[3];
                animation.offset_y = 0;
                animation.low_limit = 0;
                show3 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle =
                    5 * polar_theta[x][y] + 12 * move.radial[3] +
                    animation.dist / (((move.directional[5] + 3) * 2)) +
                    move.noise_angle[3] * q;
                animation.z = 500;
                animation.scale_x = 0.09 * size * (move.directional[5] + 1.5);
                ;
                ;
                animation.scale_y = 0.09 * size * (move.directional[6] + 1.5);
                ;
                ;
                animation.offset_z = 0;
                animation.offset_x = -35 * move.linear[3];
                animation.offset_y = 0;
                animation.low_limit = 0;
                show4 = render_value(animation);

                show5 = screen(show4, show3) - show2;
                show6 = colordodge(show4, show1);

                show7 = multiply(show1, show2);

                float linear1 = y / 32.f;


                float radius = radial_filter_radius;

                float radial = (radius - distance[x][y]) / distance[x][y];

                show7 = multiply(show1, show2) * linear1 * 2;
                show8 = subtract(show7, show5);


                pixel.green = 0.2 * show8;
                pixel.blue = show5 * radial;
                pixel.red = (1 * show1 + 1 * show2) - show7 / 2;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Complex_Kaleido_4() {

        get_ready();

        timings.master_speed = 0.01;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.033;

        timings.ratio[4] = 0.037;
        timings.ratio[5] = 0.038;
        timings.ratio[6] = 0.041;

        calculate_oscillators(timings);

        float size = 0.6;

        float q = 1;

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                float s = 1 + move.directional[6] * 0.3;

                animation.dist = distance[x][y] * s;
                animation.angle =
                    5 * polar_theta[x][y] + 1 * move.radial[0] -
                    animation.dist / (3 + move.directional[0] * 0.5);
                animation.z = 5;
                animation.scale_x = 0.08 * size + (move.directional[0] * 0.01);
                animation.scale_y = 0.07 * size + (move.directional[1] * 0.01);
                animation.offset_z = -10 * move.linear[0];
                animation.offset_x = 0;
                animation.offset_y = 0;
                animation.low_limit = 0;
                show1 = render_value(animation);

                animation.dist = distance[x][y] * s;
                animation.angle =
                    5 * polar_theta[x][y] + 1 * move.radial[1] +
                    animation.dist / (3 + move.directional[1] * 0.5);
                animation.z = 50;
                animation.scale_x = 0.08 * size + (move.directional[1] * 0.01);
                animation.scale_y = 0.07 * size + (move.directional[2] * 0.01);
                animation.offset_z = -10 * move.linear[1];
                animation.offset_x = 0;
                animation.offset_y = 0;
                animation.low_limit = 0;
                show2 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = 1;
                animation.z = 500;
                animation.scale_x = 0.2 * size;
                animation.scale_y = 0.2 * size;
                animation.offset_z = 0;
                animation.offset_y = +7 * move.linear[3] + move.noise_angle[3];
                animation.offset_x = 0;
                animation.low_limit = 0;
                show3 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle =
                    5 * polar_theta[x][y] + 12 * move.radial[3] +
                    animation.dist / (((move.directional[5] + 3) * 2)) +
                    move.noise_angle[3] * q;
                animation.z = 500;
                animation.scale_x = 0.09 * size * (move.directional[5] + 1.5);
                ;
                ;
                animation.scale_y = 0.09 * size * (move.directional[6] + 1.5);
                ;
                ;
                animation.offset_z = 0;
                animation.offset_x = -35 * move.linear[3];
                animation.offset_y = 0;
                animation.low_limit = 0;
                show4 = render_value(animation);
# 3102 "../../src/fx/2d/animartrix_detail.hpp"
                float radius = radial_filter_radius;

                float radial = (radius - distance[x][y]) / distance[x][y];





                show5 = ((show1 + show2)) - show3;
                if (show5 > 255)
                    show5 = 255;
                if (show5 < 0)
                    show5 = 0;

                show6 = colordodge(show1, show2);

                pixel.red = show5 * radial;
                pixel.blue = (64 - show5 - show3) * radial;
                pixel.green = 0.5 * (show6);



                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Complex_Kaleido_5() {

        get_ready();

        timings.master_speed = 0.01;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.033;

        timings.ratio[4] = 0.037;
        timings.ratio[5] = 0.0038;
        timings.ratio[6] = 0.041;

        calculate_oscillators(timings);

        float size = 0.6;



        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                float s = 1 + move.directional[6] * 0.8;

                animation.dist = distance[x][y] * s;
                animation.angle = 10 * move.radial[6] +
                                  50 * move.directional[5] * polar_theta[x][y] -
                                  animation.dist / 3;
                animation.z = 5;
                animation.scale_x = 0.08 * size;
                animation.scale_y = 0.07 * size;
                animation.offset_z = -10 * move.linear[0];
                animation.offset_x = 0;
                animation.offset_y = 0;
                animation.low_limit = -0.5;
                show1 = render_value(animation);

                float radius = radial_filter_radius;

                float radial = (radius - distance[x][y]) / distance[x][y];

                pixel.red = show1 * radial;
                pixel.green = 0;
                pixel.blue = 0;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Complex_Kaleido_6() {

        get_ready();

        timings.master_speed = 0.01;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.033;

        timings.ratio[4] = 0.037;
        timings.ratio[5] = 0.0038;
        timings.ratio[6] = 0.041;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle = 16 * polar_theta[x][y] + 16 * move.radial[0];
                animation.z = 5;
                animation.scale_x = 0.06;
                animation.scale_y = 0.06;
                animation.offset_z = -10 * move.linear[0];
                animation.offset_y = 10 * move.noise_angle[0];
                animation.offset_x = 10 * move.noise_angle[4];
                animation.low_limit = 0;
                show1 = render_value(animation);

                animation.dist = distance[x][y];
                animation.angle = 16 * polar_theta[x][y] + 16 * move.radial[1];
                animation.z = 500;
                animation.scale_x = 0.06;
                animation.scale_y = 0.06;
                animation.offset_z = -10 * move.linear[1];
                animation.offset_y = 10 * move.noise_angle[1];
                animation.offset_x = 10 * move.noise_angle[3];
                animation.low_limit = 0;
                show2 = render_value(animation);





                pixel.red = show1;
                pixel.green = 0;
                pixel.blue = show2;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Water() {

        get_ready();

        timings.master_speed = 0.037;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.031;
        timings.ratio[3] = 0.033;

        timings.ratio[4] = 0.037;
        timings.ratio[5] = 0.1;
        timings.ratio[6] = 0.41;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist =
                    distance[x][y] +
                    4 * sinf(move.directional[5] * 3.1415926535897932384626433832795 + (float)x / 2) +
                    4 * cosf(move.directional[6] * 3.1415926535897932384626433832795 + float(y) / 2);
                animation.angle = 1 * polar_theta[x][y];
                animation.z = 5;
                animation.scale_x = 0.06;
                animation.scale_y = 0.06;
                animation.offset_z = -10 * move.linear[0];
                animation.offset_y = 10;
                animation.offset_x = 10;
                animation.low_limit = 0;
                show1 = render_value(animation);

                animation.dist = (10 + move.directional[0]) *
                                 sinf(-move.radial[5] + move.radial[0] + (distance[x][y] / (3)))
                                                             ;
                animation.angle = 1 * polar_theta[x][y];
                animation.z = 5;
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = -10;
                animation.offset_y = 20 * move.linear[0];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show2 = render_value(animation);

                animation.dist = (10 + move.directional[1]) *
                                 sinf(-move.radial[5] + move.radial[1] + (distance[x][y] / (3)))
                                                             ;
                animation.angle = 1 * polar_theta[x][y];
                animation.z = 500;
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = -10;
                animation.offset_y = 20 * move.linear[1];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show3 = render_value(animation);

                animation.dist = (10 + move.directional[2]) *
                                 sinf(-move.radial[5] + move.radial[2] + (distance[x][y] / (3)))
                                                             ;
                animation.angle = 1 * polar_theta[x][y];
                animation.z = 500;
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = -10;
                animation.offset_y = 20 * move.linear[2];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show4 = render_value(animation);







                pixel.blue = (0.7 * show2 + 0.6 * show3 + 0.5 * show4);
                pixel.red = pixel.blue - 40;
                pixel.green = 0;



                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Parametric_Water() {

        get_ready();

        timings.master_speed = 0.003;

        timings.ratio[0] = 0.025;

        timings.ratio[1] = 0.027;
        timings.ratio[2] = 0.029;
        timings.ratio[3] = 0.033;

        timings.ratio[4] = 0.037;
        timings.ratio[5] = 0.15;
        timings.ratio[6] = 0.41;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                float s = 4;
                float f = 10 + 2 * move.directional[0];

                animation.dist = (f + move.directional[0]) *
                                 sinf(-move.radial[5] + move.radial[0] + (distance[x][y] / (s)))
                                                             ;
                animation.angle = 1 * polar_theta[x][y];
                animation.z = 5;
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = -10;
                animation.offset_y = 20 * move.linear[0];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show2 = render_value(animation);

                animation.dist = (f + move.directional[1]) *
                                 sinf(-move.radial[5] + move.radial[1] + (distance[x][y] / (s)))
                                                             ;
                animation.angle = 1 * polar_theta[x][y];
                animation.z = 500;
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = -10;
                animation.offset_y = 20 * move.linear[1];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show3 = render_value(animation);

                animation.dist = (f + move.directional[2]) *
                                 sinf(-move.radial[5] + move.radial[2] + (distance[x][y] / (s)))
                                                             ;
                animation.angle = 1 * polar_theta[x][y];
                animation.z = 5000;
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = -10;
                animation.offset_y = 20 * move.linear[2];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show4 = render_value(animation);

                animation.dist = (f + move.directional[3]) *
                                 sinf(-move.radial[5] + move.radial[3] + (distance[x][y] / (s)))
                                                             ;
                animation.angle = 1 * polar_theta[x][y];
                animation.z = 2000;
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = -10;
                animation.offset_y = 20 * move.linear[3];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show5 = render_value(animation);

                show6 = screen(show4, show5);
                show7 = screen(show2, show3);

                float radius = 40;
                float radial = (radius - distance[x][y]) / radius;




                pixel.red = pixel.blue - 40;
                pixel.green = 0;
                pixel.blue = (0.3 * show6 + 0.7 * show7) * radial;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Module_Experiment1() {

        get_ready();

        timings.master_speed = 0.03;

        timings.ratio[0] = 0.0025;

        timings.ratio[1] = 0.0027;
        timings.ratio[2] = 0.029;
        timings.ratio[3] = 0.033;


        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y] + 20 * move.directional[0];
                animation.angle = move.noise_angle[0] + move.noise_angle[1] +
                                  polar_theta[x][y];
                animation.z = 5;
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = -10;
                animation.offset_y = 20 * move.linear[2];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show1 = render_value(animation);

                pixel.red = 0;
                pixel.green = 0;
                pixel.blue = show1;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Module_Experiment2() {

        get_ready();

        timings.master_speed = 0.02;

        timings.ratio[0] = 0.0025;

        timings.ratio[1] = 0.0027;
        timings.ratio[2] = 0.029;
        timings.ratio[3] = 0.033;


        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist =
                    distance[x][y] - (16 + move.directional[0] * 16);
                animation.angle = move.noise_angle[0] + move.noise_angle[1] +
                                  polar_theta[x][y];
                animation.z = 5;
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = -10;
                animation.offset_y = 20 * move.linear[2];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show1 = render_value(animation);

                pixel.red = show1;
                pixel.green = show1 - 80;
                pixel.blue = show1 - 150;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Module_Experiment3() {

        get_ready();

        timings.master_speed = 0.01;

        timings.ratio[0] = 0.0025;

        timings.ratio[1] = 0.0027;
        timings.ratio[2] = 0.029;
        timings.ratio[3] = 0.033;


        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist =
                    distance[x][y] - (12 + move.directional[3] * 4);
                animation.angle = move.noise_angle[0] + move.noise_angle[1] +
                                  polar_theta[x][y];
                animation.z = 5;
                animation.scale_x = 0.1;
                animation.scale_y = 0.1;
                animation.offset_z = -10;
                animation.offset_y = 20 * move.linear[2];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show1 = render_value(animation);

                pixel.red = show1;
                pixel.green = show1 - 80;
                pixel.blue = show1 - 150;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Zoom2() {

        get_ready();

        run_default_oscillators();
        timings.master_speed = 0.003;
        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = (distance[x][y] * distance[x][y]) / 2;
                animation.angle = polar_theta[x][y];

                animation.scale_x = 0.005;
                animation.scale_y = 0.005;

                animation.offset_y = -10 * move.linear[0];
                animation.offset_x = 0;
                animation.offset_z = 0.1 * move.linear[0];

                animation.z = 0;
                animation.low_limit = 0;
                float show1 = render_value(animation);



                pixel.red = show1;
                pixel.green = 0;
                pixel.blue = 40 - show1;

                pixel = rgb_sanity_check(pixel);
                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Module_Experiment4() {

        get_ready();

        timings.master_speed = 0.031;

        timings.ratio[0] = 0.0025;

        timings.ratio[1] = 0.0027;
        timings.ratio[2] = 0.029;
        timings.ratio[3] = 0.033;
        timings.ratio[4] = 0.036;


        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                float s = 0.8;

                animation.dist = (distance[x][y] * distance[x][y]) * 0.7;
                animation.angle = polar_theta[x][y];
                animation.z = 5;
                animation.scale_x = 0.004 * s;
                animation.scale_y = 0.003 * s;
                animation.offset_z = 0.1 * move.linear[2];
                animation.offset_y = -20 * move.linear[2];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show1 = render_value(animation);

                animation.dist = (distance[x][y] * distance[x][y]) * 0.8;
                animation.angle = polar_theta[x][y];
                animation.z = 50;
                animation.scale_x = 0.004 * s;
                animation.scale_y = 0.003 * s;
                animation.offset_z = 0.1 * move.linear[3];
                animation.offset_y = -20 * move.linear[3];
                animation.offset_x = 100;
                animation.low_limit = 0;
                show2 = render_value(animation);

                animation.dist = (distance[x][y] * distance[x][y]) * 0.9;
                animation.angle = polar_theta[x][y];
                animation.z = 5000;
                animation.scale_x = 0.004 * s;
                animation.scale_y = 0.003 * s;
                animation.offset_z = 0.1 * move.linear[4];
                animation.offset_y = -20 * move.linear[4];
                animation.offset_x = 1000;
                animation.low_limit = 0;
                show3 = render_value(animation);
# 3656 "../../src/fx/2d/animartrix_detail.hpp"
                pixel.red = show1 - show2 - show3;
                pixel.blue = show2 - show1 - show3;
                pixel.green = show3 - show1 - show2;




                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Module_Experiment5() {

        get_ready();

        timings.master_speed = 0.031;

        timings.ratio[0] = 0.0025;

        timings.ratio[1] = 0.0027;
        timings.ratio[2] = 0.029;
        timings.ratio[3] = 0.33;
        timings.ratio[4] = 0.036;


        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                float s = 1.5;

                animation.dist = distance[x][y] +
                                 sinf(0.5 * distance[x][y] - move.radial[3]);
                animation.angle = polar_theta[x][y];
                animation.z = 5;
                animation.scale_x = 0.1 * s;
                animation.scale_y = 0.1 * s;
                animation.offset_z = 0.1 * move.linear[0];
                animation.offset_y = -20 * move.linear[0];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show1 = render_value(animation);

                pixel.red = show1;
                pixel.green = 0;
                pixel.blue = 0;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Module_Experiment6() {

        get_ready();

        timings.master_speed = 0.01;

        float w = 0.7;

        timings.ratio[0] = 0.0025;

        timings.ratio[1] = 0.0027;
        timings.ratio[2] = 0.029;
        timings.ratio[3] = 0.33 * w;
        timings.ratio[4] = 0.36 * w;


        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                float s = 0.8;

                animation.dist = distance[x][y] +
                                 sinf(0.25 * distance[x][y] - move.radial[3]);
                animation.angle = polar_theta[x][y];
                animation.z = 5;
                animation.scale_x = 0.1 * s;
                animation.scale_y = 0.1 * s;
                animation.offset_z = 0.1 * move.linear[0];
                animation.offset_y = -20 * move.linear[0];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show1 = render_value(animation);

                animation.dist = distance[x][y] +
                                 sinf(0.24 * distance[x][y] - move.radial[4]);
                animation.angle = polar_theta[x][y];
                animation.z = 10;
                animation.scale_x = 0.1 * s;
                animation.scale_y = 0.1 * s;
                animation.offset_z = 0.1 * move.linear[1];
                animation.offset_y = -20 * move.linear[1];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show2 = render_value(animation);







                pixel.red = (show1 + show2);
                pixel.green = ((show1 + show2) * 0.6) - 30;
                pixel.blue = 0;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Module_Experiment7() {

        get_ready();

        timings.master_speed = 0.005;

        float w = 0.3;

        timings.ratio[0] = 0.01;

        timings.ratio[1] = 0.011;
        timings.ratio[2] = 0.029;
        timings.ratio[3] = 0.33 * w;
        timings.ratio[4] = 0.36 * w;


        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                float s = 0.7;

                animation.dist =
                    2 + distance[x][y] +
                    2 * sinf(0.25 * distance[x][y] - move.radial[3]);
                animation.angle = polar_theta[x][y];
                animation.z = 5;
                animation.scale_x = 0.1 * s;
                animation.scale_y = 0.1 * s;
                animation.offset_z = 10 * move.linear[0];
                animation.offset_y = -20 * move.linear[0];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show1 = render_value(animation);

                animation.dist =
                    2 + distance[x][y] +
                    2 * sinf(0.24 * distance[x][y] - move.radial[4]);
                animation.angle = polar_theta[x][y];
                animation.z = 10;
                animation.scale_x = 0.1 * s;
                animation.scale_y = 0.1 * s;
                animation.offset_z = 0.1 * move.linear[1];
                animation.offset_y = -20 * move.linear[1];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show2 = render_value(animation);







                pixel.red = (show1 + show2);
                pixel.green = ((show1 + show2) * 0.6) - 50;
                pixel.blue = 0;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Module_Experiment8() {

        get_ready();

        timings.master_speed = 0.01;

        float w = 0.3;

        timings.ratio[0] = 0.01;

        timings.ratio[1] = 0.011;
        timings.ratio[2] = 0.013;
        timings.ratio[3] = 0.33 * w;
        timings.ratio[4] = 0.36 * w;

        timings.ratio[5] = 0.38 * w;
        timings.ratio[6] = 0.0003;

        timings.offset[0] = 0;
        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;
        timings.offset[4] = 400;
        timings.offset[5] = 500;
        timings.offset[6] = 600;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                float s = 0.4;
                float r = 1.5;

                animation.dist =
                    3 + distance[x][y] +
                    3 * sinf(0.25 * distance[x][y] - move.radial[3]);
                animation.angle = polar_theta[x][y] + move.noise_angle[0] +
                                  move.noise_angle[6];
                animation.z = 5;
                animation.scale_x = 0.1 * s;
                animation.scale_y = 0.1 * s;
                animation.offset_z = 10 * move.linear[0];
                animation.offset_y = -5 * r * move.linear[0];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show1 = render_value(animation);

                animation.dist =
                    4 + distance[x][y] +
                    4 * sinf(0.24 * distance[x][y] - move.radial[4]);
                animation.angle = polar_theta[x][y] + move.noise_angle[1] +
                                  move.noise_angle[6];
                animation.z = 5;
                animation.scale_x = 0.1 * s;
                animation.scale_y = 0.1 * s;
                animation.offset_z = 0.1 * move.linear[1];
                animation.offset_y = -5 * r * move.linear[1];
                animation.offset_x = 100;
                animation.low_limit = 0;
                show2 = render_value(animation);

                animation.dist =
                    5 + distance[x][y] +
                    5 * sinf(0.23 * distance[x][y] - move.radial[5]);
                animation.angle = polar_theta[x][y] + move.noise_angle[2] +
                                  move.noise_angle[6];
                animation.z = 5;
                animation.scale_x = 0.1 * s;
                animation.scale_y = 0.1 * s;
                animation.offset_z = 0.1 * move.linear[2];
                animation.offset_y = -5 * r * move.linear[2];
                animation.offset_x = 1000;
                animation.low_limit = 0;
                show3 = render_value(animation);

                show4 = colordodge(show1, show2);

                float rad = sinf(3.1415926535897932384626433832795 / 2 + distance[x][y] / 14)
                                                     ;







                pixel.red = rad * ((show1 + show2) + show3);
                pixel.green = (((show2 + show3) * 0.8) - 90) * rad;
                pixel.blue = show4 * 0.2;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Module_Experiment9() {

        get_ready();

        timings.master_speed = 0.03;

        float w = 0.3;

        timings.ratio[0] = 0.1;

        timings.ratio[1] = 0.011;
        timings.ratio[2] = 0.013;
        timings.ratio[3] = 0.33 * w;
        timings.ratio[4] = 0.36 * w;

        timings.ratio[5] = 0.38 * w;
        timings.ratio[6] = 0.0003;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                animation.dist = distance[x][y];
                animation.angle = polar_theta[x][y] + move.radial[1];
                animation.z = 5;
                animation.scale_x = 0.001;
                animation.scale_y = 0.1;
                animation.scale_z = 0.1;
                animation.offset_y = -10 * move.linear[0];
                animation.offset_x = 20;
                animation.offset_z = 10;
                animation.low_limit = 0;
                show1 = render_value(animation);

                pixel.red = 10 * show1;
                pixel.green = 0;
                pixel.blue = 0;

                pixel = rgb_sanity_check(pixel);

                setPixelColorInternal(x, y, pixel);
            }
        }
    }

    void Module_Experiment10() {

        get_ready();

        timings.master_speed = 0.01;

        float w = 1;

        timings.ratio[0] = 0.01;

        timings.ratio[1] = 0.011;
        timings.ratio[2] = 0.013;
        timings.ratio[3] = 0.33 * w;
        timings.ratio[4] = 0.36 * w;

        timings.ratio[5] = 0.38 * w;
        timings.ratio[6] = 0.0003;

        timings.offset[0] = 0;
        timings.offset[1] = 100;
        timings.offset[2] = 200;
        timings.offset[3] = 300;
        timings.offset[4] = 400;
        timings.offset[5] = 500;
        timings.offset[6] = 600;

        calculate_oscillators(timings);

        for (int x = 0; x < num_x; x++) {
            for (int y = 0; y < num_y; y++) {

                float s = 0.4;
                float r = 1.5;

                animation.dist =
                    3 + distance[x][y] +
                    3 * sinf(0.25 * distance[x][y] - move.radial[3]);
                animation.angle = polar_theta[x][y] + move.noise_angle[0] +
                                  move.noise_angle[6];
                animation.z = 5;
                animation.scale_x = 0.1 * s;
                animation.scale_y = 0.1 * s;
                animation.offset_z = 10 * move.linear[0];
                animation.offset_y = -5 * r * move.linear[0];
                animation.offset_x = 10;
                animation.low_limit = 0;
                show1 = render_value(animation);

                animation.dist =
                    4 + distance[x][y] +
                    4 * sinf(0.24 * distance[x][y] - move.radial[4]);
                animation.angle = polar_theta[x][y] + move.noise_angle[1] +
                                  move.noise_angle[6];
                animation.z = 5;
                animation.scale_x = 0.1 * s;
                animation.scale_y = 0.1 * s;
                animation.offset_z = 0.1 * move.linear[1];
                animation.offset_y = -5 * r * move.linear[1];
                animation.offset_x = 100;
                animation.low_limit = 0;
                show2 = render_value(animation);

                animation.dist =
                    5 + distance[x][y] +
                    5 * sinf(0.23 * distance[x][y] - move.radial[5]);
                animation.angle = polar_theta[x][y] + move.noise_angle[2] +
                                  move.noise_angle[6];
                animation.z = 5;
                animation.scale_x = 0.1 * s;
                animation.scale_y = 0.1 * s;
                animation.offset_z = 0.1 * move.linear[2];
                animation.offset_y = -5 * r * move.linear[2];
                animation.offset_x = 1000;
                animation.low_limit = 0;
                show3 = render_value(animation);

                show4 = colordodge(show1, show2);

                float rad = sinf(3.1415926535897932384626433832795 / 2 + distance[x][y] / 14)
                                                     ;







                CHSV(rad * ((show1 + show2) + show3), 255, 255);

                pixel = rgb_sanity_check(pixel);

                uint8_t a = getTime() / 100;
                CRGB p = CRGB(CHSV(((a + show1 + show2) + show3), 255, 255));
                rgb pixel;
                pixel.red = p.red;
                pixel.green = p.green;
                pixel.blue = p.blue;
                setPixelColorInternal(x, y, pixel);
            }
        }
    }
};

}




# 4095 "../../src/fx/2d/animartrix_detail.hpp"
#pragma GCC pop_options

# 4096 "../../src/fx/2d/animartrix_detail.hpp"
#pragma GCC pop_options
# 22 "../../src/fx/2d/animartrix.hpp" 2

namespace fl {

class Animartrix; using AnimartrixPtr = fl::Ptr<Animartrix>;;

enum AnimartrixAnim {
    RGB_BLOBS5 = 0,
    RGB_BLOBS4,
    RGB_BLOBS3,
    RGB_BLOBS2,
    RGB_BLOBS,
    POLAR_WAVES,
    SLOW_FADE,
    ZOOM2,
    ZOOM,
    HOT_BLOB,
    SPIRALUS2,
    SPIRALUS,
    YVES,
    SCALEDEMO1,
    LAVA1,
    CALEIDO3,
    CALEIDO2,
    CALEIDO1,
    DISTANCE_EXPERIMENT,
    CENTER_FIELD,
    WAVES,
    CHASING_SPIRALS,
    ROTATING_BLOB,
    RINGS,
    COMPLEX_KALEIDO,
    COMPLEX_KALEIDO_2,
    COMPLEX_KALEIDO_3,
    COMPLEX_KALEIDO_4,
    COMPLEX_KALEIDO_5,
    COMPLEX_KALEIDO_6,
    WATER,
    PARAMETRIC_WATER,
    MODULE_EXPERIMENT1,
    MODULE_EXPERIMENT2,
    MODULE_EXPERIMENT3,
    MODULE_EXPERIMENT4,
    MODULE_EXPERIMENT5,
    MODULE_EXPERIMENT6,
    MODULE_EXPERIMENT7,
    MODULE_EXPERIMENT8,
    MODULE_EXPERIMENT9,
    MODULE_EXPERIMENT10,
    MODULE_EXPERIMENT_SM1,
    MODULE_EXPERIMENT_SM2,
    MODULE_EXPERIMENT_SM3,
    MODULE_EXPERIMENT_SM4,
    MODULE_EXPERIMENT_SM5,
    MODULE_EXPERIMENT_SM6,
    MODULE_EXPERIMENT_SM8,
    MODULE_EXPERIMENT_SM9,
    MODULE_EXPERIMENT_SM10,
    NUM_ANIMATIONS
};

fl::string getAnimartrixName(int animation);

class FastLEDANIMartRIX;
class Animartrix : public Fx2d {
  public:
    Animartrix(XYMap xyMap, AnimartrixAnim which_animation) : Fx2d(xyMap) {

        this->current_animation = which_animation;
        mXyMap.convertToLookUpTable();
    }

    Animartrix(const Animartrix &) = delete;
    void draw(DrawContext context) override;
    int fxNum() const { return NUM_ANIMATIONS; }
    void fxSet(int fx);
    int fxGet() const { return static_cast<int>(current_animation); }
    Str fxName() const override { return "Animartrix:"; }
    void fxNext(int fx = 1) { fxSet(fxGet() + fx); }
    void setColorOrder(EOrder order) { color_order = order; }
    EOrder getColorOrder() const { return color_order; }

  private:
    friend void AnimartrixLoop(Animartrix &self, uint32_t now);
    friend class FastLEDANIMartRIX;
    static const char *getAnimartrixName(AnimartrixAnim animation);
    AnimartrixAnim prev_animation = NUM_ANIMATIONS;
    fl::scoped_ptr<FastLEDANIMartRIX> impl;
    CRGB *leds = nullptr;
    AnimartrixAnim current_animation = RGB_BLOBS5;
    EOrder color_order = RGB;
};

void AnimartrixLoop(Animartrix &self, uint32_t now);




struct AnimartrixEntry {
    AnimartrixAnim anim;
    const char *name;
    void (FastLEDANIMartRIX::*func)();
};

class FastLEDANIMartRIX : public animartrix_detail::ANIMartRIX {
    Animartrix *data = nullptr;

  public:
    FastLEDANIMartRIX(Animartrix *_data) {
        this->data = _data;
        this->init(data->getWidth(), data->getHeight());
    }

    void setPixelColor(int x, int y, CRGB pixel) {
        data->leds[xyMap(x, y)] = pixel;
    }
    void setPixelColorInternal(int x, int y,
                               animartrix_detail::rgb pixel) override {
        setPixelColor(x, y, CRGB(pixel.red, pixel.green, pixel.blue));
    }

    uint16_t xyMap(uint16_t x, uint16_t y) override {
        return data->xyMap(x, y);
    }

    void loop();
};

void Animartrix::fxSet(int fx) {
    int curr = fxGet();
    if (fx < 0) {
        fx = curr + fx;
        if (fx < 0) {
            fx = NUM_ANIMATIONS - 1;
        }
    }
    fx = fx % NUM_ANIMATIONS;
    current_animation = static_cast<AnimartrixAnim>(fx);
    fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fx/2d/animartrix.hpp")) << "(" << 159 << "): " << "Setting animation to " << getAnimartrixName(current_animation)) .c_str());
}

void AnimartrixLoop(Animartrix &self, uint32_t now) {
    if (self.prev_animation != self.current_animation) {
        if (self.impl) {

            self.impl->init(self.getWidth(), self.getHeight());
        }
        self.prev_animation = self.current_animation;
    }
    if (!self.impl) {
        self.impl.reset(new FastLEDANIMartRIX(&self));
    }
    self.impl->setTime(now);
    self.impl->loop();
}

static const AnimartrixEntry ANIMATION_TABLE[] = {
    {RGB_BLOBS5, "RGB_BLOBS5", &FastLEDANIMartRIX::RGB_Blobs5},
    {RGB_BLOBS4, "RGB_BLOBS4", &FastLEDANIMartRIX::RGB_Blobs4},
    {RGB_BLOBS3, "RGB_BLOBS3", &FastLEDANIMartRIX::RGB_Blobs3},
    {RGB_BLOBS2, "RGB_BLOBS2", &FastLEDANIMartRIX::RGB_Blobs2},
    {RGB_BLOBS, "RGB_BLOBS", &FastLEDANIMartRIX::RGB_Blobs},
    {POLAR_WAVES, "POLAR_WAVES", &FastLEDANIMartRIX::Polar_Waves},
    {SLOW_FADE, "SLOW_FADE", &FastLEDANIMartRIX::Slow_Fade},
    {ZOOM2, "ZOOM2", &FastLEDANIMartRIX::Zoom2},
    {ZOOM, "ZOOM", &FastLEDANIMartRIX::Zoom},
    {HOT_BLOB, "HOT_BLOB", &FastLEDANIMartRIX::Hot_Blob},
    {SPIRALUS2, "SPIRALUS2", &FastLEDANIMartRIX::Spiralus2},
    {SPIRALUS, "SPIRALUS", &FastLEDANIMartRIX::Spiralus},
    {YVES, "YVES", &FastLEDANIMartRIX::Yves},
    {SCALEDEMO1, "SCALEDEMO1", &FastLEDANIMartRIX::Scaledemo1},
    {LAVA1, "LAVA1", &FastLEDANIMartRIX::Lava1},
    {CALEIDO3, "CALEIDO3", &FastLEDANIMartRIX::Caleido3},
    {CALEIDO2, "CALEIDO2", &FastLEDANIMartRIX::Caleido2},
    {CALEIDO1, "CALEIDO1", &FastLEDANIMartRIX::Caleido1},
    {DISTANCE_EXPERIMENT, "DISTANCE_EXPERIMENT",
     &FastLEDANIMartRIX::Distance_Experiment},
    {CENTER_FIELD, "CENTER_FIELD", &FastLEDANIMartRIX::Center_Field},
    {WAVES, "WAVES", &FastLEDANIMartRIX::Waves},
    {CHASING_SPIRALS, "CHASING_SPIRALS", &FastLEDANIMartRIX::Chasing_Spirals},
    {ROTATING_BLOB, "ROTATING_BLOB", &FastLEDANIMartRIX::Rotating_Blob},
    {RINGS, "RINGS", &FastLEDANIMartRIX::Rings},
    {COMPLEX_KALEIDO, "COMPLEX_KALEIDO", &FastLEDANIMartRIX::Complex_Kaleido},
    {COMPLEX_KALEIDO_2, "COMPLEX_KALEIDO_2",
     &FastLEDANIMartRIX::Complex_Kaleido_2},
    {COMPLEX_KALEIDO_3, "COMPLEX_KALEIDO_3",
     &FastLEDANIMartRIX::Complex_Kaleido_3},
    {COMPLEX_KALEIDO_4, "COMPLEX_KALEIDO_4",
     &FastLEDANIMartRIX::Complex_Kaleido_4},
    {COMPLEX_KALEIDO_5, "COMPLEX_KALEIDO_5",
     &FastLEDANIMartRIX::Complex_Kaleido_5},
    {COMPLEX_KALEIDO_6, "COMPLEX_KALEIDO_6",
     &FastLEDANIMartRIX::Complex_Kaleido_6},
    {WATER, "WATER", &FastLEDANIMartRIX::Water},
    {PARAMETRIC_WATER, "PARAMETRIC_WATER",
     &FastLEDANIMartRIX::Parametric_Water},
    {MODULE_EXPERIMENT1, "MODULE_EXPERIMENT1",
     &FastLEDANIMartRIX::Module_Experiment1},
    {MODULE_EXPERIMENT2, "MODULE_EXPERIMENT2",
     &FastLEDANIMartRIX::Module_Experiment2},
    {MODULE_EXPERIMENT3, "MODULE_EXPERIMENT3",
     &FastLEDANIMartRIX::Module_Experiment3},
    {MODULE_EXPERIMENT4, "MODULE_EXPERIMENT4",
     &FastLEDANIMartRIX::Module_Experiment4},
    {MODULE_EXPERIMENT5, "MODULE_EXPERIMENT5",
     &FastLEDANIMartRIX::Module_Experiment5},
    {MODULE_EXPERIMENT6, "MODULE_EXPERIMENT6",
     &FastLEDANIMartRIX::Module_Experiment6},
    {MODULE_EXPERIMENT7, "MODULE_EXPERIMENT7",
     &FastLEDANIMartRIX::Module_Experiment7},
    {MODULE_EXPERIMENT8, "MODULE_EXPERIMENT8",
     &FastLEDANIMartRIX::Module_Experiment8},
    {MODULE_EXPERIMENT9, "MODULE_EXPERIMENT9",
     &FastLEDANIMartRIX::Module_Experiment9},
    {MODULE_EXPERIMENT10, "MODULE_EXPERIMENT10",
     &FastLEDANIMartRIX::Module_Experiment10},
    {MODULE_EXPERIMENT_SM1, "MODULE_EXPERIMENT_SM1", &FastLEDANIMartRIX::SM1},
    {MODULE_EXPERIMENT_SM2, "MODULE_EXPERIMENT_SM2", &FastLEDANIMartRIX::SM2},
    {MODULE_EXPERIMENT_SM3, "MODULE_EXPERIMENT_SM3", &FastLEDANIMartRIX::SM3},
    {MODULE_EXPERIMENT_SM4, "MODULE_EXPERIMENT_SM4", &FastLEDANIMartRIX::SM4},
    {MODULE_EXPERIMENT_SM5, "MODULE_EXPERIMENT_SM5", &FastLEDANIMartRIX::SM5},
    {MODULE_EXPERIMENT_SM6, "MODULE_EXPERIMENT_SM6", &FastLEDANIMartRIX::SM6},
    {MODULE_EXPERIMENT_SM8, "MODULE_EXPERIMENT_SM8", &FastLEDANIMartRIX::SM8},
    {MODULE_EXPERIMENT_SM9, "MODULE_EXPERIMENT_SM9", &FastLEDANIMartRIX::SM9},
    {MODULE_EXPERIMENT_SM10, "MODULE_EXPERIMENT_SM10",
     &FastLEDANIMartRIX::SM10},
};

fl::string getAnimartrixName(int animation) {
    if (animation < 0 || animation >= NUM_ANIMATIONS) {
        return "UNKNOWN";
    }
    return ANIMATION_TABLE[animation].name;
}

void FastLEDANIMartRIX::loop() {
    for (const auto &entry : ANIMATION_TABLE) {
        if (entry.anim == data->current_animation) {
            (this->*entry.func)();
            return;
        }
    }

    fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fx/2d/animartrix.hpp")) << "(" << 264 << "): " << "Animation not found for " << int(data->current_animation)) .c_str());
}

const char *Animartrix::getAnimartrixName(AnimartrixAnim animation) {
    for (const auto &entry : ANIMATION_TABLE) {
        if (entry.anim == animation) {
            return entry.name;
        }
    }
    fl::println( (fl::StrStream() << (fl::fastled_file_offset("../../src/fx/2d/animartrix.hpp")) << "(" << 273 << "): " << "Animation not found for " << int(animation)) .c_str());
    return "UNKNOWN";
}

void Animartrix::draw(DrawContext ctx) {
    this->leds = ctx.leds;
    AnimartrixLoop(*this, ctx.now);
    if (color_order != RGB) {
        for (int i = 0; i < mXyMap.getTotal(); ++i) {
            CRGB &pixel = ctx.leds[i];
            const uint8_t b0_index = ((color_order>>6) & 0x3);
            const uint8_t b1_index = ((color_order>>3) & 0x3);
            const uint8_t b2_index = ((color_order) & 0x3);
            pixel = CRGB(pixel.raw[b0_index], pixel.raw[b1_index],
                         pixel.raw[b2_index]);
        }

    }
    this->leds = nullptr;
}

}
# 37 "curr.h" 2



using namespace fl;
# 64 "curr.h"
UITitle festivalStickTitle("Festival Stick");
UIDescription festivalStickDescription(
    "# Festival Stick Demo\n\n"
    "This example demonstrates **proper corkscrew LED mapping** for a festival stick using FastLED's advanced mapping capabilities.\n\n"
    "## Key Features\n"
    "- **19+ turns** with 288 LEDs total\n"
    "- Uses `Corkscrew.toScreenMap()` for accurate web interface visualization\n"
    "- Multiple render modes: **Noise**, **Position**, **Fire**, **Wave**, and **Animartrix** effects\n"
    "- Real-time cylindrical surface mapping\n"
    "- **Wave mode**: Cylindrical 2D wave simulation with ripple effects\n"
    "- **Animartrix mode**: Advanced 2D animation effects with polar coordinate patterns\n\n"
    "## How It Works\n"
    "1. Draws patterns into a rectangular grid (`frameBuffer`)\n"
    "2. Maps the grid to corkscrew LED positions using `readFrom()`\n"
    "3. Web interface shows the actual spiral shape via ScreenMap\n\n"
    "*Select different render modes and adjust parameters to see various effects!*");



UISlider speed("Speed", 0.1f, 0.01f, 1.0f, 0.01f);
UISlider positionCoarse("Position Coarse (10x)", 0.0f, 0.0f, 1.0f, 0.01f);
UISlider positionFine("Position Fine (1x)", 0.0f, 0.0f, 0.1f, 0.001f);
UISlider positionExtraFine("Position Extra Fine (0.1x)", 0.0f, 0.0f, 0.01f, 0.0001f);
UISlider brightness("Brightness", 255, 0, 255, 1);

UICheckbox autoAdvance("Auto Advance", true);
UICheckbox allWhite("All White", false);
UICheckbox splatRendering("Splat Rendering", true);



UISlider noiseScale("Noise Scale", 100, 10, 200, 5);
UISlider noiseSpeed("Noise Speed", 4, 1, 100, 1);


string paletteOptions[] = {"Party", "Heat", "Ocean", "Forest", "Rainbow"};
string renderModeOptions[] = { "Wave", "Animartrix", "Noise", "Position", "Fire" };




UIDropdown paletteDropdown("Color Palette", paletteOptions);
UIDropdown renderModeDropdown("Render Mode", renderModeOptions);
# 122 "curr.h"
fl::vector<fl::string> easeInfo = {
    "EASE_NONE",
    "EASE_IN_QUAD",
    "EASE_OUT_QUAD",
    "EASE_IN_OUT_QUAD",
    "EASE_IN_CUBIC",
    "EASE_OUT_CUBIC",
    "EASE_IN_OUT_CUBIC",
    "EASE_IN_SINE",
    "EASE_OUT_SINE",
    "EASE_IN_OUT_SINE"
};

EaseType getEaseType(fl::string value) {
    if (value == "EASE_NONE") {
        return EASE_NONE;
    } else if (value == "EASE_IN_QUAD") {
        return EASE_IN_QUAD;
    } else if (value == "EASE_OUT_QUAD") {
        return EASE_OUT_QUAD;
    } else if (value == "EASE_IN_OUT_QUAD") {
        return EASE_IN_OUT_QUAD;
    } else if (value == "EASE_IN_CUBIC") {
        return EASE_IN_CUBIC;
    } else if (value == "EASE_OUT_CUBIC") {
        return EASE_OUT_CUBIC;
    } else if (value == "EASE_IN_OUT_CUBIC") {
        return EASE_IN_OUT_CUBIC;
    } else if (value == "EASE_IN_SINE") {
        return EASE_IN_SINE;
    } else if (value == "EASE_OUT_SINE") {
        return EASE_OUT_SINE;
    } else if (value == "EASE_IN_OUT_SINE") {
        return EASE_IN_OUT_SINE;
    } else {
        return EASE_NONE;
    }
}


UIDropdown saturationFunction("Saturation Function", easeInfo.begin(), easeInfo.end());
UIDropdown luminanceFunction("Luminance Function", easeInfo.begin(), easeInfo.end());


UISlider fireScaleXY("Fire Scale", 8, 1, 100, 1);
UISlider fireSpeedY("Fire SpeedY", 1.3, 1, 6, .1);
UISlider fireScaleX("Fire ScaleX", .3, 0.1, 3, .01);
UISlider fireInvSpeedZ("Fire Inverse SpeedZ", 20, 1, 100, 1);
UINumberField firePalette("Fire Palette", 0, 0, 2);


UISlider waveSpeed("Wave Speed", 0.03f, 0.0f, 1.0f, 0.01f);
UISlider waveDampening("Wave Dampening", 9.1f, 0.0f, 20.0f, 0.1f);
UICheckbox waveHalfDuplex("Wave Half Duplex", true);
UICheckbox waveAutoTrigger("Wave Auto Trigger", true);
UISlider waveTriggerSpeed("Wave Trigger Speed", 0.5f, 0.0f, 1.0f, 0.01f);
UIButton waveTriggerButton("Trigger Wave");
UINumberField wavePalette("Wave Palette", 0, 0, 2);


 extern const TProgmemRGBGradientPalette_byte firepal[] ={
    0, 0, 0, 0,
    32, 255, 0, 0,
    190, 255, 255, 0,
    255, 255, 255, 255
};

 extern const TProgmemRGBGradientPalette_byte electricGreenFirePal[] ={
    0, 0, 0, 0,
    32, 0, 70, 0,
    190, 57, 255, 20,
    255, 255, 255, 255
};

 extern const TProgmemRGBGradientPalette_byte electricBlueFirePal[] ={
    0, 0, 0, 0,
    32, 0, 0, 70,
    128, 20, 57, 255,
    255, 255, 255, 255
};


 extern const TProgmemRGBGradientPalette_byte waveBluepal[] ={
    0, 0, 0, 0,
    32, 0, 0, 70,
    128, 20, 57, 255,
    255, 255, 255, 255
};

 extern const TProgmemRGBGradientPalette_byte waveGreenpal[] ={
    0, 0, 0, 0,
    8, 128, 64, 64,
    16, 255, 222, 222,
    64, 255, 255, 255,
    255, 255, 255, 255
};

 extern const TProgmemRGBGradientPalette_byte waveRainbowpal[] ={
    0, 255, 0, 0,
    64, 255, 127, 0,
    128, 255, 255, 0,
    192, 0, 255, 0,
    255, 0, 0, 255
};



UIGroup noiseGroup("Noise Controls", noiseScale, noiseSpeed, paletteDropdown);
UIGroup fireGroup("Fire Controls", fireScaleXY, fireSpeedY, fireScaleX, fireInvSpeedZ, firePalette);
UIGroup waveGroup("Wave Controls", waveSpeed, waveDampening, waveHalfDuplex, waveAutoTrigger, waveTriggerSpeed, waveTriggerButton, wavePalette);
UIGroup renderGroup("Render Options", renderModeDropdown, splatRendering, allWhite, brightness);
UIGroup colorBoostGroup("Color Boost", saturationFunction, luminanceFunction);
UIGroup pointGraphicsGroup("Point Graphics Mode", speed, positionCoarse, positionFine, positionExtraFine, autoAdvance);


UINumberField animartrixIndex("Animartrix Animation", 5, 0, NUM_ANIMATIONS - 1);
UISlider animartrixTimeSpeed("Animartrix Time Speed", 1, -10, 10, .1);
UINumberField animartrixColorOrder("Animartrix Color Order", 0, 0, 5);

UIGroup animartrixGroup("Animartrix Controls", animartrixIndex, animartrixTimeSpeed, animartrixColorOrder);


CRGBPalette16 noisePalette = PartyColors_p;
uint8_t colorLoop = 1;


Corkscrew::Input corkscrewInput(19.25, 288);
Corkscrew corkscrew(corkscrewInput);


static float currentPosition = 0.0f;
static uint32_t lastUpdateTime = 0;


static uint32_t nextWaveTrigger = 0;
static uint32_t lastWaveTriggerTime = 0;





constexpr uint16_t CORKSCREW_WIDTH =
    calculateCorkscrewWidth(19.25, 288);
constexpr uint16_t CORKSCREW_HEIGHT =
    calculateCorkscrewHeight(19.25, 288);
# 281 "curr.h"
ScreenMap screenMap;
Grid<CRGB> frameBuffer;


WaveFxPtr waveFx;
Blend2dPtr waveBlend;


fl::scoped_ptr<Animartrix> animartrix;
fl::scoped_ptr<FxEngine> fxEngine;

void setup() {

    constexpr int width = CORKSCREW_WIDTH;
    constexpr int height = CORKSCREW_HEIGHT;
# 306 "curr.h"
    frameBuffer.reset(width, height);
    XYMap xyMap = XYMap::constructRectangularGrid(width, height, 0);


    CLEDController *controller =
        &FastLED.addLeds<APA102HD, 1, 2, BGR>(corkscrew.data(), 288);







    ScreenMap corkscrewScreenMap = corkscrew.toScreenMap(0.2f);







    controller->setScreenMap(corkscrewScreenMap);


    XYMap xyRect(width, height, false);
    WaveFx::Args waveArgs;
    waveArgs.factor = SuperSample::SUPER_SAMPLE_2X;
    waveArgs.half_duplex = true;
    waveArgs.auto_updates = true;
    waveArgs.speed = 0.16f;
    waveArgs.dampening = 6.0f;
    waveArgs.x_cyclical = true;
    waveArgs.crgbMap = WaveCrgbGradientMapPtr::New(waveBluepal);


    waveFx = NewPtr<WaveFx>(xyRect, waveArgs);


    waveBlend = NewPtr<Blend2d>(xyRect);
    waveBlend->add(waveFx);


    XYMap animartrixXyMap = XYMap::constructRectangularGrid(width, height, 0);
    animartrix.reset(new Animartrix(animartrixXyMap, POLAR_WAVES));
    fxEngine.reset(new FxEngine(width * height));
    fxEngine->addFx(*animartrix);


    fl::println( (fl::StrStream() << (fl::fastled_file_offset("curr.h")) << "(" << 354 << "): " << "Noise UI Group initialized: " << noiseGroup.name()) .c_str());
    fl::println( (fl::StrStream() << (fl::fastled_file_offset("curr.h")) << "(" << 355 << "): " << "  This group contains noise pattern controls:") .c_str());
    fl::println( (fl::StrStream() << (fl::fastled_file_offset("curr.h")) << "(" << 356 << "): " << "  - Use Noise Pattern toggle") .c_str());
    fl::println( (fl::StrStream() << (fl::fastled_file_offset("curr.h")) << "(" << 357 << "): " << "  - Noise Scale and Speed sliders") .c_str());
    fl::println( (fl::StrStream() << (fl::fastled_file_offset("curr.h")) << "(" << 358 << "): " << "  - Color Palette selection for noise") .c_str());
    fl::println( (fl::StrStream() << (fl::fastled_file_offset("curr.h")) << "(" << 359 << "): " << "  UIGroup automatically applied group membership via variadic constructor") .c_str());


    paletteDropdown.setSelectedIndex(0);
    renderModeDropdown.setSelectedIndex(0);


    paletteDropdown.onChanged([](UIDropdown &dropdown) {
        string selectedPalette = dropdown.value();
        fl::println( (fl::StrStream() << (fl::fastled_file_offset("curr.h")) << "(" << 368 << "): " << "Noise palette changed to: " << selectedPalette) .c_str());
        if (selectedPalette == "Party") {
            noisePalette = PartyColors_p;
        } else if (selectedPalette == "Heat") {
            noisePalette = HeatColors_p;
        } else if (selectedPalette == "Ocean") {
            noisePalette = OceanColors_p;
        } else if (selectedPalette == "Forest") {
            noisePalette = ForestColors_p;
        } else if (selectedPalette == "Rainbow") {
            noisePalette = RainbowColors_p;
        }
    });

    renderModeDropdown.onChanged([](UIDropdown &dropdown) {
        string mode = dropdown.value();

        for(size_t i = 0; i < dropdown.getOptionCount(); i++) {
            if(dropdown.getOption(i) == mode) {
                fl::println( (fl::StrStream() << (fl::fastled_file_offset("curr.h")) << "(" << 387 << "): " << "Render mode changed to: " << mode) .c_str());
            }
        }
    });


    animartrixColorOrder.onChanged([](int value) {
        EOrder order = RGB;
        switch(value) {
            case 0: order = RGB; break;
            case 1: order = RBG; break;
            case 2: order = GRB; break;
            case 3: order = GBR; break;
            case 4: order = BRG; break;
            case 5: order = BGR; break;
        }
        if (animartrix.get()) {
            animartrix->setColorOrder(order);
        }
    });
}

float get_position(uint32_t now) {
    if (autoAdvance.value()) {


        float elapsedSeconds = (now - lastUpdateTime) / 1000.0f;
        float increment = elapsedSeconds * speed.value() *
                          0.3f;
        currentPosition = fmodf(currentPosition + increment, 1.0f);
        lastUpdateTime = now;
        return currentPosition;
    } else {

        float combinedPosition = positionCoarse.value() + positionFine.value() + positionExtraFine.value();

        if (combinedPosition > 1.0f)
            combinedPosition = 1.0f;
        return combinedPosition;
    }
}

void fillFrameBufferNoise() {

    uint8_t noise_scale = noiseScale.value();
    uint8_t noise_speed = noiseSpeed.value();


    uint32_t now = millis();
    uint16_t noise_z = now * noise_speed / 10;
    uint16_t noise_x = now * noise_speed / 80;
    uint16_t noise_y = now * noise_speed / 160;

    int width = frameBuffer.width();
    int height = frameBuffer.height();


    uint8_t dataSmoothing = 0;
    if(noise_speed < 50) {
        dataSmoothing = 200 - (noise_speed * 4);
    }


    for(int x = 0; x < width; x++) {
        for(int y = 0; y < height; y++) {


            float angle = (float(x) / float(width)) * 2.0f * 3.1415926535897932384626433832795;



            float cylinder_radius = noise_scale;


            float noise_x_cyl = cos(angle) * cylinder_radius;
            float noise_y_cyl = sin(angle) * cylinder_radius;
            float noise_z_height = float(y) * noise_scale;


            int xoffset = int(noise_x_cyl) + noise_x;
            int yoffset = int(noise_y_cyl) + noise_y;
            int zoffset = int(noise_z_height) + noise_z;


            uint8_t data = inoise8(xoffset, yoffset, zoffset);


            data = qsub8(data, 16);
            data = qadd8(data, scale8(data, 39));


            if(dataSmoothing) {
                CRGB oldColor = frameBuffer.at(x, y);
                uint8_t olddata = (oldColor.r + oldColor.g + oldColor.b) / 3;
                uint8_t newdata = scale8(olddata, dataSmoothing) + scale8(data, 256 - dataSmoothing);
                data = newdata;
            }


            uint8_t index = data;
            uint8_t bri = data;


            uint8_t ihue = 0;
            if(colorLoop) {
                ihue = (now / 100) % 256;
                index += ihue;
            }
# 504 "curr.h"
            CRGB color = ColorFromPalette(noisePalette, index, bri);


            EaseType sat_ease = getEaseType(saturationFunction.value());
            EaseType lum_ease = getEaseType(luminanceFunction.value());
            color = color.colorBoost(sat_ease, lum_ease);

            frameBuffer.at(x, y) = color;
        }
    }
}

void drawNoise(uint32_t now) {
    (void)(now);
    fillFrameBufferNoise();
}

void draw(float pos) {


    if (splatRendering) {
        Tile2x2_u8_wrap pos_tile = corkscrew.at_wrap(pos);
        fl::println( (fl::StrStream() << (fl::fastled_file_offset("curr.h")) << "(" << 526 << "): " << "pos_tile: " << pos_tile) .c_str());
        CRGB color = CRGB::Blue;

        EaseType sat_ease = getEaseType(saturationFunction.value());
        EaseType lum_ease = getEaseType(luminanceFunction.value());
        color = color.colorBoost(sat_ease, lum_ease);

        for (int dx = 0; dx < 2; ++dx) {
            for (int dy = 0; dy < 2; ++dy) {
                Tile2x2_u8_wrap::Entry data = pos_tile.at(dx, dy);
                vec2i16 wrapped_pos = data.first;
                uint8_t alpha = data.second;

                if (alpha > 0) {
                    CRGB c = color;
                    c.nscale8(alpha);
                    frameBuffer.at(wrapped_pos.x, wrapped_pos.y) = c;
                }
            }
        }
    } else {

        vec2f pos_vec2f = corkscrew.at_no_wrap(pos);
        vec2i16 pos_i16 = vec2i16(pos_vec2f.x, pos_vec2f.y);

        CRGB color = CRGB::Blue;

        EaseType sat_ease = getEaseType(saturationFunction.value());
        EaseType lum_ease = getEaseType(luminanceFunction.value());
        color = color.colorBoost(sat_ease, lum_ease);



        frameBuffer.at(pos_i16.x, pos_i16.y) = color;
    }
}

CRGBPalette16 getFirePalette() {
    int paletteIndex = (int)firePalette.value();
    switch (paletteIndex) {
    case 0:
        return firepal;
    case 1:
        return electricGreenFirePal;
    case 2:
        return electricBlueFirePal;
    default:
        return firepal;
    }
}

uint8_t getFirePaletteIndex(uint32_t millis32, int width, int max_width, int height, int max_height,
                        uint32_t y_speed) {
    uint16_t scale = fireScaleXY.as<uint16_t>();

    float xf = (float)width / (float)max_width;
    uint8_t x = (uint8_t)(xf * 255);

    uint32_t cosx = cos8(x);
    uint32_t sinx = sin8_C(x);

    float trig_scale = scale * fireScaleX.value();
    cosx *= trig_scale;
    sinx *= trig_scale;

    uint32_t y = height * scale + y_speed;

    uint16_t z = millis32 / fireInvSpeedZ.as<uint16_t>();

    uint16_t noise16 = inoise16(cosx << 8, sinx << 8, y << 8, z << 8);

    uint8_t noise_val = noise16 >> 8;

    int8_t subtraction_factor = abs8(height - (max_height - 1)) * 255 /
                                (max_height - 1);

    return qsub8(noise_val, subtraction_factor);
}

void fillFrameBufferFire(uint32_t now) {
    CRGBPalette16 myPal = getFirePalette();


    uint32_t y_speed = now * fireSpeedY.value();

    int width = frameBuffer.width();
    int height = frameBuffer.height();


    for (int w = 0; w < width; w++) {
        for (int h = 0; h < height; h++) {

            uint8_t palette_index =
                getFirePaletteIndex(now, w, width, h, height, y_speed);


            CRGB color = ColorFromPalette(myPal, palette_index, 255);


            EaseType sat_ease = getEaseType(saturationFunction.value());
            EaseType lum_ease = getEaseType(luminanceFunction.value());
            color = color.colorBoost(sat_ease, lum_ease);



            frameBuffer.at((width - 1) - w, (height - 1) - h) = color;
        }
    }
}

void drawFire(uint32_t now) {
    fillFrameBufferFire(now);
}


CRGBPalette16 getWavePalette() {
    int paletteIndex = (int)wavePalette.value();
    switch (paletteIndex) {
    case 0:
        return waveBluepal;
    case 1:
        return waveGreenpal;
    case 2:
        return waveRainbowpal;
    default:
        return waveBluepal;
    }
}

void triggerWaveRipple() {

    float perc = 0.15f;
    int width = frameBuffer.width();
    int height = frameBuffer.height();

    int min_x = perc * width;
    int max_x = (1 - perc) * width;
    int min_y = perc * height;
    int max_y = (1 - perc) * height;

    int x = random(min_x, max_x);
    int y = random(min_y, max_y);


    waveFx->setf(x, y, 1.0f);

    fl::println( (fl::StrStream() << (fl::fastled_file_offset("curr.h")) << "(" << 672 << "): " << "Wave ripple triggered at (" << x << ", " << y << ")") .c_str());
}

void processWaveAutoTrigger(uint32_t now) {

    if (waveAutoTrigger.value()) {
        if (now >= nextWaveTrigger) {
            triggerWaveRipple();


            float speed = 1.0f - waveTriggerSpeed.value();
            uint32_t min_interval = 500 * speed;
            uint32_t max_interval = 3000 * speed;


            uint32_t min = fl::fl_min(min_interval, max_interval);
            uint32_t max = fl::fl_max(min_interval, max_interval);
            if (min == max) max += 1;

            nextWaveTrigger = now + random(min, max);
        }
    }
}

void drawWave(uint32_t now) {

    waveFx->setSpeed(waveSpeed.value());
    waveFx->setDampening(waveDampening.value());
    waveFx->setHalfDuplex(waveHalfDuplex.value());
    waveFx->setXCylindrical(true);


    CRGBPalette16 currentPalette = getWavePalette();
    WaveCrgbMapPtr newCrgbMap = WaveCrgbGradientMapPtr::New(currentPalette);
    waveFx->setCrgbMap(newCrgbMap);


    if (waveTriggerButton.value()) {
        triggerWaveRipple();
    }


    processWaveAutoTrigger(now);



    Fx::DrawContext waveContext(now, frameBuffer.data());
    waveBlend->draw(waveContext);
}

void drawAnimartrix(uint32_t now) {

    fxEngine->setSpeed(animartrixTimeSpeed.value());


    static int lastAnimartrixIndex = -1;
    if (animartrixIndex.value() != lastAnimartrixIndex) {
        lastAnimartrixIndex = animartrixIndex.value();
        animartrix->fxSet(animartrixIndex.value());
    }


    fxEngine->draw(now, frameBuffer.data());
}

void loop() {
    delay(4);
    uint32_t now = millis();
    clear(frameBuffer);

    if (allWhite) {
        CRGB whiteColor = CRGB(8, 8, 8);
        for (size_t i = 0; i < frameBuffer.size(); ++i) {
            frameBuffer.data()[i] = whiteColor;
        }
    }


    float combinedPosition = get_position(now);
    float pos = combinedPosition * (corkscrew.size() - 1);


    if (renderModeDropdown.value() == "Noise") {
        drawNoise(now);
    } else if (renderModeDropdown.value() == "Fire") {
        drawFire(now);
    } else if (renderModeDropdown.value() == "Wave") {
        drawWave(now);
    } else if (renderModeDropdown.value() == "Animartrix") {
        drawAnimartrix(now);
    } else {
        draw(pos);
    }





    const bool use_multi_sampling = splatRendering;
    corkscrew.readFrom(frameBuffer, use_multi_sampling);



    FastLED.setBrightness(brightness.value());
    FastLED.show();
}
# 13 "FestivalStick.cpp" 2
